/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/teams/{team_id}/top/reactions": {
    /**
     * Get a list of the top reactions for a team. 
     * @description Get a list of the top reactions across all public and private channels (the user is a member of) for a given team.
     * ##### Permissions
     * Must have `view_team` permission for the team.
     */
    get: operations["GetTopReactionsForTeam"];
  };
  "/users/me/top/reactions": {
    /**
     * Get a list of the top reactions for a user. 
     * @description Get a list of the top reactions across all public and private channels (the user is a member of) for a given user.
     * If no `team_id` is provided, this will also include reactions posted by the given user in direct and group messages.
     * ##### Permissions
     * Must be logged in as the user.
     */
    get: operations["GetTopReactionsForUser"];
  };
  "/teams/{team_id}/top/channels": {
    /**
     * Get a list of the top channels for a team. 
     * @description Get a list of the top public and private channels (the user is a member of) for a given team.
     * ##### Permissions
     * Must have `view_team` permission for the team.
     */
    get: operations["GetTopChannelsForTeam"];
  };
  "/users/me/top/channels": {
    /**
     * Get a list of the top channels for a user. 
     * @description Get a list of the top public and private channels (the user is a member of) for a given user.
     * ##### Permissions
     * Must be logged in as the user.
     */
    get: operations["GetTopChannelsForUser"];
  };
  "/teams/{team_id}/top/team_members": {
    /**
     * Get a list of new team members. 
     * @description Get a list of all of the new team members that have joined the given team during the given time period.
     * ##### Permissions
     * Must have `view_team` permission for the team.
     */
    get: operations["GetNewTeamMembers"];
  };
  "/teams/{team_id}/top/threads": {
    /**
     * Get a list of the top threads for a team. 
     * @description Get a list of the top threads from public and private channels (the user is a member of) for a given team.
     * ##### Permissions
     * Must have `view_team` permission for the team.
     */
    get: operations["GetTopThreadsForTeam"];
  };
  "/users/me/top/threads": {
    /**
     * Get a list of the top threads for a user. 
     * @description Get a list of the top threads from public and private channels (the user is a member of and participating in the thread) for a given user.
     * ##### Permissions
     * Must be logged in as the user.
     */
    get: operations["GetTopThreadsForUser"];
  };
  "/users/me/top/dms": {
    /**
     * Get a list of the top dms for a user. 
     * @description Get a list of the top dms for a given user.
     * ##### Permissions
     * Must be logged in as the user.
     */
    get: operations["GetTopDMsForUser"];
  };
  "/users/login": {
    /**
     * Login to Mattermost server 
     * @description ##### Permissions
     * No permission required
     */
    post: operations["Login"];
  };
  "/users/login/cws": {
    /**
     * Auto-Login to Mattermost server using CWS token 
     * @description CWS stands for Customer Web Server which is the cloud service used to manage cloud instances.
     * ##### Permissions
     * A Cloud license is required
     */
    post: operations["LoginByCwsToken"];
  };
  "/users/logout": {
    /**
     * Logout from the Mattermost server 
     * @description ##### Permissions
     * An active session is required
     */
    post: operations["Logout"];
  };
  "/users": {
    /**
     * Get users 
     * @description Get a page of a list of users. Based on query string parameters, select users from a team, channel, or select users not in a specific channel.
     * 
     * Since server version 4.0, some basic sorting is available using the `sort` query parameter. Sorting is currently only supported when selecting users on a team.
     * ##### Permissions
     * Requires an active session and (if specified) membership to the channel or team being selected from.
     */
    get: operations["GetUsers"];
    /**
     * Create a user 
     * @description Create a new user on the system. Password is required for email login. For other authentication types such as LDAP or SAML, auth_data and auth_service fields are required.
     * ##### Permissions
     * No permission required for creating email/username accounts on an open server. Auth Token is required for other authentication types such as LDAP or SAML.
     */
    post: operations["CreateUser"];
    /**
     * Permanent delete all users 
     * @description Permanently deletes all users and all their related information, including posts.
     * 
     * __Minimum server version__: 5.26.0
     * 
     * __Local mode only__: This endpoint is only available through [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
     */
    delete: operations["PermanentDeleteAllUsers"];
  };
  "/users/ids": {
    /**
     * Get users by ids 
     * @description Get a list of users based on a provided list of user ids.
     * ##### Permissions
     * Requires an active session but no other permissions.
     */
    post: operations["GetUsersByIds"];
  };
  "/users/group_channels": {
    /**
     * Get users by group channels ids 
     * @description Get an object containing a key per group channel id in the
     * query and its value as a list of users members of that group
     * channel.
     * 
     * The user must be a member of the group ids in the query, or
     * they will be omitted from the response.
     * ##### Permissions
     * Requires an active session but no other permissions.
     * 
     * __Minimum server version__: 5.14
     */
    post: operations["GetUsersByGroupChannelIds"];
  };
  "/users/usernames": {
    /**
     * Get users by usernames 
     * @description Get a list of users based on a provided list of usernames.
     * ##### Permissions
     * Requires an active session but no other permissions.
     */
    post: operations["GetUsersByUsernames"];
  };
  "/users/search": {
    /**
     * Search users 
     * @description Get a list of users based on search criteria provided in the request body. Searches are typically done against username, full name, nickname and email unless otherwise configured by the server.
     * ##### Permissions
     * Requires an active session and `read_channel` and/or `view_team` permissions for any channels or teams specified in the request body.
     */
    post: operations["SearchUsers"];
  };
  "/users/autocomplete": {
    /**
     * Autocomplete users 
     * @description Get a list of users for the purpose of autocompleting based on the provided search term. Specify a combination of `team_id` and `channel_id` to filter results further.
     * ##### Permissions
     * Requires an active session and `view_team` and `read_channel` on any teams or channels used to filter the results further.
     */
    get: operations["AutocompleteUsers"];
  };
  "/users/known": {
    /**
     * Get user IDs of known users 
     * @description Get the list of user IDs of users with any direct relationship with a
     * user. That means any user sharing any channel, including direct and
     * group channels.
     * ##### Permissions
     * Must be authenticated.
     * 
     * __Minimum server version__: 5.23
     */
    get: operations["GetKnownUsers"];
  };
  "/users/stats": {
    /**
     * Get total count of users in the system 
     * @description Get a total count of users in the system.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetTotalUsersStats"];
  };
  "/users/stats/filtered": {
    /**
     * Get total count of users in the system matching the specified filters 
     * @description Get a count of users in the system matching the specified filters.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetTotalUsersStatsFiltered"];
  };
  "/users/{user_id}": {
    /**
     * Get a user 
     * @description Get a user a object. Sensitive information will be sanitized out.
     * ##### Permissions
     * Requires an active session but no other permissions.
     */
    get: operations["GetUser"];
    /**
     * Update a user 
     * @description Update a user by providing the user object. The fields that can be updated are defined in the request body, all other provided fields will be ignored. Any fields not included in the request body will be set to null or reverted to default values.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    put: operations["UpdateUser"];
    /**
     * Deactivate a user account. 
     * @description Deactivates the user and revokes all its sessions by archiving its user object.
     * 
     * As of server version 5.28, optionally use the `permanent=true` query parameter to permanently delete the user for compliance reasons. To use this feature `ServiceSettings.EnableAPIUserDeletion` must be set to `true` in the server's configuration.
     * ##### Permissions
     * Must be logged in as the user being deactivated or have the `edit_other_users` permission.
     */
    delete: operations["DeleteUser"];
  };
  "/users/{user_id}/patch": {
    /**
     * Patch a user 
     * @description Partially update a user by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    put: operations["PatchUser"];
  };
  "/users/{user_id}/roles": {
    /**
     * Update a user's roles 
     * @description Update a user's system-level roles. Valid user roles are "system_user", "system_admin" or both of them. Overwrites any previously assigned system-level roles.
     * ##### Permissions
     * Must have the `manage_roles` permission.
     */
    put: operations["UpdateUserRoles"];
  };
  "/users/{user_id}/active": {
    /**
     * Update user active status 
     * @description Update user active or inactive status.
     * 
     * __Since server version 4.6, users using a SSO provider to login can be activated or deactivated with this endpoint. However, if their activation status in Mattermost does not reflect their status in the SSO provider, the next synchronization or login by that user will reset the activation status to that of their account in the SSO provider. Server versions 4.5 and before do not allow activation or deactivation of SSO users from this endpoint.__
     * ##### Permissions
     * User can deactivate themselves.
     * User with `manage_system` permission can activate or deactivate a user.
     */
    put: operations["UpdateUserActive"];
  };
  "/users/{user_id}/image": {
    /**
     * Get user's profile image 
     * @description Get a user's profile image based on user_id string parameter.
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetProfileImage"];
    /**
     * Set user's profile image 
     * @description Set a user's profile image based on user_id string parameter.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    post: operations["SetProfileImage"];
    /**
     * Delete user's profile image 
     * @description Delete user's profile image and reset to default image based on user_id string parameter.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     * __Minimum server version__: 5.5
     */
    delete: operations["SetDefaultProfileImage"];
  };
  "/users/{user_id}/image/default": {
    /**
     * Return user's default (generated) profile image 
     * @description Returns the default (generated) user profile image based on user_id string parameter.
     * ##### Permissions
     * Must be logged in.
     * __Minimum server version__: 5.5
     */
    get: operations["GetDefaultProfileImage"];
  };
  "/users/username/{username}": {
    /**
     * Get a user by username 
     * @description Get a user object by providing a username. Sensitive information will be sanitized out.
     * ##### Permissions
     * Requires an active session but no other permissions.
     */
    get: operations["GetUserByUsername"];
  };
  "/users/password/reset": {
    /**
     * Reset password 
     * @description Update the password for a user using a one-use, timed recovery code tied to the user's account. Only works for non-SSO users.
     * ##### Permissions
     * No permissions required.
     */
    post: operations["ResetPassword"];
  };
  "/users/{user_id}/mfa": {
    /**
     * Update a user's MFA 
     * @description Activates multi-factor authentication for the user if `activate` is true and a valid `code` is provided. If activate is false, then `code` is not required and multi-factor authentication is disabled for the user.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    put: operations["UpdateUserMfa"];
  };
  "/users/{user_id}/mfa/generate": {
    /**
     * Generate MFA secret 
     * @description Generates an multi-factor authentication secret for a user and returns it as a string and as base64 encoded QR code image.
     * ##### Permissions
     * Must be logged in as the user or have the `edit_other_users` permission.
     */
    post: operations["GenerateMfaSecret"];
  };
  "/users/{user_id}/demote": {
    /**
     * Demote a user to a guest 
     * @description Convert a regular user into a guest. This will convert the user into a
     * guest for the whole system while retaining their existing team and
     * channel memberships.
     * 
     * __Minimum server version__: 5.16
     * 
     * ##### Permissions
     * Must be logged in as the user or have the `demote_to_guest` permission.
     */
    post: operations["DemoteUserToGuest"];
  };
  "/users/{user_id}/promote": {
    /**
     * Promote a guest to user 
     * @description Convert a guest into a regular user. This will convert the guest into a
     * user for the whole system while retaining any team and channel
     * memberships and automatically joining them to the default channels.
     * 
     * __Minimum server version__: 5.16
     * 
     * ##### Permissions
     * Must be logged in as the user or have the `promote_guest` permission.
     */
    post: operations["PromoteGuestToUser"];
  };
  "/users/{user_id}/convert_to_bot": {
    /**
     * Convert a user into a bot 
     * @description Convert a user into a bot.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["ConvertUserToBot"];
  };
  "/users/mfa": {
    /**
     * Check MFA 
     * @description Check if a user has multi-factor authentication active on their account by providing a login id. Used to check whether an MFA code needs to be provided when logging in.
     * ##### Permissions
     * No permission required.
     */
    post: operations["CheckUserMfa"];
  };
  "/users/{user_id}/password": {
    /**
     * Update a user's password 
     * @description Update a user's password. New password must meet password policy set by server configuration. Current password is required if you're updating your own password.
     * ##### Permissions
     * Must be logged in as the user the password is being changed for or have `manage_system` permission.
     */
    put: operations["UpdateUserPassword"];
  };
  "/users/password/reset/send": {
    /**
     * Send password reset email 
     * @description Send an email containing a link for resetting the user's password. The link will contain a one-use, timed recovery code tied to the user's account. Only works for non-SSO users.
     * ##### Permissions
     * No permissions required.
     */
    post: operations["SendPasswordResetEmail"];
  };
  "/users/email/{email}": {
    /**
     * Get a user by email 
     * @description Get a user object by providing a user email. Sensitive information will be sanitized out.
     * ##### Permissions
     * Requires an active session and for the current session to be able to view another user's email based on the server's privacy settings.
     */
    get: operations["GetUserByEmail"];
  };
  "/users/{user_id}/sessions": {
    /**
     * Get user's sessions 
     * @description Get a list of sessions by providing the user GUID. Sensitive information will be sanitized out.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    get: operations["GetSessions"];
  };
  "/users/{user_id}/sessions/revoke": {
    /**
     * Revoke a user session 
     * @description Revokes a user session from the provided user id and session id strings.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    post: operations["RevokeSession"];
  };
  "/users/{user_id}/sessions/revoke/all": {
    /**
     * Revoke all active sessions for a user 
     * @description Revokes all user sessions from the provided user id and session id strings.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     * __Minimum server version__: 4.4
     */
    post: operations["RevokeAllSessions"];
  };
  "/users/sessions/device": {
    /**
     * Attach mobile device 
     * @description Attach a mobile device id to the currently logged in session. This will enable push notifications for a user, if configured by the server.
     * ##### Permissions
     * Must be authenticated.
     */
    put: operations["AttachDeviceId"];
  };
  "/users/{user_id}/audits": {
    /**
     * Get user's audits 
     * @description Get a list of audit by providing the user GUID.
     * ##### Permissions
     * Must be logged in as the user or have the `edit_other_users` permission.
     */
    get: operations["GetUserAudits"];
  };
  "/users/{user_id}/email/verify/member": {
    /**
     * Verify user email by ID 
     * @description Verify the email used by a user without a token.
     * 
     * __Minimum server version__: 5.24
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission.
     */
    post: operations["VerifyUserEmailWithoutToken"];
  };
  "/users/email/verify": {
    /**
     * Verify user email 
     * @description Verify the email used by a user to sign-up their account with.
     * ##### Permissions
     * No permissions required.
     */
    post: operations["VerifyUserEmail"];
  };
  "/users/email/verify/send": {
    /**
     * Send verification email 
     * @description Send an email with a verification link to a user that has an email matching the one in the request body. This endpoint will return success even if the email does not match any users on the system.
     * ##### Permissions
     * No permissions required.
     */
    post: operations["SendVerificationEmail"];
  };
  "/users/login/switch": {
    /**
     * Switch login method 
     * @description Switch a user's login method from using email to OAuth2/SAML/LDAP or back to email. When switching to OAuth2/SAML, account switching is not complete until the user follows the returned link and completes any steps on the OAuth2/SAML service provider.
     * 
     * To switch from email to OAuth2/SAML, specify `current_service`, `new_service`, `email` and `password`.
     * 
     * To switch from OAuth2/SAML to email, specify `current_service`, `new_service`, `email` and `new_password`.
     * 
     * To switch from email to LDAP/AD, specify `current_service`, `new_service`, `email`, `password`, `ldap_ip` and `new_password` (this is the user's LDAP password).
     * 
     * To switch from LDAP/AD to email, specify `current_service`, `new_service`, `ldap_ip`, `password` (this is the user's LDAP password), `email`  and `new_password`.
     * 
     * Additionally, specify `mfa_code` when trying to switch an account on LDAP/AD or email that has MFA activated.
     * 
     * ##### Permissions
     * No current authentication required except when switching from OAuth2/SAML to email.
     */
    post: operations["SwitchAccountType"];
  };
  "/users/{user_id}/tokens": {
    /**
     * Get user access tokens 
     * @description Get a list of user access tokens for a user. Does not include the actual authentication tokens. Use query parameters for paging.
     * 
     * __Minimum server version__: 4.1
     * 
     * ##### Permissions
     * Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    get: operations["GetUserAccessTokensForUser"];
    /**
     * Create a user access token 
     * @description Generate a user access token that can be used to authenticate with the Mattermost REST API.
     * 
     * __Minimum server version__: 4.1
     * 
     * ##### Permissions
     * Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    post: operations["CreateUserAccessToken"];
  };
  "/users/tokens": {
    /**
     * Get user access tokens 
     * @description Get a page of user access tokens for users on the system. Does not include the actual authentication tokens. Use query parameters for paging.
     * 
     * __Minimum server version__: 4.7
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetUserAccessTokens"];
  };
  "/users/tokens/revoke": {
    /**
     * Revoke a user access token 
     * @description Revoke a user access token and delete any sessions using the token.
     * 
     * __Minimum server version__: 4.1
     * 
     * ##### Permissions
     * Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    post: operations["RevokeUserAccessToken"];
  };
  "/users/tokens/{token_id}": {
    /**
     * Get a user access token 
     * @description Get a user access token. Does not include the actual authentication token.
     * 
     * __Minimum server version__: 4.1
     * 
     * ##### Permissions
     * Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    get: operations["GetUserAccessToken"];
  };
  "/users/tokens/disable": {
    /**
     * Disable personal access token 
     * @description Disable a personal access token and delete any sessions using the token. The token can be re-enabled using `/users/tokens/enable`.
     * 
     * __Minimum server version__: 4.4
     * 
     * ##### Permissions
     * Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    post: operations["DisableUserAccessToken"];
  };
  "/users/tokens/enable": {
    /**
     * Enable personal access token 
     * @description Re-enable a personal access token that has been disabled.
     * 
     * __Minimum server version__: 4.4
     * 
     * ##### Permissions
     * Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
     */
    post: operations["EnableUserAccessToken"];
  };
  "/users/tokens/search": {
    /**
     * Search tokens 
     * @description Get a list of tokens based on search criteria provided in the request body. Searches are done against the token id, user id and username.
     * 
     * __Minimum server version__: 4.7
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["SearchUserAccessTokens"];
  };
  "/users/{user_id}/auth": {
    /**
     * Update a user's authentication method 
     * @description Updates a user's authentication method. This can be used to change them to/from LDAP authentication for example.
     * 
     * __Minimum server version__: 4.6
     * ##### Permissions
     * Must have the `edit_other_users` permission.
     */
    put: operations["UpdateUserAuth"];
  };
  "/users/{user_id}/terms_of_service": {
    /**
     * Fetches user's latest terms of service action if the latest action was for acceptance. 
     * @description Will be deprecated in v6.0
     * Fetches user's latest terms of service action if the latest action was for acceptance.
     * 
     * __Minimum server version__: 5.6
     * ##### Permissions
     * Must be logged in as the user being acted on.
     */
    get: operations["GetUserTermsOfService"];
    /**
     * Records user action when they accept or decline custom terms of service 
     * @description Records user action when they accept or decline custom terms of service. Records the action in audit table.
     * Updates user's last accepted terms of service ID if they accepted it.
     * 
     * __Minimum server version__: 5.4
     * ##### Permissions
     * Must be logged in as the user being acted on.
     */
    post: operations["RegisterTermsOfServiceAction"];
  };
  "/users/sessions/revoke/all": {
    /**
     * Revoke all sessions from all users. 
     * @description For any session currently on the server (including admin) it will be revoked.
     * Clients will be notified to log out users.
     * 
     * __Minimum server version__: 5.14
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["RevokeSessionsFromAllUsers"];
  };
  "/users/{user_id}/typing": {
    /**
     * Publish a user typing websocket event. 
     * @description Notify users in the given channel via websocket that the given user is typing.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must have `manage_system` permission to publish for any user other than oneself.
     */
    post: operations["PublishUserTyping"];
  };
  "/users/{user_id}/uploads": {
    /**
     * Get uploads for a user 
     * @description Gets all the upload sessions belonging to a user.
     * 
     * __Minimum server version__: 5.28
     * 
     * ##### Permissions
     * Must be logged in as the user who created the upload sessions.
     */
    get: operations["GetUploadsForUser"];
  };
  "/users/{user_id}/channel_members": {
    /**
     * Get all channel members from all teams for a user 
     * @description Get all channel members from all teams for a user.
     * 
     * __Minimum server version__: 6.2.0
     * 
     * ##### Permissions
     * Logged in as the user, or have `edit_other_users` permission.
     */
    get: operations["GetChannelMembersWithTeamDataForUser"];
  };
  "/users/migrate_auth/ldap": {
    /**
     * Migrate user accounts authentication type to LDAP. 
     * @description Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to LDAP.
     * __Minimum server version__: 5.28
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["MigrateAuthToLdap"];
  };
  "/users/migrate_auth/saml": {
    /**
     * Migrate user accounts authentication type to SAML. 
     * @description Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to SAML.
     * __Minimum server version__: 5.28
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["MigrateAuthToSaml"];
  };
  "/users/{user_id}/teams/{team_id}/threads": {
    /**
     * Get all threads that user is following 
     * @description Get all threads that user is following
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    get: operations["GetUserThreads"];
  };
  "/users/{user_id}/teams/{team_id}/threads/mention_counts": {
    /**
     * Get all unread mention counts from followed threads, per-channel 
     * @description Get all unread mention counts from followed threads
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    get: operations["GetThreadMentionCountsByChannel"];
  };
  "/users/{user_id}/teams/{team_id}/threads/read": {
    /**
     * Mark all threads that user is following as read 
     * @description Mark all threads that user is following as read
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    put: operations["UpdateThreadsReadForUser"];
  };
  "/users/{user_id}/teams/{team_id}/threads/{thread_id}/read/{timestamp}": {
    /**
     * Mark a thread that user is following read state to the timestamp 
     * @description Mark a thread that user is following as read
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    put: operations["UpdateThreadReadForUser"];
  };
  "/users/{user_id}/teams/{team_id}/threads/{thread_id}/set_unread/{post_id}": {
    /**
     * Mark a thread that user is following as unread based on a post id 
     * @description Mark a thread that user is following as unread
     * 
     * __Minimum server version__: 6.7
     * 
     * ##### Permissions
     * Must have `read_channel` permission for the channel the thread is in or if the channel is public, have the `read_public_channels` permission for the team.
     * 
     * Must have `edit_other_users` permission if the user is not the one marking the thread for himself.
     */
    put: operations["SetThreadUnreadByPostId"];
  };
  "/users/{user_id}/teams/{team_id}/threads/{thread_id}/following": {
    /**
     * Start following a thread 
     * @description Start following a thread
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    put: operations["StartFollowingThread"];
    /**
     * Stop following a thread 
     * @description Stop following a thread
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    delete: operations["StopFollowingThread"];
  };
  "/users/{user_id}/teams/{team_id}/threads/{thread_id}": {
    /**
     * Get a thread followed by the user 
     * @description Get a thread
     * 
     * __Minimum server version__: 5.29
     * 
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    get: operations["GetUserThread"];
  };
  "/users/{user_id}/data_retention/team_policies": {
    /**
     * Get the policies which are applied to a user's teams 
     * @description Gets the policies which are applied to the all of the teams to which a user belongs.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must be logged in as the user or have the `manage_system` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetTeamPoliciesForUser"];
  };
  "/users/{user_id}/data_retention/channel_policies": {
    /**
     * Get the policies which are applied to a user's channels 
     * @description Gets the policies which are applied to the all of the channels to which a user belongs.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must be logged in as the user or have the `manage_system` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetChannelPoliciesForUser"];
  };
  "/users/{user_id}/status": {
    /**
     * Get user status 
     * @description Get user status by id from the server.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetUserStatus"];
    /**
     * Update user status 
     * @description Manually set a user's status. When setting a user's status, the status will remain that value until set "online" again, which will return the status to being automatically updated based on user activity.
     * ##### Permissions
     * Must have `edit_other_users` permission for the team.
     */
    put: operations["UpdateUserStatus"];
  };
  "/users/status/ids": {
    /**
     * Get user statuses by id 
     * @description Get a list of user statuses by id from the server.
     * ##### Permissions
     * Must be authenticated.
     */
    post: operations["GetUsersStatusesByIds"];
  };
  "/users/{user_id}/status/custom": {
    /**
     * Update user custom status 
     * @description Updates a user's custom status by setting the value in the user's props and updates the user. Also save the given custom status to the recent custom statuses in the user's props
     * ##### Permissions
     * Must be logged in as the user whose custom status is being updated.
     */
    put: operations["UpdateUserCustomStatus"];
    /**
     * Unsets user custom status 
     * @description Unsets a user's custom status by updating the user's props and updates the user
     * ##### Permissions
     * Must be logged in as the user whose custom status is being removed.
     */
    delete: operations["UnsetUserCustomStatus"];
  };
  "/users/{user_id}/status/custom/recent": {
    /**
     * Delete user's recent custom status 
     * @description Deletes a user's recent custom status by removing the specific status from the recentCustomStatuses in the user's props and updates the user.
     * ##### Permissions
     * Must be logged in as the user whose recent custom status is being deleted.
     */
    delete: operations["RemoveRecentCustomStatus"];
  };
  "/users/{user_id}/status/custom/recent/delete": {
    /**
     * Delete user's recent custom status 
     * @description Deletes a user's recent custom status by removing the specific status from the recentCustomStatuses in the user's props and updates the user.
     * ##### Permissions
     * Must be logged in as the user whose recent custom status is being deleted.
     */
    post: operations["PostUserRecentCustomStatusDelete"];
  };
  "/teams": {
    /**
     * Get teams 
     * @description For regular users only returns open teams. Users with the "manage_system" permission will return teams regardless of type. The result is based on query string parameters - page and per_page.
     * ##### Permissions
     * Must be authenticated. "manage_system" permission is required to show all teams.
     */
    get: operations["GetAllTeams"];
    /**
     * Create a team 
     * @description Create a new team on the system.
     * ##### Permissions
     * Must be authenticated and have the `create_team` permission.
     */
    post: operations["CreateTeam"];
  };
  "/teams/{team_id}": {
    /**
     * Get a team 
     * @description Get a team on the system.
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    get: operations["GetTeam"];
    /**
     * Update a team 
     * @description Update a team by providing the team object. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * Must have the `manage_team` permission.
     */
    put: operations["UpdateTeam"];
    /**
     * Delete a team 
     * @description Soft deletes a team, by marking the team as deleted in the database. Soft deleted teams will not be accessible in the user interface.
     * 
     * Optionally use the permanent query parameter to hard delete the team for compliance reasons. As of server version 5.0, to use this feature `ServiceSettings.EnableAPITeamDeletion` must be set to `true` in the server's configuration.
     * ##### Permissions
     * Must have the `manage_team` permission.
     */
    delete: operations["SoftDeleteTeam"];
  };
  "/teams/{team_id}/patch": {
    /**
     * Patch a team 
     * @description Partially update a team by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * Must have the `manage_team` permission.
     */
    put: operations["PatchTeam"];
  };
  "/teams/{team_id}/privacy": {
    /**
     * Update teams's privacy 
     * @description Updates team's privacy allowing changing a team from Public (open) to Private (invitation only) and back.
     * 
     * __Minimum server version__: 5.24
     * 
     * ##### Permissions
     * `manage_team` permission for the team of the team.
     */
    put: operations["UpdateTeamPrivacy"];
  };
  "/teams/{team_id}/restore": {
    /**
     * Restore a team 
     * @description Restore a team that was previously soft deleted.
     * 
     * __Minimum server version__: 5.24
     * 
     * ##### Permissions
     * Must have the `manage_team` permission.
     */
    post: operations["RestoreTeam"];
  };
  "/teams/name/{name}": {
    /**
     * Get a team by name 
     * @description Get a team based on provided name string
     * ##### Permissions
     * Must be authenticated, team type is open and have the `view_team` permission.
     */
    get: operations["GetTeamByName"];
  };
  "/teams/search": {
    /**
     * Search teams 
     * @description Search teams based on search term and options provided in the request body.
     * 
     * ##### Permissions
     * Logged in user only shows open teams
     * Logged in user with "manage_system" permission shows all teams
     */
    post: operations["SearchTeams"];
  };
  "/teams/name/{name}/exists": {
    /**
     * Check if team exists 
     * @description Check if the team exists based on a team name.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["TeamExists"];
  };
  "/users/{user_id}/teams": {
    /**
     * Get a user's teams 
     * @description Get a list of teams that a user is on.
     * ##### Permissions
     * Must be authenticated as the user or have the `manage_system` permission.
     */
    get: operations["GetTeamsForUser"];
  };
  "/teams/{team_id}/members": {
    /**
     * Get team members 
     * @description Get a page team members list based on query string parameters - team id, page and per page.
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    get: operations["GetTeamMembers"];
    /**
     * Add user to team 
     * @description Add user to the team by user_id.
     * ##### Permissions
     * Must be authenticated and team be open to add self. For adding another user, authenticated user must have the `add_user_to_team` permission.
     */
    post: operations["AddTeamMember"];
  };
  "/teams/members/invite": {
    /**
     * Add user to team from invite 
     * @description Using either an invite id or hash/data pair from an email invite link, add a user to a team.
     * ##### Permissions
     * Must be authenticated.
     */
    post: operations["AddTeamMemberFromInvite"];
  };
  "/teams/{team_id}/members/batch": {
    /**
     * Add multiple users to team 
     * @description Add a number of users to the team by user_id.
     * ##### Permissions
     * Must be authenticated. Authenticated user must have the `add_user_to_team` permission.
     */
    post: operations["AddTeamMembers"];
  };
  "/users/{user_id}/teams/members": {
    /**
     * Get team members for a user 
     * @description Get a list of team members for a user. Useful for getting the ids of teams the user is on and the roles they have in those teams.
     * ##### Permissions
     * Must be logged in as the user or have the `edit_other_users` permission.
     */
    get: operations["GetTeamMembersForUser"];
  };
  "/teams/{team_id}/members/{user_id}": {
    /**
     * Get a team member 
     * @description Get a team member on the system.
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    get: operations["GetTeamMember"];
    /**
     * Remove user from team 
     * @description Delete the team member object for a user, effectively removing them from a team.
     * ##### Permissions
     * Must be logged in as the user or have the `remove_user_from_team` permission.
     */
    delete: operations["RemoveTeamMember"];
  };
  "/teams/{team_id}/members/ids": {
    /**
     * Get team members by ids 
     * @description Get a list of team members based on a provided array of user ids.
     * ##### Permissions
     * Must have `view_team` permission for the team.
     */
    post: operations["GetTeamMembersByIds"];
  };
  "/teams/{team_id}/stats": {
    /**
     * Get a team stats 
     * @description Get a team stats on the system.
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    get: operations["GetTeamStats"];
  };
  "/teams/{team_id}/regenerate_invite_id": {
    /**
     * Regenerate the Invite ID from a Team 
     * @description Regenerates the invite ID used in invite links of a team
     * ##### Permissions
     * Must be authenticated and have the `manage_team` permission.
     */
    post: operations["RegenerateTeamInviteId"];
  };
  "/teams/{team_id}/image": {
    /**
     * Get the team icon 
     * @description Get the team icon of the team.
     * 
     * __Minimum server version__: 4.9
     * 
     * ##### Permissions
     * User must be authenticated. In addition, team must be open or the user must have the `view_team` permission.
     */
    get: operations["GetTeamIcon"];
    /**
     * Sets the team icon 
     * @description Sets the team icon for the team.
     * 
     * __Minimum server version__: 4.9
     * 
     * ##### Permissions
     * Must be authenticated and have the `manage_team` permission.
     */
    post: operations["SetTeamIcon"];
    /**
     * Remove the team icon 
     * @description Remove the team icon for the team.
     * 
     * __Minimum server version__: 4.10
     * 
     * ##### Permissions
     * Must be authenticated and have the `manage_team` permission.
     */
    delete: operations["RemoveTeamIcon"];
  };
  "/teams/{team_id}/members/{user_id}/roles": {
    /**
     * Update a team member roles 
     * @description Update a team member roles. Valid team roles are "team_user", "team_admin" or both of them. Overwrites any previously assigned team roles.
     * ##### Permissions
     * Must be authenticated and have the `manage_team_roles` permission.
     */
    put: operations["UpdateTeamMemberRoles"];
  };
  "/teams/{team_id}/members/{user_id}/schemeRoles": {
    /**
     * Update the scheme-derived roles of a team member. 
     * @description Update a team member's scheme_admin/scheme_user properties. Typically this should either be `scheme_admin=false, scheme_user=true` for ordinary team member, or `scheme_admin=true, scheme_user=true` for a team admin.
     * 
     * __Minimum server version__: 5.0
     * 
     * ##### Permissions
     * Must be authenticated and have the `manage_team_roles` permission.
     */
    put: operations["UpdateTeamMemberSchemeRoles"];
  };
  "/users/{user_id}/teams/unread": {
    /**
     * Get team unreads for a user 
     * @description Get the count for unread messages and mentions in the teams the user is a member of.
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetTeamsUnreadForUser"];
  };
  "/users/{user_id}/teams/{team_id}/unread": {
    /**
     * Get unreads for a team 
     * @description Get the unread mention and message counts for a team for the specified user.
     * ##### Permissions
     * Must be the user or have `edit_other_users` permission and have `view_team` permission for the team.
     */
    get: operations["GetTeamUnread"];
  };
  "/teams/{team_id}/invite/email": {
    /**
     * Invite users to the team by email 
     * @description Invite users to the existing team using the user's email.
     * 
     * The number of emails that can be sent is rate limited to 20 per hour with a burst of 20 emails. If the rate limit exceeds, the error message contains details on when to retry and when the timer will be reset.
     * ##### Permissions
     * Must have `invite_user` and `add_user_to_team` permissions for the team.
     */
    post: operations["InviteUsersToTeam"];
  };
  "/teams/{team_id}/invite-guests/email": {
    /**
     * Invite guests to the team by email 
     * @description Invite guests to existing team channels usign the user's email.
     * 
     * The number of emails that can be sent is rate limited to 20 per hour with a burst of 20 emails. If the rate limit exceeds, the error message contains details on when to retry and when the timer will be reset.
     * 
     * __Minimum server version__: 5.16
     * 
     * ##### Permissions
     * Must have `invite_guest` permission for the team.
     */
    post: operations["InviteGuestsToTeam"];
  };
  "/teams/invites/email": {
    /**
     * Invalidate active email invitations 
     * @description Invalidate active email invitations that have not been accepted by the user.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    delete: operations["InvalidateEmailInvites"];
  };
  "/teams/{team_id}/import": {
    /**
     * Import a Team from other application 
     * @description Import a team into a existing team. Import users, channels, posts, hooks.
     * ##### Permissions
     * Must have `permission_import_team` permission.
     */
    post: operations["ImportTeam"];
  };
  "/teams/invite/{invite_id}": {
    /**
     * Get invite info for a team 
     * @description Get the `name`, `display_name`, `description` and `id` for a team from the invite id.
     * 
     * __Minimum server version__: 4.0
     * 
     * ##### Permissions
     * No authentication required.
     */
    get: operations["GetTeamInviteInfo"];
  };
  "/teams/{team_id}/scheme": {
    /**
     * Set a team's scheme 
     * @description Set a team's scheme, more specifically sets the scheme_id value of a team record.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.0
     */
    put: operations["UpdateTeamScheme"];
  };
  "/teams/{team_id}/members_minus_group_members": {
    /**
     * Team members minus group members. 
     * @description Get the set of users who are members of the team minus the set of users who are members of the given groups.
     * Each user object contains an array of group objects representing the group memberships for that user.
     * Each user object contains the boolean fields `scheme_guest`, `scheme_user`, and `scheme_admin` representing the roles that user has for the given team.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.14
     */
    get: operations["TeamMembersMinusGroupMembers"];
  };
  "/channels": {
    /**
     * Get a list of all channels 
     * @description ##### Permissions
     * `manage_system`
     */
    get: operations["GetAllChannels"];
    /**
     * Create a channel 
     * @description Create a new channel.
     * ##### Permissions
     * If creating a public channel, `create_public_channel` permission is required. If creating a private channel, `create_private_channel` permission is required.
     */
    post: operations["CreateChannel"];
  };
  "/channels/direct": {
    /**
     * Create a direct message channel 
     * @description Create a new direct message channel between two users.
     * ##### Permissions
     * Must be one of the two users and have `create_direct_channel` permission. Having the `manage_system` permission voids the previous requirements.
     */
    post: operations["CreateDirectChannel"];
  };
  "/channels/group": {
    /**
     * Create a group message channel 
     * @description Create a new group message channel to group of users. If the logged in user's id is not included in the list, it will be appended to the end.
     * ##### Permissions
     * Must have `create_group_channel` permission.
     */
    post: operations["CreateGroupChannel"];
  };
  "/channels/search": {
    /**
     * Search all private and open type channels across all teams 
     * @description Returns all private and open type channels where 'term' matches on the name, display name, or purpose of
     * the channel.
     * 
     * Configured 'default' channels (ex Town Square and Off-Topic) can be excluded from the results
     * with the `exclude_default_channels` boolean parameter.
     * 
     * Channels that are associated (via GroupChannel records) to a given group can be excluded from the results
     * with the `not_associated_to_group` parameter and a group id string.
     */
    post: operations["SearchAllChannels"];
  };
  "/channels/group/search": {
    /**
     * Search Group Channels 
     * @description Get a list of group channels for a user which members' usernames match the search term.
     * 
     * __Minimum server version__: 5.14
     */
    post: operations["SearchGroupChannels"];
  };
  "/teams/{team_id}/channels/ids": {
    /**
     * Get a list of channels by ids 
     * @description Get a list of public channels on a team by id.
     * ##### Permissions
     * `view_team` for the team the channels are on.
     */
    post: operations["GetPublicChannelsByIdsForTeam"];
  };
  "/channels/{channel_id}/timezones": {
    /**
     * Get timezones in a channel 
     * @description Get a list of timezones for the users who are in this channel.
     * 
     * __Minimum server version__: 5.6
     * 
     * ##### Permissions
     * Must have the `read_channel` permission.
     */
    get: operations["GetChannelMembersTimezones"];
  };
  "/channels/{channel_id}": {
    /**
     * Get a channel 
     * @description Get channel from the provided channel id string.
     * ##### Permissions
     * `read_channel` permission for the channel.
     */
    get: operations["GetChannel"];
    /**
     * Update a channel 
     * @description Update a channel. The fields that can be updated are listed as parameters. Omitted fields will be treated as blanks.
     * ##### Permissions
     * If updating a public channel, `manage_public_channel_members` permission is required. If updating a private channel, `manage_private_channel_members` permission is required.
     */
    put: operations["UpdateChannel"];
    /**
     * Delete a channel 
     * @description Archives a channel. This will set the `deleteAt` to the current timestamp in the database. Soft deleted channels may not be accessible in the user interface. They can be viewed and unarchived in the **System Console > User Management > Channels** based on your license. Direct and group message channels cannot be deleted.
     * 
     * As of server version 5.28, optionally use the `permanent=true` query parameter to permanently delete the channel for compliance reasons. To use this feature `ServiceSettings.EnableAPIChannelDeletion` must be set to `true` in the server's configuration.  If you permanently delete a channel this action is not recoverable outside of a database backup.
     * 
     * ##### Permissions
     * `delete_public_channel` permission if the channel is public,
     * `delete_private_channel` permission if the channel is private,
     * or have `manage_system` permission.
     */
    delete: operations["DeleteChannel"];
  };
  "/channels/{channel_id}/patch": {
    /**
     * Patch a channel 
     * @description Partially update a channel by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * If updating a public channel, `manage_public_channel_members` permission is required. If updating a private channel, `manage_private_channel_members` permission is required.
     */
    put: operations["PatchChannel"];
  };
  "/channels/{channel_id}/privacy": {
    /**
     * Update channel's privacy 
     * @description Updates channel's privacy allowing changing a channel from Public to Private and back.
     * 
     * __Minimum server version__: 5.16
     * 
     * ##### Permissions
     * `manage_team` permission for the channels team on version < 5.28. `convert_public_channel_to_private` permission for the channel if updating privacy to 'P' on version >= 5.28. `convert_private_channel_to_public` permission for the channel if updating privacy to 'O' on version >= 5.28.
     */
    put: operations["UpdateChannelPrivacy"];
  };
  "/channels/{channel_id}/restore": {
    /**
     * Restore a channel 
     * @description Restore channel from the provided channel id string.
     * 
     * __Minimum server version__: 3.10
     * 
     * ##### Permissions
     * `manage_team` permission for the team of the channel.
     */
    post: operations["RestoreChannel"];
  };
  "/channels/{channel_id}/move": {
    /**
     * Move a channel 
     * @description Move a channel to another team.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission.
     */
    post: operations["MoveChannel"];
  };
  "/channels/{channel_id}/stats": {
    /**
     * Get channel statistics 
     * @description Get statistics for a channel.
     * ##### Permissions
     * Must have the `read_channel` permission.
     */
    get: operations["GetChannelStats"];
  };
  "/channels/{channel_id}/pinned": {
    /**
     * Get a channel's pinned posts 
     * @description Get a list of pinned posts for channel.
     */
    get: operations["GetPinnedPosts"];
  };
  "/teams/{team_id}/channels": {
    /**
     * Get public channels 
     * @description Get a page of public channels on a team based on query string parameters - page and per_page.
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    get: operations["GetPublicChannelsForTeam"];
  };
  "/teams/{team_id}/channels/private": {
    /**
     * Get private channels 
     * @description Get a page of private channels on a team based on query string
     * parameters - team_id, page and per_page.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetPrivateChannelsForTeam"];
  };
  "/teams/{team_id}/channels/deleted": {
    /**
     * Get deleted channels 
     * @description Get a page of deleted channels on a team based on query string parameters - team_id, page and per_page.
     * 
     * __Minimum server version__: 3.10
     */
    get: operations["GetDeletedChannelsForTeam"];
  };
  "/teams/{team_id}/channels/autocomplete": {
    /**
     * Autocomplete channels 
     * @description Autocomplete public channels on a team based on the search term provided in the request URL.
     * 
     * __Minimum server version__: 4.7
     * 
     * ##### Permissions
     * Must have the `list_team_channels` permission.
     */
    get: operations["AutocompleteChannelsForTeam"];
  };
  "/teams/{team_id}/channels/search_autocomplete": {
    /**
     * Autocomplete channels for search 
     * @description Autocomplete your channels on a team based on the search term provided in the request URL.
     * 
     * __Minimum server version__: 5.4
     * 
     * ##### Permissions
     * Must have the `list_team_channels` permission.
     */
    get: operations["AutocompleteChannelsForTeamForSearch"];
  };
  "/teams/{team_id}/channels/search": {
    /**
     * Search channels 
     * @description Search public channels on a team based on the search term provided in the request body.
     * ##### Permissions
     * Must have the `list_team_channels` permission.
     * 
     * In server version 5.16 and later, a user without the `list_team_channels` permission will be able to use this endpoint, with the search results limited to the channels that the user is a member of.
     */
    post: operations["SearchChannels"];
  };
  "/teams/{team_id}/channels/search_archived": {
    /**
     * Search archived channels 
     * @description Search archived channels on a team based on the search term provided in the request body.
     * 
     * __Minimum server version__: 5.18
     * 
     * ##### Permissions
     * Must have the `list_team_channels` permission.
     * 
     * In server version 5.18 and later, a user without the `list_team_channels` permission will be able to use this endpoint, with the search results limited to the channels that the user is a member of.
     */
    post: operations["SearchArchivedChannels"];
  };
  "/teams/{team_id}/channels/name/{channel_name}": {
    /**
     * Get a channel by name 
     * @description Gets channel from the provided team id and channel name strings.
     * ##### Permissions
     * `read_channel` permission for the channel.
     */
    get: operations["GetChannelByName"];
  };
  "/teams/name/{team_name}/channels/name/{channel_name}": {
    /**
     * Get a channel by name and team name 
     * @description Gets a channel from the provided team name and channel name strings.
     * ##### Permissions
     * `read_channel` permission for the channel.
     */
    get: operations["GetChannelByNameForTeamName"];
  };
  "/channels/{channel_id}/members": {
    /**
     * Get channel members 
     * @description Get a page of members for a channel.
     * ##### Permissions
     * `read_channel` permission for the channel.
     */
    get: operations["GetChannelMembers"];
    /**
     * Add user to channel 
     * @description Add a user to a channel by creating a channel member object.
     */
    post: operations["AddChannelMember"];
  };
  "/channels/{channel_id}/members/ids": {
    /**
     * Get channel members by ids 
     * @description Get a list of channel members based on the provided user ids.
     * ##### Permissions
     * Must have the `read_channel` permission.
     */
    post: operations["GetChannelMembersByIds"];
  };
  "/channels/{channel_id}/members/{user_id}": {
    /**
     * Get channel member 
     * @description Get a channel member.
     * ##### Permissions
     * `read_channel` permission for the channel.
     */
    get: operations["GetChannelMember"];
    /**
     * Remove user from channel 
     * @description Delete a channel member, effectively removing them from a channel.
     * 
     * In server version 5.3 and later, channel members can only be deleted from public or private channels.
     * ##### Permissions
     * `manage_public_channel_members` permission if the channel is public.
     * `manage_private_channel_members` permission if the channel is private.
     */
    delete: operations["RemoveUserFromChannel"];
  };
  "/channels/{channel_id}/members/{user_id}/roles": {
    /**
     * Update channel roles 
     * @description Update a user's roles for a channel.
     * ##### Permissions
     * Must have `manage_channel_roles` permission for the channel.
     */
    put: operations["UpdateChannelRoles"];
  };
  "/channels/{channel_id}/members/{user_id}/schemeRoles": {
    /**
     * Update the scheme-derived roles of a channel member. 
     * @description Update a channel member's scheme_admin/scheme_user properties. Typically this should either be `scheme_admin=false, scheme_user=true` for ordinary channel member, or `scheme_admin=true, scheme_user=true` for a channel admin.
     * __Minimum server version__: 5.0
     * ##### Permissions
     * Must be authenticated and have the `manage_channel_roles` permission.
     */
    put: operations["UpdateChannelMemberSchemeRoles"];
  };
  "/channels/{channel_id}/members/{user_id}/notify_props": {
    /**
     * Update channel notifications 
     * @description Update a user's notification properties for a channel. Only the provided fields are updated.
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission.
     */
    put: operations["UpdateChannelNotifyProps"];
  };
  "/channels/members/{user_id}/view": {
    /**
     * View channel 
     * @description Perform all the actions involved in viewing a channel. This includes marking channels as read, clearing push notifications, and updating the active channel.
     * ##### Permissions
     * Must be logged in as user or have `edit_other_users` permission.
     * 
     * __Response only includes `last_viewed_at_times` in Mattermost server 4.3 and newer.__
     */
    post: operations["ViewChannel"];
  };
  "/users/{user_id}/teams/{team_id}/channels/members": {
    /**
     * Get channel memberships and roles for a user 
     * @description Get all channel memberships and associated membership roles (i.e. `channel_user`, `channel_admin`) for a user on a specific team.
     * ##### Permissions
     * Logged in as the user and `view_team` permission for the team. Having `manage_system` permission voids the previous requirements.
     */
    get: operations["GetChannelMembersForUser"];
  };
  "/users/{user_id}/teams/{team_id}/channels": {
    /**
     * Get channels for user 
     * @description Get all the channels on a team for a user.
     * ##### Permissions
     * Logged in as the user, or have `edit_other_users` permission, and `view_team` permission for the team.
     */
    get: operations["GetChannelsForTeamForUser"];
  };
  "/users/{user_id}/channels": {
    /**
     * Get all channels from all teams 
     * @description Get all channels from all teams that a user is a member of.
     * 
     * __Minimum server version__: 6.1
     * 
     * ##### Permissions
     * 
     * Logged in as the user, or have `edit_other_users` permission.
     */
    get: operations["GetChannelsForUser"];
  };
  "/users/{user_id}/channels/{channel_id}/unread": {
    /**
     * Get unread messages 
     * @description Get the total unread messages and mentions for a channel for a user.
     * ##### Permissions
     * Must be logged in as user and have the `read_channel` permission, or have `edit_other_usrs` permission.
     */
    get: operations["GetChannelUnread"];
  };
  "/channels/{channel_id}/scheme": {
    /**
     * Set a channel's scheme 
     * @description Set a channel's scheme, more specifically sets the scheme_id value of a channel record.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.10
     */
    put: operations["UpdateChannelScheme"];
  };
  "/channels/{channel_id}/members_minus_group_members": {
    /**
     * Channel members minus group members. 
     * @description Get the set of users who are members of the channel minus the set of users who are members of the given groups.
     * Each user object contains an array of group objects representing the group memberships for that user.
     * Each user object contains the boolean fields `scheme_guest`, `scheme_user`, and `scheme_admin` representing the roles that user has for the given channel.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.14
     */
    get: operations["ChannelMembersMinusGroupMembers"];
  };
  "/channels/{channel_id}/member_counts_by_group": {
    /**
     * Channel members counts for each group that has atleast one member in the channel 
     * @description Returns a set of ChannelMemberCountByGroup objects which contain a `group_id`, `channel_member_count` and a `channel_member_timezones_count`.
     * ##### Permissions
     * Must have `read_channel` permission for the given channel.
     * __Minimum server version__: 5.24
     */
    get: operations["GetChannelMemberCountsByGroup"];
  };
  "/channels/{channel_id}/moderations": {
    /**
     * Get information about channel's moderation. 
     * @description ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.22
     */
    get: operations["GetChannelModerations"];
  };
  "/channels/{channel_id}/moderations/patch": {
    /**
     * Update a channel's moderation settings. 
     * @description ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.22
     */
    put: operations["PatchChannelModerations"];
  };
  "/users/{user_id}/teams/{team_id}/channels/categories": {
    /**
     * Get user's sidebar categories 
     * @description Get a list of sidebar categories that will appear in the user's sidebar on the given team, including a list of channel IDs in each category.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    get: operations["GetSidebarCategoriesForTeamForUser"];
    /**
     * Update user's sidebar categories 
     * @description Update any number of sidebar categories for the user on the given team. This can be used to reorder the channels in these categories.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    put: operations["UpdateSidebarCategoriesForTeamForUser"];
    /**
     * Create user's sidebar category 
     * @description Create a custom sidebar category for the user on the given team.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    post: operations["CreateSidebarCategoryForTeamForUser"];
  };
  "/users/{user_id}/teams/{team_id}/channels/categories/order": {
    /**
     * Get user's sidebar category order 
     * @description Returns the order of the sidebar categories for a user on the given team as an array of IDs.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    get: operations["GetSidebarCategoryOrderForTeamForUser"];
    /**
     * Update user's sidebar category order 
     * @description Updates the order of the sidebar categories for a user on the given team. The provided array must include the IDs of all categories on the team.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    put: operations["UpdateSidebarCategoryOrderForTeamForUser"];
  };
  "/users/{user_id}/teams/{team_id}/channels/categories/{category_id}": {
    /**
     * Get sidebar category 
     * @description Returns a single sidebar category for the user on the given team.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    get: operations["GetSidebarCategoryForTeamForUser"];
    /**
     * Update sidebar category 
     * @description Updates a single sidebar category for the user on the given team.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    put: operations["UpdateSidebarCategoryForTeamForUser"];
    /**
     * Delete sidebar category 
     * @description Deletes a single sidebar category for the user on the given team. Only custom categories can be deleted.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be authenticated and have the `list_team_channels` permission.
     */
    delete: operations["RemoveSidebarCategoryForTeamForUser"];
  };
  "/posts": {
    /**
     * Create a post 
     * @description Create a new post in a channel. To create the post as a comment on another post, provide `root_id`.
     * ##### Permissions
     * Must have `create_post` permission for the channel the post is being created in.
     */
    post: operations["CreatePost"];
  };
  "/posts/ephemeral": {
    /**
     * Create a ephemeral post 
     * @description Create a new ephemeral post in a channel.
     * ##### Permissions
     * Must have `create_post_ephemeral` permission (currently only given to system admin)
     */
    post: operations["CreatePostEphemeral"];
  };
  "/posts/{post_id}": {
    /**
     * Get a post 
     * @description Get a single post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
     */
    get: operations["GetPost"];
    /**
     * Update a post 
     * @description Update a post. Only the fields listed below are updatable, omitted fields will be treated as blank.
     * ##### Permissions
     * Must have `edit_post` permission for the channel the post is in.
     */
    put: operations["UpdatePost"];
    /**
     * Delete a post 
     * @description Soft deletes a post, by marking the post as deleted in the database. Soft deleted posts will not be returned in post queries.
     * ##### Permissions
     * Must be logged in as the user or have `delete_others_posts` permission.
     */
    delete: operations["DeletePost"];
  };
  "/users/{user_id}/posts/{post_id}/set_unread": {
    /**
     * Mark as unread from a post. 
     * @description Mark a channel as being unread from a given post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
     * Must have `edit_other_users` permission if the user is not the one marking the post for himself.
     * 
     * __Minimum server version__: 5.18
     */
    post: operations["SetPostUnread"];
  };
  "/posts/{post_id}/patch": {
    /**
     * Patch a post 
     * @description Partially update a post by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * Must have the `edit_post` permission.
     */
    put: operations["PatchPost"];
  };
  "/posts/{post_id}/thread": {
    /**
     * Get a thread 
     * @description Get a post and the rest of the posts in the same thread.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
     */
    get: operations["GetPostThread"];
  };
  "/users/{user_id}/posts/flagged": {
    /**
     * Get a list of flagged posts 
     * @description Get a page of flagged posts of a user provided user id string. Selects from a channel, team, or all flagged posts by a user. Will only return posts from channels in which the user is member.
     * ##### Permissions
     * Must be user or have `manage_system` permission.
     */
    get: operations["GetFlaggedPostsForUser"];
  };
  "/posts/{post_id}/files/info": {
    /**
     * Get file info for post 
     * @description Gets a list of file information objects for the files attached to a post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in.
     */
    get: operations["GetFileInfosForPost"];
  };
  "/channels/{channel_id}/posts": {
    /**
     * Get posts for a channel 
     * @description Get a page of posts in a channel. Use the query parameters to modify the behaviour of this endpoint. The parameter `since` must not be used with any of `before`, `after`, `page`, and `per_page` parameters.
     * If `since` is used, it will always return all posts modified since that time, ordered by their create time limited till 1000. A caveat with this parameter is that there is no guarantee that the returned posts will be consecutive. It is left to the clients to maintain state and fill any missing holes in the post order.
     * ##### Permissions
     * Must have `read_channel` permission for the channel.
     */
    get: operations["GetPostsForChannel"];
  };
  "/users/{user_id}/channels/{channel_id}/posts/unread": {
    /**
     * Get posts around oldest unread 
     * @description Get the oldest unread post in the channel for the given user as well as the posts around it. The returned list is sorted in descending order (most recent post first).
     * ##### Permissions
     * Must be logged in as the user or have `edit_other_users` permission, and must have `read_channel` permission for the channel.
     * __Minimum server version__: 5.14
     */
    get: operations["GetPostsAroundLastUnread"];
  };
  "/teams/{team_id}/posts/search": {
    /**
     * Search for team posts 
     * @description Search posts in the team and from the provided terms string.
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    post: operations["SearchPosts"];
  };
  "/posts/{post_id}/pin": {
    /**
     * Pin a post to the channel 
     * @description Pin a post to a channel it is in based from the provided post id string.
     * ##### Permissions
     * Must be authenticated and have the `read_channel` permission to the channel the post is in.
     */
    post: operations["PinPost"];
  };
  "/posts/{post_id}/unpin": {
    /**
     * Unpin a post to the channel 
     * @description Unpin a post to a channel it is in based from the provided post id string.
     * ##### Permissions
     * Must be authenticated and have the `read_channel` permission to the channel the post is in.
     */
    post: operations["UnpinPost"];
  };
  "/posts/{post_id}/actions/{action_id}": {
    /**
     * Perform a post action 
     * @description Perform a post action, which allows users to interact with integrations through posts.
     * ##### Permissions
     * Must be authenticated and have the `read_channel` permission to the channel the post is in.
     */
    post: operations["DoPostAction"];
  };
  "/posts/ids": {
    /**
     * Get posts by a list of ids 
     * @description Fetch a list of posts based on the provided postIDs
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
     */
    post: operations["getPostsByIds"];
  };
  "/users/{user_id}/posts/{post_id}/reminder": {
    /**
     * Set a post reminder 
     * @description Set a reminder for the user for the post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in.
     * 
     * __Minimum server version__: 7.2
     */
    post: operations["SetPostReminder"];
  };
  "/users/{user_id}/preferences": {
    /**
     * Get the user's preferences 
     * @description Get a list of the user's preferences.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    get: operations["GetPreferences"];
    /**
     * Save the user's preferences 
     * @description Save a list of the user's preferences.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    put: operations["UpdatePreferences"];
  };
  "/users/{user_id}/preferences/delete": {
    /**
     * Delete user's preferences 
     * @description Delete a list of the user's preferences.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    post: operations["DeletePreferences"];
  };
  "/users/{user_id}/preferences/{category}": {
    /**
     * List a user's preferences by category 
     * @description Lists the current user's stored preferences in the given category.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    get: operations["GetPreferencesByCategory"];
  };
  "/users/{user_id}/preferences/{category}/name/{preference_name}": {
    /**
     * Get a specific user preference 
     * @description Gets a single preference for the current user with the given category and name.
     * ##### Permissions
     * Must be logged in as the user being updated or have the `edit_other_users` permission.
     */
    get: operations["GetPreferencesByCategoryByName"];
  };
  "/files": {
    /**
     * Upload a file 
     * @description Uploads a file that can later be attached to a post.
     * 
     * This request can either be a multipart/form-data request with a channel_id, files and optional
     * client_ids defined in the FormData, or it can be a request with the channel_id and filename
     * defined as query parameters with the contents of a single file in the body of the request.
     * 
     * Only multipart/form-data requests are supported by server versions up to and including 4.7.
     * Server versions 4.8 and higher support both types of requests.
     * 
     * ##### Permissions
     * Must have `upload_file` permission.
     */
    post: operations["UploadFile"];
  };
  "/files/{file_id}": {
    /**
     * Get a file 
     * @description Gets a file that has been uploaded previously.
     * ##### Permissions
     * Must have `read_channel` permission or be uploader of the file.
     */
    get: operations["GetFile"];
  };
  "/files/{file_id}/thumbnail": {
    /**
     * Get a file's thumbnail 
     * @description Gets a file's thumbnail.
     * ##### Permissions
     * Must have `read_channel` permission or be uploader of the file.
     */
    get: operations["GetFileThumbnail"];
  };
  "/files/{file_id}/preview": {
    /**
     * Get a file's preview 
     * @description Gets a file's preview.
     * ##### Permissions
     * Must have `read_channel` permission or be uploader of the file.
     */
    get: operations["GetFilePreview"];
  };
  "/files/{file_id}/link": {
    /**
     * Get a public file link 
     * @description Gets a public link for a file that can be accessed without logging into Mattermost.
     * ##### Permissions
     * Must have `read_channel` permission or be uploader of the file.
     */
    get: operations["GetFileLink"];
  };
  "/files/{file_id}/info": {
    /**
     * Get metadata for a file 
     * @description Gets a file's info.
     * ##### Permissions
     * Must have `read_channel` permission or be uploader of the file.
     */
    get: operations["GetFileInfo"];
  };
  "/files/{file_id}/public": {
    /**
     * Get a public file 
     * @description ##### Permissions
     * No permissions required.
     */
    get: operations["GetFilePublic"];
  };
  "/teams/{team_id}/files/search": {
    /**
     * Search files in a team 
     * @description Search for files in a team based on file name, extention and file content (if file content extraction is enabled and supported for the files).
     * __Minimum server version__: 5.34
     * ##### Permissions
     * Must be authenticated and have the `view_team` permission.
     */
    post: operations["SearchFiles"];
  };
  "/uploads": {
    /**
     * Create an upload 
     * @description Creates a new upload session.
     * 
     * __Minimum server version__: 5.28
     * ##### Permissions
     * Must have `upload_file` permission.
     */
    post: operations["CreateUpload"];
  };
  "/uploads/{upload_id}": {
    /**
     * Get an upload session 
     * @description Gets an upload session that has been previously created.
     * 
     * ##### Permissions
     * Must be logged in as the user who created the upload session.
     */
    get: operations["GetUpload"];
    /**
     * Perform a file upload 
     * @description Starts or resumes a file upload.  
     * To resume an existing (incomplete) upload, data should be sent starting from the offset specified in the upload session object.
     * 
     * The request body can be in one of two formats:
     * - Binary file content streamed in request's body
     * - multipart/form-data
     * 
     * ##### Permissions
     * Must be logged in as the user who created the upload session.
     */
    post: operations["UploadData"];
  };
  "/jobs": {
    /**
     * Get the jobs. 
     * @description Get a page of jobs. Use the query parameters to modify the behaviour of this endpoint.
     * __Minimum server version: 4.1__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    get: operations["GetJobs"];
    /**
     * Create a new job. 
     * @description Create a new job.
     * __Minimum server version: 4.1__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    post: operations["CreateJob"];
  };
  "/jobs/{job_id}": {
    /**
     * Get a job. 
     * @description Gets a single job.
     * __Minimum server version: 4.1__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    get: operations["GetJob"];
  };
  "/jobs/{job_id}/download": {
    /**
     * Download the results of a job. 
     * @description Download the result of a single job.
     * __Minimum server version: 5.28__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    get: operations["DownloadJob"];
  };
  "/jobs/{job_id}/cancel": {
    /**
     * Cancel a job. 
     * @description Cancel a job.
     * __Minimum server version: 4.1__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    post: operations["CancelJob"];
  };
  "/jobs/type/{type}": {
    /**
     * Get the jobs of the given type. 
     * @description Get a page of jobs of the given type. Use the query parameters to modify the behaviour of this endpoint.
     * __Minimum server version: 4.1__
     * ##### Permissions
     * Must have `manage_jobs` permission.
     */
    get: operations["GetJobsByType"];
  };
  "/system/timezones": {
    /**
     * Retrieve a list of supported timezones 
     * @description __Minimum server version__: 3.10
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetSupportedTimezone"];
  };
  "/system/ping": {
    /**
     * Check system health 
     * @description Check if the server is up and healthy based on the configuration setting `GoRoutineHealthThreshold`. If `GoRoutineHealthThreshold` and the number of goroutines on the server exceeds that threshold the server is considered unhealthy. If `GoRoutineHealthThreshold` is not set or the number of goroutines is below the threshold the server is considered healthy.
     * __Minimum server version__: 3.10
     * If a "device_id" is passed in the query, it will test the Push Notification Proxy in order to discover whether the device is able to receive notifications. The response will have a "CanReceiveNotifications" property with one of the following values: - true: It can receive notifications - false: It cannot receive notifications - unknown: There has been an unknown error, and it is not certain whether it can
     *   receive notifications.
     * 
     * __Minimum server version__: 6.5
     * ##### Permissions
     * None.
     */
    get: operations["GetPing"];
  };
  "/system/notices/{teamId}": {
    /**
     * Get notices for logged in user in specified team 
     * @description Will return appropriate product notices for current user in the team specified by teamId parameter.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetNotices"];
  };
  "/system/notices/view": {
    /**
     * Update notices as 'viewed' 
     * @description Will mark the specified notices as 'viewed' by the logged in user.
     * __Minimum server version__: 5.26
     * ##### Permissions
     * Must be logged in.
     */
    put: operations["MarkNoticesViewed"];
  };
  "/database/recycle": {
    /**
     * Recycle database connections 
     * @description Recycle database connections by closing and reconnecting all connections to master and read replica databases.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["DatabaseRecycle"];
  };
  "/email/test": {
    /**
     * Send a test email 
     * @description Send a test email to make sure you have your email settings configured correctly. Optionally provide a configuration in the request body to test. If no valid configuration is present in the request body the current server configuration will be tested.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["TestEmail"];
  };
  "/site_url/test": {
    /**
     * Checks the validity of a Site URL 
     * @description Sends a Ping request to the mattermost server using the specified Site URL.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.16
     */
    post: operations["TestSiteURL"];
  };
  "/file/s3_test": {
    /**
     * Test AWS S3 connection 
     * @description Send a test to validate if can connect to AWS S3. Optionally provide a configuration in the request body to test. If no valid configuration is present in the request body the current server configuration will be tested.
     * ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 4.8
     */
    post: operations["TestS3Connection"];
  };
  "/config": {
    /**
     * Get configuration 
     * @description Retrieve the current server configuration
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetConfig"];
    /**
     * Update configuration 
     * @description Submit a new configuration for the server to use. As of server version 4.8, the `PluginSettings.EnableUploads` setting cannot be modified by this endpoint.
     * Note that the parameters that aren't set in the configuration that you provide will be reset to default values. Therefore, if you want to change a configuration parameter and leave the other ones unchanged, you need to get the existing configuration first, change the field that you want, then put that new configuration.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    put: operations["UpdateConfig"];
  };
  "/config/reload": {
    /**
     * Reload configuration 
     * @description Reload the configuration file to pick up on any changes made to it.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["ReloadConfig"];
  };
  "/config/client": {
    /**
     * Get client configuration 
     * @description Get a subset of the server configuration needed by the client.
     * ##### Permissions
     * No permission required.
     */
    get: operations["GetClientConfig"];
  };
  "/config/environment": {
    /**
     * Get configuration made through environment variables 
     * @description Retrieve a json object mirroring the server configuration where fields are set to true
     * if the corresponding config setting is set through an environment variable. Settings
     * that haven't been set through environment variables will be missing from the object.
     * 
     * __Minimum server version__: 4.10
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetEnvironmentConfig"];
  };
  "/config/patch": {
    /**
     * Patch configuration 
     * @description Submit configuration to patch. As of server version 4.8, the `PluginSettings.EnableUploads` setting cannot be modified by this endpoint.
     * ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 5.20
     * ##### Note
     * The Plugins are stored as a map, and since a map may recursively go  down to any depth, individual fields of a map are not changed.  Consider using the `update config` (PUT api/v4/config) endpoint to update a plugins configurations.
     */
    put: operations["PatchConfig"];
  };
  "/license": {
    /**
     * Upload license file 
     * @description Upload a license to enable enterprise features.
     * 
     * __Minimum server version__: 4.0
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["UploadLicenseFile"];
    /**
     * Remove license file 
     * @description Remove the license file from the server. This will disable all enterprise features.
     * 
     * __Minimum server version__: 4.0
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    delete: operations["RemoveLicenseFile"];
  };
  "/license/client": {
    /**
     * Get client license 
     * @description Get a subset of the server license needed by the client.
     * ##### Permissions
     * No permission required but having the `manage_system` permission returns more information.
     */
    get: operations["GetClientLicense"];
  };
  "/license/renewal": {
    /**
     * Request the license renewal link 
     * @description Request the renewal link that would be used to start the license renewal process
     * __Minimum server version__: 5.32
     * ##### Permissions
     * Must have `sysconsole_write_about` permission.
     */
    get: operations["RequestLicenseRenewalLink"];
  };
  "/trial-license": {
    /**
     * Request and install a trial license for your server 
     * @description Request and install a trial license for your server
     * __Minimum server version__: 5.25
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["RequestTrialLicense"];
  };
  "/trial-license/prev": {
    /**
     * Get last trial license used 
     * @description Get the last trial license used on the sevrer
     * __Minimum server version__: 5.36
     * ##### Permissions
     * Must have `manage_systems` permissions.
     */
    get: operations["GetPrevTrialLicense"];
  };
  "/audits": {
    /**
     * Get audits 
     * @description Get a page of audits for all users on the system, selected with `page` and `per_page` query parameters.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetAudits"];
  };
  "/caches/invalidate": {
    /**
     * Invalidate all the caches 
     * @description Purge all the in-memory caches for the Mattermost server. This can have a temporary negative effect on performance while the caches are re-populated.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["InvalidateCaches"];
  };
  "/logs": {
    /**
     * Get logs 
     * @description Get a page of server logs, selected with `page` and `logs_per_page` query parameters.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetLogs"];
    /**
     * Add log message 
     * @description Add log messages to the server logs.
     * ##### Permissions
     * Users with `manage_system` permission can log ERROR or DEBUG messages.
     * Logged in users can log ERROR or DEBUG messages when `ServiceSettings.EnableDeveloper` is `true` or just DEBUG messages when `false`.
     * Non-logged in users can log ERROR or DEBUG messages when `ServiceSettings.EnableDeveloper` is `true` and cannot log when `false`.
     */
    post: operations["PostLog"];
  };
  "/analytics/old": {
    /**
     * Get analytics 
     * @description Get some analytics data about the system. This endpoint uses the old format, the `/analytics` route is reserved for the new format when it gets implemented.
     * 
     * The returned JSON changes based on the `name` query parameter but is always key/value pairs.
     * 
     * __Minimum server version__: 4.0
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetAnalyticsOld"];
  };
  "/server_busy": {
    /**
     * Get server busy expiry time. 
     * @description Gets the timestamp corresponding to when the server busy flag will be automatically cleared.
     * 
     * __Minimum server version__: 5.20
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetServerBusyExpires"];
    /**
     * Set the server busy (high load) flag 
     * @description Marks the server as currently having high load which disables non-critical services such as search, statuses and typing notifications.
     * 
     * __Minimum server version__: 5.20
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["SetServerBusy"];
    /**
     * Clears the server busy (high load) flag 
     * @description Marks the server as not having high load which re-enables non-critical services such as search, statuses and typing notifications.
     * 
     * __Minimum server version__: 5.20
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    delete: operations["ClearServerBusy"];
  };
  "/notifications/ack": {
    /**
     * Acknowledge receiving of a notification 
     * @description __Minimum server version__: 3.10
     * ##### Permissions
     * Must be logged in.
     */
    post: operations["AcknowledgeNotification"];
  };
  "/redirect_location": {
    /**
     * Get redirect location 
     * @description __Minimum server version__: 3.10
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetRedirectLocation"];
  };
  "/image": {
    /**
     * Get an image by url 
     * @description Fetches an image via Mattermost image proxy.
     * __Minimum server version__: 3.10
     * ##### Permissions
     * Must be logged in.
     */
    get: operations["GetImageByUrl"];
  };
  "/upgrade_to_enterprise": {
    /**
     * Executes an inplace upgrade from Team Edition to Enterprise Edition 
     * @description It downloads the Mattermost Enterprise Edition of your current version and replace your current version with it. After the upgrade you need to restart the Mattermost server.
     * __Minimum server version__: 5.27
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["UpgradeToEnterprise"];
  };
  "/upgrade_to_enterprise/status": {
    /**
     * Get the current status for the inplace upgrade from Team Edition to Enterprise Edition 
     * @description It returns the percentage of completion of the current upgrade or the error if there is any.
     * __Minimum server version__: 5.27
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["UpgradeToEnterpriseStatus"];
  };
  "/restart": {
    /**
     * Restart the system after an upgrade from Team Edition to Enterprise Edition 
     * @description It restarts the current running mattermost instance to execute the new Enterprise binary.
     * __Minimum server version__: 5.27
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["RestartServer"];
  };
  "/warn_metrics/status": {
    /**
     * Get the warn metrics status (enabled or disabled) 
     * @description Get the status of a set of metrics (enabled or disabled) from the Systems table.
     * 
     * The returned JSON contains the metrics that we need to warn the admin on with regard
     * to their status (we return the ones whose status is "true", which means that they are
     * in a "warnable" state - e.g. a threshold has been crossed or some other condition has
     * been fulfilled).
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission.
     */
    get: operations["GetWarnMetricsStatus"];
  };
  "/warn_metrics/ack/{warn_metric_id}": {
    /**
     * Acknowledge a warning of a metric status 
     * @description Acknowledge a warning for the warn_metric_id metric crossing a threshold (or some
     * similar condition being fulfilled) - attempts to send an ack email to
     * acknowledge@mattermost.com and sets the "ack" status for all the warn metrics in the system.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission.
     */
    post: operations["SendWarnMetricAck"];
  };
  "/warn_metrics/trial-license-ack/{warn_metric_id}": {
    /**
     * Request trial license and acknowledge a warning of a metric status 
     * @description Request a trial license and acknowledge a warning for the warn_metric_id metric crossing a threshold (or some
     * similar condition being fulfilled) - sets the "ack" status for all the warn metrics in the system.
     * 
     * __Minimum server version__: 5.28
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission.
     */
    post: operations["SendTrialLicenseWarnMetricAck"];
  };
  "/integrity": {
    /**
     * Perform a database integrity check 
     * @description Performs a database integrity check.
     * 
     * 
     * __Note__: This check may temporarily harm system performance.
     * 
     * 
     * __Minimum server version__: 5.28.0
     * 
     * 
     * __Local mode only__: This endpoint is only available through [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
     */
    post: operations["CheckIntegrity"];
  };
  "/system/support_packet": {
    /**
     * Download a zip file which contains helpful and useful information for troubleshooting your mattermost instance. 
     * @description Download a zip file which contains helpful and useful information for troubleshooting your mattermost instance.
     * __Minimum server version: 5.32__
     * ##### Permissions
     * Must have any of the system console read permissions.
     * ##### License
     * Requires either a E10 or E20 license.
     */
    get: operations["GenerateSupportPacket"];
  };
  "/emoji": {
    /**
     * Get a list of custom emoji 
     * @description Get a page of metadata for custom emoji on the system. Since server version 4.7, sort using the `sort` query parameter.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetEmojiList"];
    /**
     * Create a custom emoji 
     * @description Create a custom emoji for the team.
     * ##### Permissions
     * Must be authenticated.
     */
    post: operations["CreateEmoji"];
  };
  "/emoji/{emoji_id}": {
    /**
     * Get a custom emoji 
     * @description Get some metadata for a custom emoji.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetEmoji"];
    /**
     * Delete a custom emoji 
     * @description Delete a custom emoji.
     * ##### Permissions
     * Must have the `manage_team` or `manage_system` permissions or be the user who created the emoji.
     */
    delete: operations["DeleteEmoji"];
  };
  "/emoji/name/{emoji_name}": {
    /**
     * Get a custom emoji by name 
     * @description Get some metadata for a custom emoji using its name.
     * ##### Permissions
     * Must be authenticated.
     * 
     * __Minimum server version__: 4.7
     */
    get: operations["GetEmojiByName"];
  };
  "/emoji/{emoji_id}/image": {
    /**
     * Get custom emoji image 
     * @description Get the image for a custom emoji.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetEmojiImage"];
  };
  "/emoji/search": {
    /**
     * Search custom emoji 
     * @description Search for custom emoji by name based on search criteria provided in the request body. A maximum of 200 results are returned.
     * ##### Permissions
     * Must be authenticated.
     * 
     * __Minimum server version__: 4.7
     */
    post: operations["SearchEmoji"];
  };
  "/emoji/autocomplete": {
    /**
     * Autocomplete custom emoji 
     * @description Get a list of custom emoji with names starting with or matching the provided name. Returns a maximum of 100 results.
     * ##### Permissions
     * Must be authenticated.
     * 
     * __Minimum server version__: 4.7
     */
    get: operations["AutocompleteEmoji"];
  };
  "/hooks/incoming": {
    /**
     * List incoming webhooks 
     * @description Get a page of a list of incoming webhooks. Optionally filter for a specific team using query parameters.
     * ##### Permissions
     * `manage_webhooks` for the system or `manage_webhooks` for the specific team.
     */
    get: operations["GetIncomingWebhooks"];
    /**
     * Create an incoming webhook 
     * @description Create an incoming webhook for a channel.
     * ##### Permissions
     * `manage_webhooks` for the team the webhook is in.
     * 
     * `manage_others_incoming_webhooks` for the team the webhook is in if the user is different than the requester.
     */
    post: operations["CreateIncomingWebhook"];
  };
  "/hooks/incoming/{hook_id}": {
    /**
     * Get an incoming webhook 
     * @description Get an incoming webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    get: operations["GetIncomingWebhook"];
    /**
     * Update an incoming webhook 
     * @description Update an incoming webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    put: operations["UpdateIncomingWebhook"];
    /**
     * Delete an incoming webhook 
     * @description Delete an incoming webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    delete: operations["DeleteIncomingWebhook"];
  };
  "/hooks/outgoing": {
    /**
     * List outgoing webhooks 
     * @description Get a page of a list of outgoing webhooks. Optionally filter for a specific team or channel using query parameters.
     * ##### Permissions
     * `manage_webhooks` for the system or `manage_webhooks` for the specific team/channel.
     */
    get: operations["GetOutgoingWebhooks"];
    /**
     * Create an outgoing webhook 
     * @description Create an outgoing webhook for a team.
     * ##### Permissions
     * `manage_webhooks` for the team the webhook is in.
     * 
     * `manage_others_outgoing_webhooks` for the team the webhook is in if the user is different than the requester.
     */
    post: operations["CreateOutgoingWebhook"];
  };
  "/hooks/outgoing/{hook_id}": {
    /**
     * Get an outgoing webhook 
     * @description Get an outgoing webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    get: operations["GetOutgoingWebhook"];
    /**
     * Update an outgoing webhook 
     * @description Update an outgoing webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    put: operations["UpdateOutgoingWebhook"];
    /**
     * Delete an outgoing webhook 
     * @description Delete an outgoing webhook given the hook id.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    delete: operations["DeleteOutgoingWebhook"];
  };
  "/hooks/outgoing/{hook_id}/regen_token": {
    /**
     * Regenerate the token for the outgoing webhook. 
     * @description Regenerate the token for the outgoing webhook.
     * ##### Permissions
     * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
     */
    post: operations["RegenOutgoingHookToken"];
  };
  "/saml/metadata": {
    /**
     * Get metadata 
     * @description Get SAML metadata from the server. SAML must be configured properly.
     * ##### Permissions
     * No permission required.
     */
    get: operations["GetSamlMetadata"];
  };
  "/saml/metadatafromidp": {
    /**
     * Get metadata from Identity Provider 
     * @description Get SAML metadata from the Identity Provider. SAML must be configured properly.
     * ##### Permissions
     * No permission required.
     */
    post: operations["GetSamlMetadataFromIdp"];
  };
  "/saml/certificate/idp": {
    /**
     * Upload IDP certificate 
     * @description Upload the IDP certificate to be used with your SAML configuration. The server will pick a hard-coded filename for the IdpCertificateFile setting in your `config.json`.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    post: operations["UploadSamlIdpCertificate"];
    /**
     * Remove IDP certificate 
     * @description Delete the current IDP certificate being used with your SAML configuration. This will also disable SAML on your system as this certificate is required for SAML.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    delete: operations["DeleteSamlIdpCertificate"];
  };
  "/saml/certificate/public": {
    /**
     * Upload public certificate 
     * @description Upload the public certificate to be used for encryption with your SAML configuration. The server will pick a hard-coded filename for the PublicCertificateFile setting in your `config.json`.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    post: operations["UploadSamlPublicCertificate"];
    /**
     * Remove public certificate 
     * @description Delete the current public certificate being used with your SAML configuration. This will also disable encryption for SAML on your system as this certificate is required for that.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    delete: operations["DeleteSamlPublicCertificate"];
  };
  "/saml/certificate/private": {
    /**
     * Upload private key 
     * @description Upload the private key to be used for encryption with your SAML configuration. The server will pick a hard-coded filename for the PrivateKeyFile setting in your `config.json`.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    post: operations["UploadSamlPrivateCertificate"];
    /**
     * Remove private key 
     * @description Delete the current private key being used with your SAML configuration. This will also disable encryption for SAML on your system as this key is required for that.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    delete: operations["DeleteSamlPrivateCertificate"];
  };
  "/saml/certificate/status": {
    /**
     * Get certificate status 
     * @description Get the status of the uploaded certificates and keys in use by your SAML configuration.
     * ##### Permissions
     * Must have `sysconsole_write_authentication` permission.
     */
    get: operations["GetSamlCertificateStatus"];
  };
  "/saml/reset_auth_data": {
    /**
     * Reset AuthData to Email 
     * @description Reset the AuthData field of SAML users to their email. This is meant to be used when the "id" attribute is set to an empty value ("") from a previously non-empty value.
     * __Minimum server version__: 5.35
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["ResetSamlAuthDataToEmail"];
  };
  "/compliance/reports": {
    /**
     * Get reports 
     * @description Get a list of compliance reports previously created by page, selected with `page` and `per_page` query parameters.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetComplianceReports"];
    /**
     * Create report 
     * @description Create and save a compliance report.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["CreateComplianceReport"];
  };
  "/compliance/reports/{report_id}": {
    /**
     * Get a report 
     * @description Get a compliance reports previously created.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetComplianceReport"];
  };
  "/compliance/reports/{report_id}/download": {
    /**
     * Download a report 
     * @description Download the full contents of a report as a file.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["DownloadComplianceReport"];
  };
  "/ldap/sync": {
    /**
     * Sync with LDAP 
     * @description Synchronize any user attribute changes in the configured AD/LDAP server with Mattermost.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["SyncLdap"];
  };
  "/ldap/test": {
    /**
     * Test LDAP configuration 
     * @description Test the current AD/LDAP configuration to see if the AD/LDAP server can be contacted successfully.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["TestLdap"];
  };
  "/ldap/groups": {
    /**
     * Returns a list of LDAP groups 
     * @description ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 5.11
     */
    get: operations["GetLdapGroups"];
  };
  "/ldap/groups/{remote_id}/link": {
    /**
     * Link a LDAP group 
     * @description ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 5.11
     */
    post: operations["LinkLdapGroup"];
    /**
     * Delete a link for LDAP group 
     * @description ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 5.11
     */
    delete: operations["UnlinkLdapGroup"];
  };
  "/ldap/migrateid": {
    /**
     * Migrate Id LDAP 
     * @description Migrate LDAP IdAttribute to new value.
     * ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version__: 5.26
     */
    post: operations["MigrateIdLdap"];
  };
  "/ldap/certificate/public": {
    /**
     * Upload public certificate 
     * @description Upload the public certificate to be used for TLS verification. The server will pick a hard-coded filename for the PublicCertificateFile setting in your `config.json`.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["UploadLdapPublicCertificate"];
    /**
     * Remove public certificate 
     * @description Delete the current public certificate being used for TLS verification.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    delete: operations["DeleteLdapPublicCertificate"];
  };
  "/ldap/certificate/private": {
    /**
     * Upload private key 
     * @description Upload the private key to be used for TLS verification. The server will pick a hard-coded filename for the PrivateKeyFile setting in your `config.json`.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["UploadLdapPrivateCertificate"];
    /**
     * Remove private key 
     * @description Delete the current private key being used with your TLS verification.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    delete: operations["DeleteLdapPrivateCertificate"];
  };
  "/groups": {
    /**
     * Get groups 
     * @description Retrieve a list of all groups not associated to a particular channel or team.
     * 
     * `not_associated_to_team` **OR** `not_associated_to_channel` is required.
     * 
     * If you use `not_associated_to_team`, you must be a team admin for that particular team (permission to manage that team).
     * 
     * If you use `not_associated_to_channel`, you must be a channel admin for that particular channel (permission to manage that channel).
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroups"];
    /**
     * Create a custom group 
     * @description Create a `custom` type group.
     * 
     * #### Permission
     * Must have `create_custom_group` permission.
     * 
     * __Minimum server version__: 6.3
     */
    post: operations["CreateGroup"];
  };
  "/groups/{group_id}": {
    /**
     * Get a group 
     * @description Get group from the provided group id string
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroup"];
    /**
     * Deletes a custom group 
     * @description Soft deletes a custom group.
     * 
     * ##### Permissions
     * Must have `custom_group_delete` permission for the given group.
     * 
     * __Minimum server version__: 6.3
     */
    delete: operations["DeleteGroup"];
  };
  "/groups/{group_id}/patch": {
    /**
     * Patch a group 
     * @description Partially update a group by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    put: operations["PatchGroup"];
  };
  "/groups/{group_id}/teams/{team_id}/link": {
    /**
     * Link a team to a group 
     * @description Link a team to a group
     * ##### Permissions
     * Must have `manage_team` permission.
     * 
     * __Minimum server version__: 5.11
     */
    post: operations["LinkGroupSyncableForTeam"];
    /**
     * Delete a link from a team to a group 
     * @description Delete a link from a team to a group
     * ##### Permissions
     * Must have `manage_team` permission.
     * 
     * __Minimum server version__: 5.11
     */
    delete: operations["UnlinkGroupSyncableForTeam"];
  };
  "/groups/{group_id}/channels/{channel_id}/link": {
    /**
     * Link a channel to a group 
     * @description Link a channel to a group
     * ##### Permissions
     * If the channel is private, you must have `manage_private_channel_members` permission.
     * Otherwise, you must have the `manage_public_channel_members` permission.
     * 
     * __Minimum server version__: 5.11
     */
    post: operations["LinkGroupSyncableForChannel"];
    /**
     * Delete a link from a channel to a group 
     * @description Delete a link from a channel to a group
     * ##### Permissions
     * If the channel is private, you must have `manage_private_channel_members` permission.
     * Otherwise, you must have the `manage_public_channel_members` permission.
     * 
     * __Minimum server version__: 5.11
     */
    delete: operations["UnlinkGroupSyncableForChannel"];
  };
  "/groups/{group_id}/teams/{team_id}": {
    /**
     * Get GroupSyncable from Team ID 
     * @description Get the GroupSyncable object with group_id and team_id from params
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupSyncableForTeamId"];
  };
  "/groups/{group_id}/channels/{channel_id}": {
    /**
     * Get GroupSyncable from channel ID 
     * @description Get the GroupSyncable object with group_id and channel_id from params
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupSyncableForChannelId"];
  };
  "/groups/{group_id}/teams": {
    /**
     * Get group teams 
     * @description Retrieve the list of teams associated to the group
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupSyncablesTeams"];
  };
  "/groups/{group_id}/channels": {
    /**
     * Get group channels 
     * @description Retrieve the list of channels associated to the group
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupSyncablesChannels"];
  };
  "/groups/{group_id}/teams/{team_id}/patch": {
    /**
     * Patch a GroupSyncable associated to Team 
     * @description Partially update a GroupSyncable by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    put: operations["PatchGroupSyncableForTeam"];
  };
  "/groups/{group_id}/channels/{channel_id}/patch": {
    /**
     * Patch a GroupSyncable associated to Channel 
     * @description Partially update a GroupSyncable by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    put: operations["PatchGroupSyncableForChannel"];
  };
  "/groups/{group_id}/members": {
    /**
     * Get group users 
     * @description Retrieve the list of users associated with a given group.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupUsers"];
    /**
     * Adds members to a custom group 
     * @description Adds members to a custom group.
     * 
     * ##### Permissions
     * Must have `custom_group_manage_members` permission for the given group.
     * 
     * __Minimum server version__: 6.3
     */
    post: operations["AddGroupMembers"];
    /**
     * Removes members from a custom group 
     * @description Soft deletes a custom group members.
     * 
     * ##### Permissions
     * Must have `custom_group_manage_members` permission for the given group.
     * 
     * __Minimum server version__: 6.3
     */
    delete: operations["DeleteGroupMembers"];
  };
  "/groups/{group_id}/stats": {
    /**
     * Get group stats 
     * @description Retrieve the stats of a given group.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.26
     */
    get: operations["GetGroupStats"];
  };
  "/channels/{channel_id}/groups": {
    /**
     * Get channel groups 
     * @description Retrieve the list of groups associated with a given channel.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupsByChannel"];
  };
  "/teams/{team_id}/groups": {
    /**
     * Get team groups 
     * @description Retrieve the list of groups associated with a given team.
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupsByTeam"];
  };
  "/teams/{team_id}/groups_by_channels": {
    /**
     * Get team groups by channels 
     * @description Retrieve the set of groups associated with the channels in the given team grouped by channel.
     * 
     * ##### Permissions
     * Must have `manage_system` permission or can access only for current user
     * 
     * __Minimum server version__: 5.11
     */
    get: operations["GetGroupsAssociatedToChannelsByTeam"];
  };
  "/users/{user_id}/groups": {
    /**
     * Get groups for a userId 
     * @description Retrieve the list of groups associated to the user
     * 
     * __Minimum server version__: 5.24
     */
    get: operations["GetGroupsByUserId"];
  };
  "/cluster/status": {
    /**
     * Get cluster status 
     * @description Get a set of information for each node in the cluster, useful for checking the status and health of each node.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    get: operations["GetClusterStatus"];
  };
  "/brand/image": {
    /**
     * Get brand image 
     * @description Get the previously uploaded brand image. Returns 404 if no brand image has been uploaded.
     * ##### Permissions
     * No permission required.
     */
    get: operations["GetBrandImage"];
    /**
     * Upload brand image 
     * @description Uploads a brand image.
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["UploadBrandImage"];
    /**
     * Delete current brand image 
     * @description Deletes the previously uploaded brand image. Returns 404 if no brand image has been uploaded.
     * ##### Permissions
     * Must have `manage_system` permission.
     * __Minimum server version: 5.6__
     */
    delete: operations["DeleteBrandImage"];
  };
  "/commands": {
    /**
     * List commands for a team 
     * @description List commands for a team.
     * ##### Permissions
     * `manage_slash_commands` if need list custom commands.
     */
    get: operations["ListCommands"];
    /**
     * Create a command 
     * @description Create a command for a team.
     * ##### Permissions
     * `manage_slash_commands` for the team the command is in.
     */
    post: operations["CreateCommand"];
  };
  "/teams/{team_id}/commands/autocomplete": {
    /**
     * List autocomplete commands 
     * @description List autocomplete commands in the team.
     * ##### Permissions
     * `view_team` for the team.
     */
    get: operations["ListAutocompleteCommands"];
  };
  "/teams/{team_id}/commands/autocomplete_suggestions": {
    /**
     * List commands' autocomplete data 
     * @description List commands' autocomplete data for the team.
     * ##### Permissions
     * `view_team` for the team.
     * __Minimum server version__: 5.24
     */
    get: operations["ListCommandAutocompleteSuggestions"];
  };
  "/commands/{command_id}": {
    /**
     * Get a command 
     * @description Get a command definition based on command id string.
     * ##### Permissions
     * Must have `manage_slash_commands` permission for the team the command is in.
     * 
     * __Minimum server version__: 5.22
     */
    get: operations["GetCommandById"];
    /**
     * Update a command 
     * @description Update a single command based on command id string and Command struct.
     * ##### Permissions
     * Must have `manage_slash_commands` permission for the team the command is in.
     */
    put: operations["UpdateCommand"];
    /**
     * Delete a command 
     * @description Delete a command based on command id string.
     * ##### Permissions
     * Must have `manage_slash_commands` permission for the team the command is in.
     */
    delete: operations["DeleteCommand"];
  };
  "/commands/{command_id}/move": {
    /**
     * Move a command 
     * @description Move a command to a different team based on command id string.
     * ##### Permissions
     * Must have `manage_slash_commands` permission for the team the command is currently in and the destination team.
     * 
     * __Minimum server version__: 5.22
     */
    put: operations["MoveCommand"];
  };
  "/commands/{command_id}/regen_token": {
    /**
     * Generate a new token 
     * @description Generate a new token for the command based on command id string.
     * ##### Permissions
     * Must have `manage_slash_commands` permission for the team the command is in.
     */
    put: operations["RegenCommandToken"];
  };
  "/commands/execute": {
    /**
     * Execute a command 
     * @description Execute a command on a team.
     * ##### Permissions
     * Must have `use_slash_commands` permission for the team the command is in.
     */
    post: operations["ExecuteCommand"];
  };
  "/oauth/apps": {
    /**
     * Get OAuth apps 
     * @description Get a page of OAuth 2.0 client applications registered with Mattermost.
     * ##### Permissions
     * With `manage_oauth` permission, the apps registered by the logged in user are returned. With `manage_system_wide_oauth` permission, all apps regardless of creator are returned.
     */
    get: operations["GetOAuthApps"];
    /**
     * Register OAuth app 
     * @description Register an OAuth 2.0 client application with Mattermost as the service provider.
     * ##### Permissions
     * Must have `manage_oauth` permission.
     */
    post: operations["CreateOAuthApp"];
  };
  "/oauth/apps/{app_id}": {
    /**
     * Get an OAuth app 
     * @description Get an OAuth 2.0 client application registered with Mattermost.
     * ##### Permissions
     * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
     */
    get: operations["GetOAuthApp"];
    /**
     * Update an OAuth app 
     * @description Update an OAuth 2.0 client application based on OAuth struct.
     * ##### Permissions
     * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
     */
    put: operations["UpdateOAuthApp"];
    /**
     * Delete an OAuth app 
     * @description Delete and unregister an OAuth 2.0 client application 
     * ##### Permissions
     * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
     */
    delete: operations["DeleteOAuthApp"];
  };
  "/oauth/apps/{app_id}/regen_secret": {
    /**
     * Regenerate OAuth app secret 
     * @description Regenerate the client secret for an OAuth 2.0 client application registered with Mattermost.
     * ##### Permissions
     * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
     */
    post: operations["RegenerateOAuthAppSecret"];
  };
  "/oauth/apps/{app_id}/info": {
    /**
     * Get info on an OAuth app 
     * @description Get public information about an OAuth 2.0 client application registered with Mattermost. The application's client secret will be blanked out.
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetOAuthAppInfo"];
  };
  "/users/{user_id}/oauth/apps/authorized": {
    /**
     * Get authorized OAuth apps 
     * @description Get a page of OAuth 2.0 client applications authorized to access a user's account.
     * ##### Permissions
     * Must be authenticated as the user or have `edit_other_users` permission.
     */
    get: operations["GetAuthorizedOAuthAppsForUser"];
  };
  "/elasticsearch/test": {
    /**
     * Test Elasticsearch configuration 
     * @description Test the current Elasticsearch configuration to see if the Elasticsearch server can be contacted successfully.
     * Optionally provide a configuration in the request body to test. If no valid configuration is present in the
     * request body the current server configuration will be tested.
     * 
     * __Minimum server version__: 4.1
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["TestElasticsearch"];
  };
  "/elasticsearch/purge_indexes": {
    /**
     * Purge all Elasticsearch indexes 
     * @description Deletes all Elasticsearch indexes and their contents. After calling this endpoint, it is
     * necessary to schedule a new Elasticsearch indexing job to repopulate the indexes.
     * __Minimum server version__: 4.1
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["PurgeElasticsearchIndexes"];
  };
  "/bleve/purge_indexes": {
    /**
     * Purge all Bleve indexes 
     * @description Deletes all Bleve indexes and their contents. After calling this endpoint, it is
     * necessary to schedule a new Bleve indexing job to repopulate the indexes.
     * __Minimum server version__: 5.24
     * ##### Permissions
     * Must have `sysconsole_write_experimental` permission.
     */
    post: operations["PurgeBleveIndexes"];
  };
  "/data_retention/policy": {
    /**
     * Get the global data retention policy 
     * @description Gets the current global data retention policy details from the server,
     * including what data should be purged and the cutoff times for each data
     * type that should be purged.
     * 
     * __Minimum server version__: 4.3
     * 
     * ##### Permissions
     * Requires an active session but no other permissions.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetDataRetentionPolicy"];
  };
  "/data_retention/policies_count": {
    /**
     * Get the number of granular data retention policies 
     * @description Gets the number of granular (i.e. team or channel-specific) data retention
     * policies from the server.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetDataRetentionPoliciesCount"];
  };
  "/data_retention/policies": {
    /**
     * Get the granular data retention policies 
     * @description Gets details about the granular (i.e. team or channel-specific) data retention
     * policies from the server.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetDataRetentionPolicies"];
    /**
     * Create a new granular data retention policy 
     * @description Creates a new granular data retention policy with the specified display
     * name and post duration.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    post: operations["CreateDataRetentionPolicy"];
  };
  "/data_retention/policies/{policy_id}": {
    /**
     * Get a granular data retention policy 
     * @description Gets details about a granular data retention policies by ID.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetDataRetentionPolicyByID"];
    /**
     * Delete a granular data retention policy 
     * @description Deletes a granular data retention policy.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    delete: operations["DeleteDataRetentionPolicy"];
    /**
     * Patch a granular data retention policy 
     * @description Patches (i.e. replaces the fields of) a granular data retention policy.
     * If any fields are omitted, they will not be changed.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    patch: operations["PatchDataRetentionPolicy"];
  };
  "/data_retention/policies/{policy_id}/teams": {
    /**
     * Get the teams for a granular data retention policy 
     * @description Gets the teams to which a granular data retention policy is applied.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetTeamsForRetentionPolicy"];
    /**
     * Add teams to a granular data retention policy 
     * @description Adds teams to a granular data retention policy.
     * 
     *  __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    post: operations["AddTeamsToRetentionPolicy"];
    /**
     * Delete teams from a granular data retention policy 
     * @description Delete teams from a granular data retention policy.
     * 
     *  __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    delete: operations["RemoveTeamsFromRetentionPolicy"];
  };
  "/data_retention/policies/{policy_id}/teams/search": {
    /**
     * Search for the teams in a granular data retention policy 
     * @description Searches for the teams to which a granular data retention policy is applied.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    post: operations["SearchTeamsForRetentionPolicy"];
  };
  "/data_retention/policies/{policy_id}/channels": {
    /**
     * Get the channels for a granular data retention policy 
     * @description Gets the channels to which a granular data retention policy is applied.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    get: operations["GetChannelsForRetentionPolicy"];
    /**
     * Add channels to a granular data retention policy 
     * @description Adds channels to a granular data retention policy.
     * 
     *  __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    post: operations["AddChannelsToRetentionPolicy"];
    /**
     * Delete channels from a granular data retention policy 
     * @description Delete channels from a granular data retention policy.
     * 
     *  __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_write_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    delete: operations["RemoveChannelsFromRetentionPolicy"];
  };
  "/data_retention/policies/{policy_id}/channels/search": {
    /**
     * Search for the channels in a granular data retention policy 
     * @description Searches for the channels to which a granular data retention policy is applied.
     * 
     * __Minimum server version__: 5.35
     * 
     * ##### Permissions
     * Must have the `sysconsole_read_compliance_data_retention` permission.
     * 
     * ##### License
     * Requires an E20 license.
     */
    post: operations["SearchChannelsForRetentionPolicy"];
  };
  "/plugins": {
    /**
     * Get plugins 
     * @description Get a list of inactive and a list of active plugin manifests. Plugins must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.4
     */
    get: operations["GetPlugins"];
    /**
     * Upload plugin 
     * @description Upload a plugin that is contained within a compressed .tar.gz file. Plugins and plugin uploads must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.4
     */
    post: operations["UploadPlugin"];
  };
  "/plugins/install_from_url": {
    /**
     * Install plugin from url 
     * @description Supply a URL to a plugin compressed in a .tar.gz file. Plugins must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.14
     */
    post: operations["InstallPluginFromUrl"];
  };
  "/plugins/{plugin_id}": {
    /**
     * Remove plugin 
     * @description Remove the plugin with the provided ID from the server. All plugin files are deleted. Plugins must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.4
     */
    delete: operations["RemovePlugin"];
  };
  "/plugins/{plugin_id}/enable": {
    /**
     * Enable plugin 
     * @description Enable a previously uploaded plugin. Plugins must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.4
     */
    post: operations["EnablePlugin"];
  };
  "/plugins/{plugin_id}/disable": {
    /**
     * Disable plugin 
     * @description Disable a previously enabled plugin. Plugins must be enabled in the server's config settings.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 4.4
     */
    post: operations["DisablePlugin"];
  };
  "/plugins/webapp": {
    /**
     * Get webapp plugins 
     * @description Get a list of web app plugins installed and activated on the server.
     * 
     * ##### Permissions
     * No permissions required.
     * 
     * __Minimum server version__: 4.4
     */
    get: operations["GetWebappPlugins"];
  };
  "/plugins/statuses": {
    /**
     * Get plugins status 
     * @description Returns the status for plugins installed anywhere in the cluster
     * 
     * ##### Permissions
     * No permissions required.
     * 
     * __Minimum server version__: 4.4
     */
    get: operations["GetPluginStatuses"];
  };
  "/plugins/marketplace": {
    /**
     * Gets all the marketplace plugins 
     * @description Gets all plugins from the marketplace server, merging data from locally installed plugins as well as prepackaged plugins shipped with the server.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.16
     */
    get: operations["GetMarketplacePlugins"];
    /**
     * Installs a marketplace plugin 
     * @description Installs a plugin listed in the marketplace server.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.16
     */
    post: operations["InstallMarketplacePlugin"];
  };
  "/plugins/marketplace/first_admin_visit": {
    /**
     * Get if the Plugin Marketplace has been visited by at least an admin. 
     * @description Retrieves the status that specifies that at least one System Admin has visited the in-product Plugin Marketplace.
     * __Minimum server version: 5.33__
     * ##### Permissions
     * Must have `manage_system` permissions.
     */
    get: operations["GetMarketplaceVisitedByAdmin"];
    /**
     * Stores that the Plugin Marketplace has been visited by at least an admin. 
     * @description Stores the system-level status that specifies that at least an admin has visited the in-product Plugin Marketplace.
     * __Minimum server version: 5.33__
     * ##### Permissions
     * Must have `manage_system` permissions.
     */
    post: operations["UpdateMarketplaceVisitedByAdmin"];
  };
  "/roles": {
    /**
     * Get a list of all the roles 
     * @description ##### Permissions
     * 
     * `manage_system` permission is required.
     * 
     * __Minimum server version__: 5.33
     */
    get: operations["GetAllRoles"];
  };
  "/roles/{role_id}": {
    /**
     * Get a role 
     * @description Get a role from the provided role id.
     * 
     * ##### Permissions
     * Requires an active session but no other permissions.
     * 
     * __Minimum server version__: 4.9
     */
    get: operations["GetRole"];
  };
  "/roles/name/{role_name}": {
    /**
     * Get a role 
     * @description Get a role from the provided role name.
     * 
     * ##### Permissions
     * Requires an active session but no other permissions.
     * 
     * __Minimum server version__: 4.9
     */
    get: operations["GetRoleByName"];
  };
  "/roles/{role_id}/patch": {
    /**
     * Patch a role 
     * @description Partially update a role by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * 
     * ##### Permissions
     * `manage_system` permission is required.
     * 
     * __Minimum server version__: 4.9
     */
    put: operations["PatchRole"];
  };
  "/roles/names": {
    /**
     * Get a list of roles by name 
     * @description Get a list of roles from their names.
     * 
     * ##### Permissions
     * Requires an active session but no other permissions.
     * 
     * __Minimum server version__: 4.9
     */
    post: operations["GetRolesByNames"];
  };
  "/schemes": {
    /**
     * Get the schemes. 
     * @description Get a page of schemes. Use the query parameters to modify the behaviour of this endpoint.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.0
     */
    get: operations["GetSchemes"];
    /**
     * Create a scheme 
     * @description Create a new scheme.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.0
     */
    post: operations["CreateScheme"];
  };
  "/schemes/{scheme_id}": {
    /**
     * Get a scheme 
     * @description Get a scheme from the provided scheme id.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.0
     */
    get: operations["GetScheme"];
    /**
     * Delete a scheme 
     * @description Soft deletes a scheme, by marking the scheme as deleted in the database.
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     * 
     * __Minimum server version__: 5.0
     */
    delete: operations["DeleteScheme"];
  };
  "/schemes/{scheme_id}/patch": {
    /**
     * Patch a scheme 
     * @description Partially update a scheme by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * 
     * ##### Permissions
     * `manage_system` permission is required.
     * 
     * __Minimum server version__: 5.0
     */
    put: operations["PatchScheme"];
  };
  "/schemes/{scheme_id}/teams": {
    /**
     * Get a page of teams which use this scheme. 
     * @description Get a page of teams which use this scheme. The provided Scheme ID should be for a Team-scoped Scheme.
     * Use the query parameters to modify the behaviour of this endpoint.
     * 
     * ##### Permissions
     * `manage_system` permission is required.
     * 
     * __Minimum server version__: 5.0
     */
    get: operations["GetTeamsForScheme"];
  };
  "/schemes/{scheme_id}/channels": {
    /**
     * Get a page of channels which use this scheme. 
     * @description Get a page of channels which use this scheme. The provided Scheme ID should be for a Channel-scoped Scheme.
     * Use the query parameters to modify the behaviour of this endpoint.
     * 
     * ##### Permissions
     * `manage_system` permission is required.
     * 
     * __Minimum server version__: 5.0
     */
    get: operations["GetChannelsForScheme"];
  };
  "/terms_of_service": {
    /**
     * Get latest terms of service 
     * @description Get latest terms of service from the server
     * 
     * __Minimum server version__: 5.4
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetTermsOfService"];
    /**
     * Creates a new terms of service 
     * @description Creates new terms of service
     * 
     * __Minimum server version__: 5.4
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["CreateTermsOfService"];
  };
  "/sharedchannels/{team_id}": {
    /**
     * Get all shared channels for team. 
     * @description Get all shared channels for a team.
     * 
     * __Minimum server version__: 5.50
     * 
     * ##### Permissions
     * Must be authenticated.
     */
    get: operations["GetAllSharedChannels"];
  };
  "/sharedchannels/remote_info/{remote_id}": {
    /**
     * Get remote cluster info by ID for user. 
     * @description Get remote cluster info based on remoteId.
     * 
     * __Minimum server version__: 5.50
     * 
     * ##### Permissions
     * Must be authenticated and user must belong to at least one channel shared with the remote cluster.
     */
    get: operations["GetRemoteClusterInfo"];
  };
  "/opengraph": {
    /**
     * Get open graph metadata for url 
     * @description Get Open Graph Metadata for a specif URL. Use the Open Graph protocol to get some generic metadata about a URL. Used for creating link previews.
     * 
     * __Minimum server version__: 3.10
     * 
     * ##### Permissions
     * No permission required but must be logged in.
     */
    post: operations["OpenGraph"];
  };
  "/reactions": {
    /**
     * Create a reaction 
     * @description Create a reaction.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in.
     */
    post: operations["SaveReaction"];
  };
  "/posts/{post_id}/reactions": {
    /**
     * Get a list of reactions to a post 
     * @description Get a list of reactions made by all users to a given post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in.
     */
    get: operations["GetReactions"];
  };
  "/users/{user_id}/posts/{post_id}/reactions/{emoji_name}": {
    /**
     * Remove a reaction from a post 
     * @description Deletes a reaction made by a user from the given post.
     * ##### Permissions
     * Must be user or have `manage_system` permission.
     */
    delete: operations["DeleteReaction"];
  };
  "/posts/ids/reactions": {
    /**
     * Bulk get the reaction for posts 
     * @description Get a list of reactions made by all users to a given post.
     * ##### Permissions
     * Must have `read_channel` permission for the channel the post is in.
     * 
     * __Minimum server version__: 5.8
     */
    post: operations["GetBulkReactions"];
  };
  "/actions/dialogs/open": {
    /**
     * Open a dialog 
     * @description Open an interactive dialog using a trigger ID provided by a slash command, or some other action payload. See https://docs.mattermost.com/developer/interactive-dialogs.html for more information on interactive dialogs.
     * __Minimum server version: 5.6__
     */
    post: operations["OpenInteractiveDialog"];
  };
  "/actions/dialogs/submit": {
    /**
     * Submit a dialog 
     * @description Endpoint used by the Mattermost clients to submit a dialog. See https://docs.mattermost.com/developer/interactive-dialogs.html for more information on interactive dialogs.
     * __Minimum server version: 5.6__
     */
    post: operations["SubmitInteractiveDialog"];
  };
  "/bots": {
    /**
     * Get bots 
     * @description Get a page of a list of bots.
     * ##### Permissions
     * Must have `read_bots` permission for bots you are managing, and `read_others_bots` permission for bots others are managing.
     * __Minimum server version__: 5.10
     */
    get: operations["GetBots"];
    /**
     * Create a bot 
     * @description Create a new bot account on the system. Username is required.
     * ##### Permissions
     * Must have `create_bot` permission.
     * __Minimum server version__: 5.10
     */
    post: operations["CreateBot"];
  };
  "/bots/{bot_user_id}": {
    /**
     * Get a bot 
     * @description Get a bot specified by its bot id.
     * ##### Permissions
     * Must have `read_bots` permission for bots you are managing, and `read_others_bots` permission for bots others are managing.
     * __Minimum server version__: 5.10
     */
    get: operations["GetBot"];
    /**
     * Patch a bot 
     * @description Partially update a bot by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
     * ##### Permissions
     * Must have `manage_bots` permission. 
     * __Minimum server version__: 5.10
     */
    put: operations["PatchBot"];
  };
  "/bots/{bot_user_id}/disable": {
    /**
     * Disable a bot 
     * @description Disable a bot.
     * ##### Permissions
     * Must have `manage_bots` permission. 
     * __Minimum server version__: 5.10
     */
    post: operations["DisableBot"];
  };
  "/bots/{bot_user_id}/enable": {
    /**
     * Enable a bot 
     * @description Enable a bot.
     * ##### Permissions
     * Must have `manage_bots` permission. 
     * __Minimum server version__: 5.10
     */
    post: operations["EnableBot"];
  };
  "/bots/{bot_user_id}/assign/{user_id}": {
    /**
     * Assign a bot to a user 
     * @description Assign a bot to a specified user.
     * ##### Permissions
     * Must have `manage_bots` permission. 
     * __Minimum server version__: 5.10
     */
    post: operations["AssignBot"];
  };
  "/bots/{bot_user_id}/icon": {
    /**
     * Get bot's LHS icon 
     * @description Get a bot's LHS icon image based on bot_user_id string parameter.
     * ##### Permissions
     * Must be logged in.
     * __Minimum server version__: 5.14
     */
    get: operations["GetBotIconImage"];
    /**
     * Set bot's LHS icon image 
     * @description Set a bot's LHS icon image based on bot_user_id string parameter. Icon image must be SVG format, all other formats are rejected.
     * ##### Permissions
     * Must have `manage_bots` permission.
     * __Minimum server version__: 5.14
     */
    post: operations["SetBotIconImage"];
    /**
     * Delete bot's LHS icon image 
     * @description Delete bot's LHS icon image based on bot_user_id string parameter.
     * ##### Permissions
     * Must have `manage_bots` permission.
     * __Minimum server version__: 5.14
     */
    delete: operations["DeleteBotIconImage"];
  };
  "/bots/{bot_user_id}/convert_to_user": {
    /**
     * Convert a bot into a user 
     * @description Convert a bot into a user.
     * 
     * __Minimum server version__: 5.26
     * 
     * ##### Permissions
     * Must have `manage_system` permission.
     */
    post: operations["ConvertBotToUser"];
  };
  "/cloud/limits": {
    /**
     * Get cloud workspace limits 
     * @description Retrieve any cloud workspace limits applicable to this instance.
     * ##### Permissions
     * Must be authenticated and be licensed for Cloud.
     * __Minimum server version__: 7.0 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetCloudLimits"];
  };
  "/cloud/products": {
    /**
     * Get cloud products 
     * @description Retrieve a list of all products that are offered for Mattermost Cloud.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetCloudProducts"];
  };
  "/cloud/payment": {
    /**
     * Create a customer setup payment intent 
     * @description Creates a customer setup payment intent for the given Mattermost cloud installation.
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permission and be licensed for Cloud.
     * 
     * __Minimum server version__: 5.28
     * __Note:__: This is intended for internal use and is subject to change.
     */
    post: operations["CreateCustomerPayment"];
  };
  "/cloud/payment/confirm": {
    /**
     * Completes the payment setup intent 
     * @description Confirms the payment setup intent initiated when posting to `/cloud/payment`.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
     */
    post: operations["ConfirmCustomerPayment"];
  };
  "/cloud/customer": {
    /**
     * Get cloud customer 
     * @description Retrieves the customer information for the Mattermost Cloud customer bound to this installation.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetCloudCustomer"];
    /**
     * Update cloud customer 
     * @description Updates the customer information for the Mattermost Cloud customer bound to this installation.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.29 __Note:__ This is intended for internal use and is subject to change.
     */
    put: operations["UpdateCloudCustomer"];
  };
  "/cloud/customer/address": {
    /**
     * Update cloud customer address 
     * @description Updates the company address for the Mattermost Cloud customer bound to this installation.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.29 __Note:__ This is intended for internal use and is subject to change.
     */
    put: operations["UpdateCloudCustomerAddress"];
  };
  "/cloud/subscription": {
    /**
     * Get cloud subscription 
     * @description Retrieves the subscription information for the Mattermost Cloud customer bound to this installation.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetSubscription"];
  };
  "/cloud/subscription/invoices": {
    /**
     * Get cloud subscription invoices 
     * @description Retrieves the invoices for the subscription bound to this installation.
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetInvoicesForSubscription"];
  };
  "/cloud/subscription/invoices/{invoice_id}/pdf": {
    /**
     * Get cloud invoice PDF 
     * @description Retrieves the PDF for the invoice passed as parameter
     * ##### Permissions
     * Must have `manage_system` permission and be licensed for Cloud.
     * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
     */
    get: operations["GetInvoiceForSubscriptionAsPdf"];
  };
  "/cloud/webhook": {
    /**
     * POST endpoint for CWS Webhooks 
     * @description An endpoint for processing webhooks from the Customer Portal
     * ##### Permissions
     * This endpoint should only be accessed by CWS, in a Mattermost Cloud instance
     * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
     */
    post: operations["PostEndpointForCwsWebhooks"];
  };
  "/usage/posts": {
    /**
     * Get current usage of posts 
     * @description Retrieve rounded off total no. of posts for this instance. Example: returns 4000 instead of 4321
     * ##### Permissions
     * Must be authenticated.
     * __Minimum server version__: 7.0
     */
    get: operations["GetPostsUsage"];
  };
  "/usage/storage": {
    /**
     * Get the total file storage usage for the instance in bytes. 
     * @description Get the total file storage usage for the instance in bytes rounded down to the most significant digit. Example: returns 4000 instead of 4321
     * ##### Permissions
     * Must be authenticated.
     * __Minimum server version__: 7.1
     */
    get: operations["GetStorageUsage"];
  };
  "/permissions/ancillary": {
    /**
     * Return all system console subsection ancillary permissions 
     * @description Returns all the ancillary permissions for the corresponding system console subsection permissions appended to the requested permission subsections.
     * 
     * __Minimum server version__: 5.35
     */
    get: operations["GetAncillaryPermissions"];
  };
  "/imports": {
    /**
     * List import files 
     * @description Lists all available import files.
     * 
     * __Minimum server version__: 5.31
     * ##### Permissions
     * Must have `manage_system` permissions.
     */
    get: operations["ListImports"];
  };
  "/exports": {
    /**
     * List export files 
     * @description Lists all available export files.
     * __Minimum server version__: 5.33
     * ##### Permissions
     * Must have `manage_system` permissions.
     */
    get: operations["ListExports"];
  };
  "/exports/{export_name}": {
    /**
     * Download an export file 
     * @description Downloads an export file.
     * 
     * 
     * __Minimum server version__: 5.33
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permissions.
     */
    get: operations["DownloadExport"];
    /**
     * Delete an export file 
     * @description Deletes an export file.
     * 
     * 
     * __Minimum server version__: 5.33
     * 
     * ##### Permissions
     * 
     * Must have `manage_system` permissions.
     */
    delete: operations["DeleteExport"];
  };
  "/runs": {
    /**
     * List all playbook runs 
     * @description Retrieve a paged list of playbook runs, filtered by team, status, owner, name and/or members, and sorted by ID, name, status, creation date, end date, team or owner ID.
     */
    get: operations["listPlaybookRuns"];
    /**
     * Create a new playbook run 
     * @description Create a new playbook run in a team, using a playbook as template, with a specific name and a specific owner.
     */
    post: operations["createPlaybookRunFromPost"];
  };
  "/runs/dialog": {
    /**
     * Create a new playbook run from dialog 
     * @description This is an internal endpoint to create a playbook run from the submission of an interactive dialog, filled by a user in the webapp. See [Interactive Dialogs](https://docs.mattermost.com/developer/interactive-dialogs.html) for more information.
     */
    post: operations["createPlaybookRunFromDialog"];
  };
  "/runs/owners": {
    /**
     * Get all owners 
     * @description Get the owners of all playbook runs, filtered by team.
     */
    get: operations["getOwners"];
  };
  "/runs/channels": {
    /**
     * Get playbook run channels 
     * @description Get all channels associated with a playbook run, filtered by team, status, owner, name and/or members, and sorted by ID, name, status, creation date, end date, team, or owner ID.
     */
    get: operations["getChannels"];
  };
  "/runs/checklist-autocomplete": {
    /**
     * Get autocomplete data for /playbook check 
     * @description This is an internal endpoint used by the autocomplete system to retrieve the data needed to show the list of items that the user can check.
     */
    get: operations["getChecklistAutocomplete"];
  };
  "/runs/channel/{channel_id}": {
    /** Find playbook run by channel ID */
    get: operations["getPlaybookRunByChannelId"];
  };
  "/runs/{id}": {
    /** Get a playbook run */
    get: operations["getPlaybookRun"];
    /** Update a playbook run */
    patch: operations["updatePlaybookRun"];
  };
  "/runs/{id}/metadata": {
    /** Get playbook run metadata */
    get: operations["getPlaybookRunMetadata"];
  };
  "/runs/{id}/end": {
    /** End a playbook run */
    put: operations["endPlaybookRun"];
    /**
     * End a playbook run from dialog 
     * @description This is an internal endpoint to end a playbook run via a confirmation dialog, submitted by a user in the webapp.
     */
    post: operations["endPlaybookRunDialog"];
  };
  "/runs/{id}/restart": {
    /** Restart a playbook run */
    put: operations["restartPlaybookRun"];
  };
  "/runs/{id}/status": {
    /** Update a playbook run's status */
    post: operations["status"];
  };
  "/runs/{id}/finish": {
    /** Finish a playbook */
    put: operations["finish"];
  };
  "/runs/{id}/owner": {
    /** Update playbook run owner */
    post: operations["changeOwner"];
  };
  "/runs/{id}/next-stage-dialog": {
    /**
     * Go to next stage from dialog 
     * @description This is an internal endpoint to go to the next stage via a confirmation dialog, submitted by a user in the webapp.
     */
    post: operations["nextStageDialog"];
  };
  "/runs/{id}/checklists/{checklist}/add": {
    /**
     * Add an item to a playbook run's checklist 
     * @description The most common pattern to add a new item is to only send its title as the request payload. By default, it is an open item, with no assignee and no slash command.
     */
    put: operations["addChecklistItem"];
  };
  "/runs/{id}/checklists/{checklist}/reorder": {
    /** Reorder an item in a playbook run's checklist */
    put: operations["reoderChecklistItem"];
  };
  "/runs/{id}/checklists/{checklist}/item/{item}": {
    /**
     * Update an item of a playbook run's checklist 
     * @description Update the title and the slash command of an item in one of the playbook run's checklists.
     */
    put: operations["itemRename"];
    /** Delete an item of a playbook run's checklist */
    delete: operations["itemDelete"];
  };
  "/runs/{id}/checklists/{checklist}/item/{item}/state": {
    /** Update the state of an item */
    put: operations["itemSetState"];
  };
  "/runs/{id}/checklists/{checklist}/item/{item}/assignee": {
    /** Update the assignee of an item */
    put: operations["itemSetAssignee"];
  };
  "/runs/{id}/checklists/{checklist}/item/{item}/run": {
    /** Run an item's slash command */
    put: operations["itemRun"];
  };
  "/runs/{id}/timeline/{event-id}/": {
    /** Remove a timeline event from the playbook run */
    delete: operations["removeTimelineEvent"];
  };
  "/playbooks": {
    /**
     * List all playbooks 
     * @description Retrieve a paged list of playbooks, filtered by team, and sorted by title, number of stages or number of steps.
     */
    get: operations["getPlaybooks"];
    /** Create a playbook */
    post: operations["createPlaybook"];
  };
  "/playbooks/{id}": {
    /** Get a playbook */
    get: operations["getPlaybook"];
    /** Update a playbook */
    put: operations["updatePlaybook"];
    /** Delete a playbook */
    delete: operations["deletePlaybook"];
  };
  "/playbooks/{id}/autofollows": {
    /** Get the list of followers' user IDs of a playbook */
    get: operations["getAutoFollows"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    User: {
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a user was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a user was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a user was deleted
       */
      delete_at?: number;
      username?: string;
      first_name?: string;
      last_name?: string;
      nickname?: string;
      email?: string;
      email_verified?: boolean;
      auth_service?: string;
      roles?: string;
      locale?: string;
      notify_props?: components["schemas"]["UserNotifyProps"];
      props?: Record<string, never>;
      last_password_update?: number;
      last_picture_update?: number;
      failed_attempts?: number;
      mfa_active?: boolean;
      timezone?: components["schemas"]["Timezone"];
      /** @description ID of accepted terms of service, if any. This field is not present if empty. */
      terms_of_service_id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds the user accepted the terms of service
       */
      terms_of_service_create_at?: number;
    };
    UsersStats: {
      total_users_count?: number;
    };
    KnownUsers: (unknown)[];
    Team: {
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a team was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a team was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a team was deleted
       */
      delete_at?: number;
      display_name?: string;
      name?: string;
      description?: string;
      email?: string;
      type?: string;
      allowed_domains?: string;
      invite_id?: string;
      allow_open_invite?: boolean;
      /** @description The data retention policy to which this team has been assigned. If no such policy exists, or the caller does not have the `sysconsole_read_compliance_data_retention` permission, this field will be null. */
      policy_id?: string;
    };
    TeamStats: {
      team_id?: string;
      total_member_count?: number;
      active_member_count?: number;
    };
    TeamExists: {
      exists?: boolean;
    };
    Channel: {
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a channel was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a channel was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a channel was deleted
       */
      delete_at?: number;
      team_id?: string;
      type?: string;
      display_name?: string;
      name?: string;
      header?: string;
      purpose?: string;
      /** @description The time in milliseconds of the last post of a channel */
      last_post_at?: number;
      total_msg_count?: number;
      /**
       * Format: int64 
       * @description Deprecated in Mattermost 5.0 release
       */
      extra_update_at?: number;
      creator_id?: string;
    };
    ChannelStats: {
      channel_id?: string;
      member_count?: number;
    };
    ChannelMember: {
      channel_id?: string;
      user_id?: string;
      roles?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds the channel was last viewed by the user
       */
      last_viewed_at?: number;
      msg_count?: number;
      mention_count?: number;
      notify_props?: components["schemas"]["ChannelNotifyProps"];
      /**
       * Format: int64 
       * @description The time in milliseconds the channel member was last updated
       */
      last_update_at?: number;
    };
    ChannelMemberWithTeamData: components["schemas"]["ChannelMember"] & {
      /** @description The display name of the team to which this channel belongs. */
      team_display_name?: string;
      /** @description The name of the team to which this channel belongs. */
      team_name?: string;
      /** @description The time at which the team to which this channel belongs was last updated. */
      team_update_at?: number;
    };
    ChannelData: {
      channel?: components["schemas"]["Channel"];
      member?: components["schemas"]["ChannelMember"];
    };
    ChannelWithTeamData: components["schemas"]["Channel"] & {
      /** @description The display name of the team to which this channel belongs. */
      team_display_name?: string;
      /** @description The name of the team to which this channel belongs. */
      team_name?: string;
      /** @description The time at which the team to which this channel belongs was last updated. */
      team_update_at?: number;
      /** @description The data retention policy to which this team has been assigned. If no such policy exists, or the caller does not have the `sysconsole_read_compliance_data_retention` permission, this field will be null. */
      policy_id?: string;
    };
    ChannelListWithTeamData: (components["schemas"]["ChannelWithTeamData"])[];
    Post: {
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a post was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a post was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a post was deleted
       */
      delete_at?: number;
      /** Format: int64 */
      edit_at?: number;
      user_id?: string;
      channel_id?: string;
      root_id?: string;
      original_id?: string;
      message?: string;
      type?: string;
      props?: Record<string, never>;
      hashtag?: string;
      file_ids?: (string)[];
      pending_post_id?: string;
      metadata?: components["schemas"]["PostMetadata"];
    };
    FileInfoList: {
      /**
       * @example [
       *   "file_info_id1",
       *   "file_info_id2"
       * ]
       */
      order?: (string)[];
      file_infos?: {
        [key: string]: components["schemas"]["FileInfo"] | undefined;
      };
      /** @description The ID of next file info. Not omitted when empty or not relevant. */
      next_file_id?: string;
      /** @description The ID of previous file info. Not omitted when empty or not relevant. */
      prev_file_id?: string;
    };
    PostList: {
      /**
       * @example [
       *   "post_id1",
       *   "post_id12"
       * ]
       */
      order?: (string)[];
      posts?: {
        [key: string]: components["schemas"]["Post"] | undefined;
      };
      /** @description The ID of next post. Not omitted when empty or not relevant. */
      next_post_id?: string;
      /** @description The ID of previous post. Not omitted when empty or not relevant. */
      prev_post_id?: string;
      /** @description Whether there are more items after this page. */
      has_next?: boolean;
    };
    PostListWithSearchMatches: {
      /**
       * @example [
       *   "post_id1",
       *   "post_id12"
       * ]
       */
      order?: (string)[];
      posts?: {
        [key: string]: components["schemas"]["Post"] | undefined;
      };
      /**
       * @description A mapping of post IDs to a list of matched terms within the post. This field will only be populated on servers running version 5.1 or greater with Elasticsearch enabled. 
       * @example {
       *   "post_id1": [
       *     "search match 1",
       *     "search match 2"
       *   ]
       * }
       */
      matches?: {
        [key: string]: (string)[] | undefined;
      };
    };
    /** @description Additional information used to display a post. */
    PostMetadata: {
      /** @description Information about content embedded in the post including OpenGraph previews, image link previews, and message attachments. This field will be null if the post does not contain embedded content. */
      embeds?: ({
          /**
           * @description The type of content that is embedded in this point. 
           * @enum {string}
           */
          type?: "image" | "message_attachment" | "opengraph" | "link";
          /** @description The URL of the embedded content, if one exists. */
          url?: string;
          /**
           * @description Any additional information about the embedded content. Only used at this time to store OpenGraph metadata.
           * This field will be null for non-OpenGraph embeds.
           */
          data?: Record<string, never>;
        })[];
      /** @description The custom emojis that appear in this point or have been used in reactions to this post. This field will be null if the post does not contain custom emojis. */
      emojis?: (components["schemas"]["Emoji"])[];
      /** @description The FileInfo objects for any files attached to the post. This field will be null if the post does not have any file attachments. */
      files?: (components["schemas"]["FileInfo"])[];
      /** @description An object mapping the URL of an external image to an object containing the dimensions of that image. This field will be null if the post or its embedded content does not reference any external images. */
      images?: Record<string, never>;
      /** @description Any reactions made to this point. This field will be null if no reactions have been made to this post. */
      reactions?: (components["schemas"]["Reaction"])[];
    };
    /** @description A mapping of teamIds to teams. */
    TeamMap: {
      team_id?: components["schemas"]["Team"];
    };
    TeamMember: {
      /** @description The ID of the team this member belongs to. */
      team_id?: string;
      /** @description The ID of the user this member relates to. */
      user_id?: string;
      /** @description The complete list of roles assigned to this team member, as a space-separated list of role names, including any roles granted implicitly through permissions schemes. */
      roles?: string;
      /** @description The time in milliseconds that this team member was deleted. */
      delete_at?: number;
      /** @description Whether this team member holds the default user role defined by the team's permissions scheme. */
      scheme_user?: boolean;
      /** @description Whether this team member holds the default admin role defined by the team's permissions scheme. */
      scheme_admin?: boolean;
      /** @description The list of roles explicitly assigned to this team member, as a space separated list of role names. This list does *not* include any roles granted implicitly through permissions schemes. */
      explicit_roles?: string;
    };
    TeamUnread: {
      team_id?: string;
      msg_count?: number;
      mention_count?: number;
    };
    ChannelUnread: {
      team_id?: string;
      channel_id?: string;
      msg_count?: number;
      mention_count?: number;
    };
    ChannelUnreadAt: {
      /** @description The ID of the team the channel belongs to. */
      team_id?: string;
      /** @description The ID of the channel the user has access to.. */
      channel_id?: string;
      /** @description No. of messages the user has already read. */
      msg_count?: number;
      /** @description No. of mentions the user has within the unread posts of the channel. */
      mention_count?: number;
      /** @description time in milliseconds when the user last viewed the channel. */
      last_viewed_at?: number;
    };
    Session: {
      /**
       * Format: int64 
       * @description The time in milliseconds a session was created
       */
      create_at?: number;
      device_id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a session will expire
       */
      expires_at?: number;
      id?: string;
      is_oauth?: boolean;
      /**
       * Format: int64 
       * @description The time in milliseconds of the last activity of a session
       */
      last_activity_at?: number;
      props?: Record<string, never>;
      roles?: string;
      team_members?: (components["schemas"]["TeamMember"])[];
      token?: string;
      user_id?: string;
    };
    FileInfo: {
      /** @description The unique identifier for this file */
      id?: string;
      /** @description The ID of the user that uploaded this file */
      user_id?: string;
      /** @description If this file is attached to a post, the ID of that post */
      post_id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a file was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a file was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a file was deleted
       */
      delete_at?: number;
      /** @description The name of the file */
      name?: string;
      /** @description The extension at the end of the file name */
      extension?: string;
      /** @description The size of the file in bytes */
      size?: number;
      /** @description The MIME type of the file */
      mime_type?: string;
      /** @description If this file is an image, the width of the file */
      width?: number;
      /** @description If this file is an image, the height of the file */
      height?: number;
      /** @description If this file is an image, whether or not it has a preview-sized version */
      has_preview_image?: boolean;
    };
    Preference: {
      /** @description The ID of the user that owns this preference */
      user_id?: string;
      category?: string;
      name?: string;
      value?: string;
    };
    UserAuthData: {
      /** @description Service-specific authentication data */
      auth_data: string;
      /** @description The authentication service such as "email", "gitlab", or "ldap" */
      auth_service: string;
    };
    UserAutocomplete: {
      /** @description A list of users that are the main result of the query */
      users?: (components["schemas"]["User"])[];
      /** @description A special case list of users returned when autocompleting in a specific channel. Omitted when empty or not relevant */
      out_of_channel?: (components["schemas"]["User"])[];
    };
    UserAutocompleteInTeam: {
      /** @description A list of user objects in the team */
      in_team?: (components["schemas"]["User"])[];
    };
    UserAutocompleteInChannel: {
      /** @description A list of user objects in the channel */
      in_channel?: (components["schemas"]["User"])[];
      /** @description A list of user objects not in the channel */
      out_of_channel?: (components["schemas"]["User"])[];
    };
    IncomingWebhook: {
      /** @description The unique identifier for this incoming webhook */
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a incoming webhook was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a incoming webhook was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a incoming webhook was deleted
       */
      delete_at?: number;
      /** @description The ID of a public channel or private group that receives the webhook payloads */
      channel_id?: string;
      /** @description The description for this incoming webhook */
      description?: string;
      /** @description The display name for this incoming webhook */
      display_name?: string;
    };
    OutgoingWebhook: {
      /** @description The unique identifier for this outgoing webhook */
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a outgoing webhook was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a outgoing webhook was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a outgoing webhook was deleted
       */
      delete_at?: number;
      /** @description The Id of the user who created the webhook */
      creator_id?: string;
      /** @description The ID of the team that the webhook watchs */
      team_id?: string;
      /** @description The ID of a public channel that the webhook watchs */
      channel_id?: string;
      /** @description The description for this outgoing webhook */
      description?: string;
      /** @description The display name for this outgoing webhook */
      display_name?: string;
      /** @description List of words for the webhook to trigger on */
      trigger_words?: (string)[];
      /** @description When to trigger the webhook, `0` when a trigger word is present at all and `1` if the message starts with a trigger word */
      trigger_when?: number;
      /** @description The URLs to POST the payloads to when the webhook is triggered */
      callback_urls?: (string)[];
      /**
       * @description The format to POST the data in, either `application/json` or `application/x-www-form-urlencoded` 
       * @default application/x-www-form-urlencoded
       */
      content_type?: string;
    };
    Reaction: {
      /** @description The ID of the user that made this reaction */
      user_id?: string;
      /** @description The ID of the post to which this reaction was made */
      post_id?: string;
      /** @description The name of the emoji that was used for this reaction */
      emoji_name?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds this reaction was made
       */
      create_at?: number;
    };
    TopReaction: {
      /** @description The name of the emoji used for this reaction. */
      emoji_name?: string;
      /**
       * Format: int64 
       * @description The number of the times this emoji has been used.
       */
      count?: number;
    };
    NewTeamMember: {
      /** @description The user's ID. */
      id?: string;
      username?: string;
      first_name?: string;
      last_name?: string;
      nickname?: string;
      /** @description The user's position field value. */
      position?: string;
      /** @description The creation timestamp of the team member record. */
      create_at?: number;
    };
    TopReactionList: {
      /** @description Indicates if there is another page of reactions that can be fetched. */
      has_next?: boolean;
      /** @description List of reactions. */
      items?: (components["schemas"]["TopReaction"])[];
    };
    NewTeamMembersList: {
      /** @description Indicates if there is another page of new team members that can be fetched. */
      has_next?: boolean;
      /** @description List of new team members. */
      items?: (components["schemas"]["NewTeamMember"])[];
      /** @description The total count of new team members for the given time range. */
      total_count?: number;
    };
    TopChannel: {
      id?: string;
      type?: string;
      display_name?: string;
      name?: string;
      team_id?: string;
      /** @description The number of messages posted in the channel by users over the given time period (not including messages posted by bots). */
      message_count?: string;
    };
    TopChannelList: {
      /** @description Indicates if there is another page of channels that can be fetched. */
      has_next?: boolean;
      /** @description List of channels. */
      items?: (components["schemas"]["TopChannel"])[];
    };
    InsightUserInformation: {
      id?: string;
      first_name?: string;
      last_name?: string;
      nickname?: string;
      username?: string;
      last_picture_update?: string;
      /** Format: int64 */
      create_at?: number;
    };
    TopThread: {
      post?: components["schemas"]["Post"];
      channel_id?: string;
      channel_display_name?: string;
      channel_name?: string;
      Participants?: (string)[];
      /** @description User who created the post */
      user_information?: components["schemas"]["InsightUserInformation"];
    };
    TopThreadList: {
      /** @description Indicates if there is another page of top threads that can be fetched. */
      has_next?: boolean;
      /** @description List of top threads. */
      items?: (components["schemas"]["TopThread"])[];
    };
    TopDMInsightUserInformation: components["schemas"]["InsightUserInformation"] & {
      position?: string;
    };
    TopDM: {
      /** Format: int64 */
      post_count?: number;
      /** Format: int64 */
      outgoing_message_count?: number;
      second_participant?: components["schemas"]["TopDMInsightUserInformation"];
    };
    TopDMList: {
      /** @description Indicates if there is another page of top DMs that can be fetched. */
      has_next?: boolean;
      /** @description List of top DMs. */
      items?: (components["schemas"]["TopDM"])[];
    };
    Emoji: {
      /** @description The ID of the emoji */
      id?: string;
      /** @description The ID of the user that made the emoji */
      creator_id?: string;
      /** @description The name of the emoji */
      name?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds the emoji was made
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds the emoji was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds the emoji was deleted
       */
      delete_at?: number;
    };
    Command: {
      /** @description The ID of the slash command */
      id?: string;
      /** @description The token which is used to verify the source of the payload */
      token?: string;
      /** @description The time in milliseconds the command was created */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds the command was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds the command was deleted, 0 if never deleted
       */
      delete_at?: number;
      /** @description The user id for the commands creator */
      creator_id?: string;
      /** @description The team id for which this command is configured */
      team_id?: string;
      /** @description The string that triggers this command */
      trigger?: string;
      /** @description Is the trigger done with HTTP Get ('G') or HTTP Post ('P') */
      method?: string;
      /** @description What is the username for the response post */
      username?: string;
      /** @description The url to find the icon for this users avatar */
      icon_url?: string;
      /** @description Use auto complete for this command */
      auto_complete?: boolean;
      /** @description The description for this command shown when selecting the command */
      auto_complete_desc?: string;
      /** @description The hint for this command */
      auto_complete_hint?: string;
      /** @description Display name for the command */
      display_name?: string;
      /** @description Description for this command */
      description?: string;
      /** @description The URL that is triggered */
      url?: string;
    };
    AutocompleteSuggestion: {
      /** @description Completed suggestion */
      Complete?: string;
      /** @description Predicted text user might want to input */
      Suggestion?: string;
      /** @description Hint about suggested input */
      Hint?: string;
      /** @description Description of the suggested command */
      Description?: string;
      /** @description Base64 encoded svg image */
      IconData?: string;
    };
    CommandResponse: {
      /** @description The response type either in_channel or ephemeral */
      ResponseType?: string;
      Text?: string;
      Username?: string;
      IconURL?: string;
      GotoLocation?: string;
      Attachments?: (components["schemas"]["SlackAttachment"])[];
    };
    SlackAttachment: {
      Id?: string;
      Fallback?: string;
      Color?: string;
      Pretext?: string;
      AuthorName?: string;
      AuthorLink?: string;
      AuthorIcon?: string;
      Title?: string;
      TitleLink?: string;
      Text?: string;
      Fields?: (components["schemas"]["SlackAttachmentField"])[];
      ImageURL?: string;
      ThumbURL?: string;
      Footer?: string;
      FooterIcon?: string;
      /** @description The timestamp of the slack attachment, either type of string or integer */
      Timestamp?: string;
    };
    SlackAttachmentField: {
      Title?: string;
      /** @description The value of the attachment, set as string but capable with golang interface */
      Value?: string;
      Short?: boolean;
    };
    StatusOK: {
      /** @description Will contain "ok" if the request was successful and there was nothing else to return */
      status?: string;
    };
    /** @description OpenGraph metadata of a webpage */
    OpenGraph: {
      type?: string;
      url?: string;
      title?: string;
      description?: string;
      determiner?: string;
      site_name?: string;
      locale?: string;
      locales_alternate?: (string)[];
      images?: ({
          url?: string;
          secure_url?: string;
          type?: string;
          width?: number;
          height?: number;
        })[];
      videos?: ({
          url?: string;
          secure_url?: string;
          type?: string;
          width?: number;
          height?: number;
        })[];
      audios?: ({
          url?: string;
          secure_url?: string;
          type?: string;
        })[];
      /** @description Article object used in OpenGraph metadata of a webpage, if type is article */
      article?: {
        published_time?: string;
        modified_time?: string;
        expiration_time?: string;
        section?: string;
        tags?: (string)[];
        authors?: ({
            first_name?: string;
            last_name?: string;
            username?: string;
            gender?: string;
          })[];
      };
      /** @description Book object used in OpenGraph metadata of a webpage, if type is book */
      book?: {
        isbn?: string;
        release_date?: string;
        tags?: (string)[];
        authors?: ({
            first_name?: string;
            last_name?: string;
            username?: string;
            gender?: string;
          })[];
      };
      profile?: {
        first_name?: string;
        last_name?: string;
        username?: string;
        gender?: string;
      };
    };
    Audit: {
      id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a audit was created
       */
      create_at?: number;
      user_id?: string;
      action?: string;
      extra_info?: string;
      ip_address?: string;
      session_id?: string;
    };
    Config: {
      ServiceSettings?: {
        SiteURL?: string;
        ListenAddress?: string;
        ConnectionSecurity?: string;
        TLSCertFile?: string;
        TLSKeyFile?: string;
        UseLetsEncrypt?: boolean;
        LetsEncryptCertificateCacheFile?: string;
        Forward80To443?: boolean;
        ReadTimeout?: number;
        WriteTimeout?: number;
        MaximumLoginAttempts?: number;
        SegmentDeveloperKey?: string;
        GoogleDeveloperKey?: string;
        EnableOAuthServiceProvider?: boolean;
        EnableIncomingWebhooks?: boolean;
        EnableOutgoingWebhooks?: boolean;
        EnableCommands?: boolean;
        EnableOnlyAdminIntegrations?: boolean;
        EnablePostUsernameOverride?: boolean;
        EnablePostIconOverride?: boolean;
        EnableTesting?: boolean;
        EnableDeveloper?: boolean;
        EnableSecurityFixAlert?: boolean;
        EnableInsecureOutgoingConnections?: boolean;
        EnableMultifactorAuthentication?: boolean;
        EnforceMultifactorAuthentication?: boolean;
        AllowCorsFrom?: string;
        SessionLengthWebInDays?: number;
        SessionLengthMobileInDays?: number;
        SessionLengthSSOInDays?: number;
        SessionCacheInMinutes?: number;
        WebsocketSecurePort?: number;
        WebsocketPort?: number;
        WebserverMode?: string;
        EnableCustomEmoji?: boolean;
        RestrictCustomEmojiCreation?: string;
      };
      TeamSettings?: {
        SiteName?: string;
        MaxUsersPerTeam?: number;
        EnableTeamCreation?: boolean;
        EnableUserCreation?: boolean;
        EnableOpenServer?: boolean;
        RestrictCreationToDomains?: string;
        EnableCustomBrand?: boolean;
        CustomBrandText?: string;
        CustomDescriptionText?: string;
        RestrictDirectMessage?: string;
        RestrictTeamInvite?: string;
        RestrictPublicChannelManagement?: string;
        RestrictPrivateChannelManagement?: string;
        RestrictPublicChannelCreation?: string;
        RestrictPrivateChannelCreation?: string;
        RestrictPublicChannelDeletion?: string;
        RestrictPrivateChannelDeletion?: string;
        UserStatusAwayTimeout?: number;
        MaxChannelsPerTeam?: number;
        MaxNotificationsPerChannel?: number;
      };
      SqlSettings?: {
        DriverName?: string;
        DataSource?: string;
        DataSourceReplicas?: (string)[];
        MaxIdleConns?: number;
        MaxOpenConns?: number;
        Trace?: boolean;
        AtRestEncryptKey?: string;
      };
      LogSettings?: {
        EnableConsole?: boolean;
        ConsoleLevel?: string;
        EnableFile?: boolean;
        FileLevel?: string;
        FileLocation?: string;
        EnableWebhookDebugging?: boolean;
        EnableDiagnostics?: boolean;
      };
      PasswordSettings?: {
        MinimumLength?: number;
        Lowercase?: boolean;
        Number?: boolean;
        Uppercase?: boolean;
        Symbol?: boolean;
      };
      FileSettings?: {
        MaxFileSize?: number;
        DriverName?: string;
        Directory?: string;
        EnablePublicLink?: boolean;
        PublicLinkSalt?: string;
        ThumbnailWidth?: number;
        ThumbnailHeight?: number;
        PreviewWidth?: number;
        PreviewHeight?: number;
        ProfileWidth?: number;
        ProfileHeight?: number;
        InitialFont?: string;
        AmazonS3AccessKeyId?: string;
        AmazonS3SecretAccessKey?: string;
        AmazonS3Bucket?: string;
        AmazonS3Region?: string;
        AmazonS3Endpoint?: string;
        AmazonS3SSL?: boolean;
      };
      EmailSettings?: {
        EnableSignUpWithEmail?: boolean;
        EnableSignInWithEmail?: boolean;
        EnableSignInWithUsername?: boolean;
        SendEmailNotifications?: boolean;
        RequireEmailVerification?: boolean;
        FeedbackName?: string;
        FeedbackEmail?: string;
        FeedbackOrganization?: string;
        SMTPUsername?: string;
        SMTPPassword?: string;
        SMTPServer?: string;
        SMTPPort?: string;
        ConnectionSecurity?: string;
        InviteSalt?: string;
        PasswordResetSalt?: string;
        SendPushNotifications?: boolean;
        PushNotificationServer?: string;
        PushNotificationContents?: string;
        EnableEmailBatching?: boolean;
        EmailBatchingBufferSize?: number;
        EmailBatchingInterval?: number;
      };
      RateLimitSettings?: {
        Enable?: boolean;
        PerSec?: number;
        MaxBurst?: number;
        MemoryStoreSize?: number;
        VaryByRemoteAddr?: boolean;
        VaryByHeader?: string;
      };
      PrivacySettings?: {
        ShowEmailAddress?: boolean;
        ShowFullName?: boolean;
      };
      SupportSettings?: {
        TermsOfServiceLink?: string;
        PrivacyPolicyLink?: string;
        AboutLink?: string;
        HelpLink?: string;
        ReportAProblemLink?: string;
        SupportEmail?: string;
      };
      GitLabSettings?: {
        Enable?: boolean;
        Secret?: string;
        Id?: string;
        Scope?: string;
        AuthEndpoint?: string;
        TokenEndpoint?: string;
        UserApiEndpoint?: string;
      };
      GoogleSettings?: {
        Enable?: boolean;
        Secret?: string;
        Id?: string;
        Scope?: string;
        AuthEndpoint?: string;
        TokenEndpoint?: string;
        UserApiEndpoint?: string;
      };
      Office365Settings?: {
        Enable?: boolean;
        Secret?: string;
        Id?: string;
        Scope?: string;
        AuthEndpoint?: string;
        TokenEndpoint?: string;
        UserApiEndpoint?: string;
      };
      LdapSettings?: {
        Enable?: boolean;
        LdapServer?: string;
        LdapPort?: number;
        ConnectionSecurity?: string;
        BaseDN?: string;
        BindUsername?: string;
        BindPassword?: string;
        UserFilter?: string;
        FirstNameAttribute?: string;
        LastNameAttribute?: string;
        EmailAttribute?: string;
        UsernameAttribute?: string;
        NicknameAttribute?: string;
        IdAttribute?: string;
        PositionAttribute?: string;
        SyncIntervalMinutes?: number;
        SkipCertificateVerification?: boolean;
        QueryTimeout?: number;
        MaxPageSize?: number;
        LoginFieldName?: string;
      };
      ComplianceSettings?: {
        Enable?: boolean;
        Directory?: string;
        EnableDaily?: boolean;
      };
      LocalizationSettings?: {
        DefaultServerLocale?: string;
        DefaultClientLocale?: string;
        AvailableLocales?: string;
      };
      SamlSettings?: {
        Enable?: boolean;
        Verify?: boolean;
        Encrypt?: boolean;
        IdpUrl?: string;
        IdpDescriptorUrl?: string;
        AssertionConsumerServiceURL?: string;
        IdpCertificateFile?: string;
        PublicCertificateFile?: string;
        PrivateKeyFile?: string;
        FirstNameAttribute?: string;
        LastNameAttribute?: string;
        EmailAttribute?: string;
        UsernameAttribute?: string;
        NicknameAttribute?: string;
        LocaleAttribute?: string;
        PositionAttribute?: string;
        LoginButtonText?: string;
      };
      NativeAppSettings?: {
        AppDownloadLink?: string;
        AndroidAppDownloadLink?: string;
        IosAppDownloadLink?: string;
      };
      ClusterSettings?: {
        Enable?: boolean;
        InterNodeListenAddress?: string;
        InterNodeUrls?: (string)[];
      };
      MetricsSettings?: {
        Enable?: boolean;
        BlockProfileRate?: number;
        ListenAddress?: string;
      };
      AnalyticsSettings?: {
        MaxUsersForStatistics?: number;
      };
    };
    EnvironmentConfig: {
      ServiceSettings?: {
        SiteURL?: boolean;
        ListenAddress?: boolean;
        ConnectionSecurity?: boolean;
        TLSCertFile?: boolean;
        TLSKeyFile?: boolean;
        UseLetsEncrypt?: boolean;
        LetsEncryptCertificateCacheFile?: boolean;
        Forward80To443?: boolean;
        ReadTimeout?: boolean;
        WriteTimeout?: boolean;
        MaximumLoginAttempts?: boolean;
        SegmentDeveloperKey?: boolean;
        GoogleDeveloperKey?: boolean;
        EnableOAuthServiceProvider?: boolean;
        EnableIncomingWebhooks?: boolean;
        EnableOutgoingWebhooks?: boolean;
        EnableCommands?: boolean;
        EnableOnlyAdminIntegrations?: boolean;
        EnablePostUsernameOverride?: boolean;
        EnablePostIconOverride?: boolean;
        EnableTesting?: boolean;
        EnableDeveloper?: boolean;
        EnableSecurityFixAlert?: boolean;
        EnableInsecureOutgoingConnections?: boolean;
        EnableMultifactorAuthentication?: boolean;
        EnforceMultifactorAuthentication?: boolean;
        AllowCorsFrom?: boolean;
        SessionLengthWebInDays?: boolean;
        SessionLengthMobileInDays?: boolean;
        SessionLengthSSOInDays?: boolean;
        SessionCacheInMinutes?: boolean;
        WebsocketSecurePort?: boolean;
        WebsocketPort?: boolean;
        WebserverMode?: boolean;
        EnableCustomEmoji?: boolean;
        RestrictCustomEmojiCreation?: boolean;
      };
      TeamSettings?: {
        SiteName?: boolean;
        MaxUsersPerTeam?: boolean;
        EnableTeamCreation?: boolean;
        EnableUserCreation?: boolean;
        EnableOpenServer?: boolean;
        RestrictCreationToDomains?: boolean;
        EnableCustomBrand?: boolean;
        CustomBrandText?: boolean;
        CustomDescriptionText?: boolean;
        RestrictDirectMessage?: boolean;
        RestrictTeamInvite?: boolean;
        RestrictPublicChannelManagement?: boolean;
        RestrictPrivateChannelManagement?: boolean;
        RestrictPublicChannelCreation?: boolean;
        RestrictPrivateChannelCreation?: boolean;
        RestrictPublicChannelDeletion?: boolean;
        RestrictPrivateChannelDeletion?: boolean;
        UserStatusAwayTimeout?: boolean;
        MaxChannelsPerTeam?: boolean;
        MaxNotificationsPerChannel?: boolean;
      };
      SqlSettings?: {
        DriverName?: boolean;
        DataSource?: boolean;
        DataSourceReplicas?: boolean;
        MaxIdleConns?: boolean;
        MaxOpenConns?: boolean;
        Trace?: boolean;
        AtRestEncryptKey?: boolean;
      };
      LogSettings?: {
        EnableConsole?: boolean;
        ConsoleLevel?: boolean;
        EnableFile?: boolean;
        FileLevel?: boolean;
        FileLocation?: boolean;
        EnableWebhookDebugging?: boolean;
        EnableDiagnostics?: boolean;
      };
      PasswordSettings?: {
        MinimumLength?: boolean;
        Lowercase?: boolean;
        Number?: boolean;
        Uppercase?: boolean;
        Symbol?: boolean;
      };
      FileSettings?: {
        MaxFileSize?: boolean;
        DriverName?: boolean;
        Directory?: boolean;
        EnablePublicLink?: boolean;
        PublicLinkSalt?: boolean;
        ThumbnailWidth?: boolean;
        ThumbnailHeight?: boolean;
        PreviewWidth?: boolean;
        PreviewHeight?: boolean;
        ProfileWidth?: boolean;
        ProfileHeight?: boolean;
        InitialFont?: boolean;
        AmazonS3AccessKeyId?: boolean;
        AmazonS3SecretAccessKey?: boolean;
        AmazonS3Bucket?: boolean;
        AmazonS3Region?: boolean;
        AmazonS3Endpoint?: boolean;
        AmazonS3SSL?: boolean;
      };
      EmailSettings?: {
        EnableSignUpWithEmail?: boolean;
        EnableSignInWithEmail?: boolean;
        EnableSignInWithUsername?: boolean;
        SendEmailNotifications?: boolean;
        RequireEmailVerification?: boolean;
        FeedbackName?: boolean;
        FeedbackEmail?: boolean;
        FeedbackOrganization?: boolean;
        SMTPUsername?: boolean;
        SMTPPassword?: boolean;
        SMTPServer?: boolean;
        SMTPPort?: boolean;
        ConnectionSecurity?: boolean;
        InviteSalt?: boolean;
        PasswordResetSalt?: boolean;
        SendPushNotifications?: boolean;
        PushNotificationServer?: boolean;
        PushNotificationContents?: boolean;
        EnableEmailBatching?: boolean;
        EmailBatchingBufferSize?: boolean;
        EmailBatchingInterval?: boolean;
      };
      RateLimitSettings?: {
        Enable?: boolean;
        PerSec?: boolean;
        MaxBurst?: boolean;
        MemoryStoreSize?: boolean;
        VaryByRemoteAddr?: boolean;
        VaryByHeader?: boolean;
      };
      PrivacySettings?: {
        ShowEmailAddress?: boolean;
        ShowFullName?: boolean;
      };
      SupportSettings?: {
        TermsOfServiceLink?: boolean;
        PrivacyPolicyLink?: boolean;
        AboutLink?: boolean;
        HelpLink?: boolean;
        ReportAProblemLink?: boolean;
        SupportEmail?: boolean;
      };
      GitLabSettings?: {
        Enable?: boolean;
        Secret?: boolean;
        Id?: boolean;
        Scope?: boolean;
        AuthEndpoint?: boolean;
        TokenEndpoint?: boolean;
        UserApiEndpoint?: boolean;
      };
      GoogleSettings?: {
        Enable?: boolean;
        Secret?: boolean;
        Id?: boolean;
        Scope?: boolean;
        AuthEndpoint?: boolean;
        TokenEndpoint?: boolean;
        UserApiEndpoint?: boolean;
      };
      Office365Settings?: {
        Enable?: boolean;
        Secret?: boolean;
        Id?: boolean;
        Scope?: boolean;
        AuthEndpoint?: boolean;
        TokenEndpoint?: boolean;
        UserApiEndpoint?: boolean;
      };
      LdapSettings?: {
        Enable?: boolean;
        LdapServer?: boolean;
        LdapPort?: boolean;
        ConnectionSecurity?: boolean;
        BaseDN?: boolean;
        BindUsername?: boolean;
        BindPassword?: boolean;
        UserFilter?: boolean;
        FirstNameAttribute?: boolean;
        LastNameAttribute?: boolean;
        EmailAttribute?: boolean;
        UsernameAttribute?: boolean;
        NicknameAttribute?: boolean;
        IdAttribute?: boolean;
        PositionAttribute?: boolean;
        SyncIntervalMinutes?: boolean;
        SkipCertificateVerification?: boolean;
        QueryTimeout?: boolean;
        MaxPageSize?: boolean;
        LoginFieldName?: boolean;
      };
      ComplianceSettings?: {
        Enable?: boolean;
        Directory?: boolean;
        EnableDaily?: boolean;
      };
      LocalizationSettings?: {
        DefaultServerLocale?: boolean;
        DefaultClientLocale?: boolean;
        AvailableLocales?: boolean;
      };
      SamlSettings?: {
        Enable?: boolean;
        Verify?: boolean;
        Encrypt?: boolean;
        IdpUrl?: boolean;
        IdpDescriptorUrl?: boolean;
        AssertionConsumerServiceURL?: boolean;
        IdpCertificateFile?: boolean;
        PublicCertificateFile?: boolean;
        PrivateKeyFile?: boolean;
        FirstNameAttribute?: boolean;
        LastNameAttribute?: boolean;
        EmailAttribute?: boolean;
        UsernameAttribute?: boolean;
        NicknameAttribute?: boolean;
        LocaleAttribute?: boolean;
        PositionAttribute?: boolean;
        LoginButtonText?: boolean;
      };
      NativeAppSettings?: {
        AppDownloadLink?: boolean;
        AndroidAppDownloadLink?: boolean;
        IosAppDownloadLink?: boolean;
      };
      ClusterSettings?: {
        Enable?: boolean;
        InterNodeListenAddress?: boolean;
        InterNodeUrls?: boolean;
      };
      MetricsSettings?: {
        Enable?: boolean;
        BlockProfileRate?: boolean;
        ListenAddress?: boolean;
      };
      AnalyticsSettings?: {
        MaxUsersForStatistics?: boolean;
      };
    };
    SamlCertificateStatus: {
      /** @description Status is good when `true` */
      idp_certificate_file?: boolean;
      /** @description Status is good when `true` */
      public_certificate_file?: boolean;
      /** @description Status is good when `true` */
      private_key_file?: boolean;
    };
    Compliance: {
      id?: string;
      /** Format: int64 */
      create_at?: number;
      user_id?: string;
      status?: string;
      count?: number;
      desc?: string;
      type?: string;
      /** Format: int64 */
      start_at?: number;
      /** Format: int64 */
      end_at?: number;
      keywords?: string;
      emails?: string;
    };
    ClusterInfo: {
      /** @description The unique ID for the node */
      id?: string;
      /** @description The server version the node is on */
      version?: string;
      /** @description The hash of the configuartion file the node is using */
      config_hash?: string;
      /** @description The URL used to communicate with those node from other nodes */
      internode_url?: string;
      /** @description The hostname for this node */
      hostname?: string;
      /** @description The time of the last ping to this node */
      last_ping?: number;
      /** @description Whether or not the node is alive and well */
      is_alive?: boolean;
    };
    AppError: {
      status_code?: number;
      id?: string;
      message?: string;
      request_id?: string;
    };
    Status: {
      user_id?: string;
      status?: string;
      manual?: boolean;
      /** Format: int64 */
      last_activity_at?: number;
    };
    OAuthApp: {
      /** @description The client id of the application */
      id?: string;
      /** @description The client secret of the application */
      client_secret?: string;
      /** @description The name of the client application */
      name?: string;
      /** @description A short description of the application */
      description?: string;
      /** @description A URL to an icon to display with the application */
      icon_url?: string;
      /** @description A list of callback URLs for the appliation */
      callback_urls?: (string)[];
      /** @description A link to the website of the application */
      homepage?: string;
      /** @description Set this to `true` to skip asking users for permission */
      is_trusted?: boolean;
      /**
       * Format: int64 
       * @description The time of registration for the application
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The last time of update for the application
       */
      update_at?: number;
    };
    Job: {
      /** @description The unique id of the job */
      id?: string;
      /** @description The type of job */
      type?: string;
      /**
       * Format: int64 
       * @description The time at which the job was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time at which the job was started
       */
      start_at?: number;
      /**
       * Format: int64 
       * @description The last time at which the job had activity
       */
      last_activity_at?: number;
      /** @description The status of the job */
      status?: string;
      /** @description The progress (as a percentage) of the job */
      progress?: number;
      /** @description A freeform data field containing additional information about the job */
      data?: Record<string, never>;
    };
    UserAccessToken: {
      /** @description Unique identifier for the token */
      id?: string;
      /** @description The token used for authentication */
      token?: string;
      /** @description The user the token authenticates for */
      user_id?: string;
      /** @description A description of the token usage */
      description?: string;
    };
    UserAccessTokenSanitized: {
      /** @description Unique identifier for the token */
      id?: string;
      /** @description The user the token authenticates for */
      user_id?: string;
      /** @description A description of the token usage */
      description?: string;
      /** @description Indicates whether the token is active */
      is_active?: boolean;
    };
    GlobalDataRetentionPolicy: {
      /** @description Indicates whether data retention policy deletion of messages is enabled globally. */
      message_deletion_enabled?: boolean;
      /** @description Indicates whether data retention policy deletion of file attachments is enabled globally. */
      file_deletion_enabled?: boolean;
      /** @description The current server timestamp before which messages should be deleted. */
      message_retention_cutoff?: number;
      /** @description The current server timestamp before which files should be deleted. */
      file_retention_cutoff?: number;
    };
    DataRetentionPolicyWithoutId: {
      /** @description The display name for this retention policy. */
      display_name?: string;
      /** @description The number of days a message will be retained before being deleted by this policy. If this value is less than 0, the policy has infinite retention (i.e. messages are never deleted). */
      post_duration?: number;
    };
    DataRetentionPolicy: components["schemas"]["DataRetentionPolicyWithoutId"] & {
      /** @description The ID of this retention policy. */
      id?: string;
    };
    DataRetentionPolicyWithTeamAndChannelCounts: components["schemas"]["DataRetentionPolicy"] & {
      /** @description The number of teams to which this policy is applied. */
      team_count?: number;
      /** @description The number of channels to which this policy is applied. */
      channel_count?: number;
    };
    DataRetentionPolicyWithTeamAndChannelIds: components["schemas"]["DataRetentionPolicyWithoutId"] & {
      /** @description The IDs of the teams to which this policy should be applied. */
      team_ids?: (string)[];
      /** @description The IDs of the channels to which this policy should be applied. */
      channel_ids?: (string)[];
    };
    DataRetentionPolicyCreate: WithRequired<components["schemas"]["DataRetentionPolicyWithTeamAndChannelIds"], "display_name" | "post_duration">;
    DataRetentionPolicyForTeam: {
      /** @description The team ID. */
      team_id?: string;
      /** @description The number of days a message will be retained before being deleted by this policy. */
      post_duration?: number;
    };
    RetentionPolicyForTeamList: {
      /** @description The list of team policies. */
      policies?: (components["schemas"]["DataRetentionPolicyForTeam"])[];
      /** @description The total number of team policies. */
      total_count?: number;
    };
    DataRetentionPolicyForChannel: {
      /** @description The channel ID. */
      channel_id?: string;
      /** @description The number of days a message will be retained before being deleted by this policy. */
      post_duration?: number;
    };
    RetentionPolicyForChannelList: {
      /** @description The list of channel policies. */
      policies?: (components["schemas"]["DataRetentionPolicyForChannel"])[];
      /** @description The total number of channel policies. */
      total_count?: number;
    };
    UserNotifyProps: {
      /** @description Set to "true" to enable email notifications, "false" to disable. Defaults to "true". */
      email?: string;
      /** @description Set to "all" to receive push notifications for all activity, "mention" for mentions and direct messages only, and "none" to disable. Defaults to "mention". */
      push?: string;
      /** @description Set to "all" to receive desktop notifications for all activity, "mention" for mentions and direct messages only, and "none" to disable. Defaults to "all". */
      desktop?: string;
      /** @description Set to "true" to enable sound on desktop notifications, "false" to disable. Defaults to "true". */
      desktop_sound?: string;
      /** @description A comma-separated list of words to count as mentions. Defaults to username and @username. */
      mention_keys?: string;
      /** @description Set to "true" to enable channel-wide notifications (@channel, @all, etc.), "false" to disable. Defaults to "true". */
      channel?: string;
      /** @description Set to "true" to enable mentions for first name. Defaults to "true" if a first name is set, "false" otherwise. */
      first_name?: string;
    };
    Timezone: {
      /** @description Set to "true" to use the browser/system timezone, "false" to set manually. Defaults to "true". */
      useAutomaticTimezone?: boolean;
      /** @description Value when setting manually the timezone, i.e. "Europe/Berlin". */
      manualTimezone?: string;
      /** @description This value is set automatically when the "useAutomaticTimezone" is set to "true". */
      automaticTimezone?: string;
    };
    ChannelNotifyProps: {
      /** @description Set to "true" to enable email notifications, "false" to disable, or "default" to use the global user notification setting. */
      email?: string;
      /** @description Set to "all" to receive push notifications for all activity, "mention" for mentions and direct messages only, "none" to disable, or "default" to use the global user notification setting. */
      push?: string;
      /** @description Set to "all" to receive desktop notifications for all activity, "mention" for mentions and direct messages only, "none" to disable, or "default" to use the global user notification setting. */
      desktop?: string;
      /** @description Set to "all" to mark the channel unread for any new message, "mention" to mark unread for new mentions only. Defaults to "all". */
      mark_unread?: string;
    };
    PluginManifest: {
      /** @description Globally unique identifier that represents the plugin. */
      id?: string;
      /** @description Name of the plugin. */
      name?: string;
      /** @description Description of what the plugin is and does. */
      description?: string;
      /** @description Version number of the plugin. */
      version?: string;
      /**
       * @description The minimum Mattermost server version required for the plugin.
       * 
       * Available as server version 5.6.
       */
      min_server_version?: string;
      /** @description Deprecated in Mattermost 5.2 release. */
      backend?: {
        /** @description Path to the executable binary. */
        executable?: string;
      };
      server?: {
        /** @description Paths to executable binaries, specifying multiple entry points for different platforms when bundled together in a single plugin. */
        executables?: {
          "linux-amd64"?: string;
          "darwin-amd64"?: string;
          "windows-amd64"?: string;
        };
        /** @description Path to the executable binary. */
        executable?: string;
      };
      webapp?: {
        /** @description Path to the webapp JavaScript bundle. */
        bundle_path?: string;
      };
      /** @description Settings schema used to define the System Console UI for the plugin. */
      settings_schema?: Record<string, never>;
    };
    MarketplacePlugin: {
      /** @description URL that leads to the homepage of the plugin. */
      homepage_url?: string;
      /** @description Base64 encoding of a plugin icon SVG. */
      icon_data?: string;
      /** @description URL to download the plugin. */
      download_url?: string;
      /** @description URL that leads to the release notes of the plugin. */
      release_notes_url?: string;
      /** @description A list of the plugin labels. */
      labels?: (string)[];
      /** @description Base64 encoded signature of the plugin. */
      signature?: string;
      manifest?: components["schemas"]["PluginManifest"];
      /** @description Version number of the already installed plugin, if any. */
      installed_version?: string;
    };
    PushNotification: {
      ack_id?: string;
      platform?: string;
      server_id?: string;
      device_id?: string;
      post_id?: string;
      category?: string;
      sound?: string;
      message?: string;
      badge?: number;
      cont_ava?: number;
      team_id?: string;
      channel_id?: string;
      root_id?: string;
      channel_name?: string;
      type?: string;
      sender_id?: string;
      sender_name?: string;
      override_username?: string;
      override_icon_url?: string;
      from_webhook?: string;
      version?: string;
      is_id_loaded?: boolean;
    };
    PluginStatus: {
      /** @description Globally unique identifier that represents the plugin. */
      plugin_id?: string;
      /** @description Name of the plugin. */
      name?: string;
      /** @description Description of what the plugin is and does. */
      description?: string;
      /** @description Version number of the plugin. */
      version?: string;
      /** @description ID of the cluster in which plugin is running */
      cluster_id?: string;
      /** @description Path to the plugin on the server */
      plugin_path?: string;
      /**
       * @description State of the plugin 
       * @enum {number}
       */
      state?: NotRunning | Starting | Running | FailedToStart | FailedToStayRunning | Stopping;
    };
    PluginManifestWebapp: {
      /** @description Globally unique identifier that represents the plugin. */
      id?: string;
      /** @description Version number of the plugin. */
      version?: string;
      webapp?: {
        /** @description Path to the webapp JavaScript bundle. */
        bundle_path?: string;
      };
    };
    Role: {
      /** @description The unique identifier of the role. */
      id?: string;
      /** @description The unique name of the role, used when assigning roles to users/groups in contexts. */
      name?: string;
      /** @description The human readable name for the role. */
      display_name?: string;
      /** @description A human readable description of the role. */
      description?: string;
      /** @description A list of the unique names of the permissions this role grants. */
      permissions?: (string)[];
      /** @description indicates if this role is managed by a scheme (true), or is a custom stand-alone role (false). */
      scheme_managed?: boolean;
    };
    Scheme: {
      /** @description The unique identifier of the scheme. */
      id?: string;
      /** @description The human readable name for the scheme. */
      name?: string;
      /** @description A human readable description of the scheme. */
      description?: string;
      /**
       * Format: int64 
       * @description The time at which the scheme was created.
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time at which the scheme was last updated.
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time at which the scheme was deleted.
       */
      delete_at?: number;
      /** @description The scope to which this scheme can be applied, either "team" or "channel". */
      scope?: string;
      /** @description The id of the default team admin role for this scheme. */
      default_team_admin_role?: string;
      /** @description The id of the default team user role for this scheme. */
      default_team_user_role?: string;
      /** @description The id of the default channel admin role for this scheme. */
      default_channel_admin_role?: string;
      /** @description The id of the default channel user role for this scheme. */
      default_channel_user_role?: string;
    };
    TermsOfService: {
      /** @description The unique identifier of the terms of service. */
      id?: string;
      /**
       * Format: int64 
       * @description The time at which the terms of service was created.
       */
      create_at?: number;
      /** @description The unique identifier of the user who created these terms of service. */
      user_id?: string;
      /** @description The text of terms of service. Supports Markdown. */
      text?: string;
    };
    UserTermsOfService: {
      /** @description The unique identifier of the user who performed this terms of service action. */
      user_id?: string;
      /** @description The unique identifier of the terms of service the action was performed on. */
      terms_of_service_id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds that this action was performed.
       */
      create_at?: number;
    };
    PostIdToReactionsMap: {
      [key: string]: (components["schemas"]["Reaction"])[] | undefined;
    };
    Product: {
      id?: string;
      name?: string;
      description?: string;
      price_per_seat?: string;
      add_ons?: (components["schemas"]["AddOn"])[];
    };
    AddOn: {
      id?: string;
      name?: string;
      display_name?: string;
      price_per_seat?: string;
    };
    ProductLimits: {
      boards?: components["schemas"]["BoardsLimits"];
      files?: components["schemas"]["FilesLimits"];
      integrations?: components["schemas"]["IntegrationsLimits"];
      messages?: components["schemas"]["MessagesLimits"];
      teams?: components["schemas"]["TeamsLimits"];
    };
    BoardsLimits: {
      cards?: number | null;
      views?: number | null;
    };
    FilesLimits: {
      /** Format: int64 */
      total_storage?: number | null;
    };
    IntegrationsLimits: {
      enabled?: number | null;
    };
    MessagesLimits: {
      history?: number | null;
    };
    TeamsLimits: {
      active?: number | null;
    };
    PaymentSetupIntent: {
      id?: string;
      client_secret?: string;
    };
    PaymentMethod: {
      type?: string;
      last_four?: number;
      exp_month?: number;
      exp_year?: number;
      card_brand?: string;
      name?: string;
    };
    Address: {
      city?: string;
      country?: string;
      line1?: string;
      line2?: string;
      postal_code?: string;
      state?: string;
    };
    CloudCustomer: {
      id?: string;
      creator_id?: string;
      /** Format: int64 */
      create_at?: number;
      email?: string;
      name?: string;
      num_employees?: string;
      contact_first_name?: string;
      contact_last_name?: string;
      billing_address?: components["schemas"]["Address"];
      company_address?: components["schemas"]["Address"];
      payment_method?: components["schemas"]["PaymentMethod"];
    };
    Subscription: {
      id?: string;
      customer_id?: string;
      product_id?: string;
      add_ons?: (string)[];
      /** Format: int64 */
      start_at?: number;
      /** Format: int64 */
      end_at?: number;
      /** Format: int64 */
      create_at?: number;
      seats?: number;
      dns?: string;
    };
    SubscriptionStats: {
      remaining_seats?: number;
      is_paid_tier?: string;
    };
    Invoice: {
      id?: string;
      number?: string;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      total?: number;
      /** Format: int64 */
      tax?: number;
      status?: string;
      /** Format: int64 */
      period_start?: number;
      /** Format: int64 */
      period_end?: number;
      subscription_id?: string;
      item?: (components["schemas"]["InvoiceLineItem"])[];
    };
    InvoiceLineItem: {
      price_id?: string;
      /** Format: int64 */
      total?: number;
      /** Format: int64 */
      quantity?: number;
      /** Format: int64 */
      price_per_unit?: number;
      description?: string;
      metadata?: (string)[];
    };
    Group: {
      id?: string;
      name?: string;
      display_name?: string;
      description?: string;
      source?: string;
      remote_id?: string;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      update_at?: number;
      /** Format: int64 */
      delete_at?: number;
      has_syncables?: boolean;
    };
    GroupSyncableTeam: {
      team_id?: string;
      group_id?: string;
      auto_add?: boolean;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      delete_at?: number;
      /** Format: int64 */
      update_at?: number;
    };
    GroupSyncableChannel: {
      channel_id?: string;
      group_id?: string;
      auto_add?: boolean;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      delete_at?: number;
      /** Format: int64 */
      update_at?: number;
    };
    GroupSyncableTeams: {
      team_id?: string;
      team_display_name?: string;
      team_type?: string;
      group_id?: string;
      auto_add?: boolean;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      delete_at?: number;
      /** Format: int64 */
      update_at?: number;
    };
    GroupSyncableChannels: {
      channel_id?: string;
      channel_display_name?: string;
      channel_type?: string;
      team_id?: string;
      team_display_name?: string;
      team_type?: string;
      group_id?: string;
      auto_add?: boolean;
      /** Format: int64 */
      create_at?: number;
      /** Format: int64 */
      delete_at?: number;
      /** Format: int64 */
      update_at?: number;
    };
    ChannelModeration: {
      name?: string;
      roles?: components["schemas"]["ChannelModeratedRoles"];
    };
    ChannelModeratedRoles: {
      guests?: components["schemas"]["ChannelModeratedRole"];
      members?: components["schemas"]["ChannelModeratedRole"];
    };
    ChannelModeratedRole: {
      value?: boolean;
      enabled?: boolean;
    };
    ChannelModeratedRolesPatch: {
      guests?: boolean;
      members?: boolean;
    };
    ChannelModerationPatch: {
      name?: string;
      roles?: components["schemas"]["ChannelModeratedRolesPatch"];
    };
    /** @description An object describing group member information in a channel */
    ChannelMemberCountByGroup: {
      /** @description ID of the group */
      group_id?: string;
      /** @description Total number of group members in the channel */
      channel_member_count?: number;
      /** @description Total number of unique timezones for the group members in the channel */
      channel_member_timezones_count?: number;
    };
    /** @description A paged list of LDAP groups */
    LDAPGroupsPaged: {
      /** @description Total number of groups */
      count?: number;
      groups?: (components["schemas"]["LDAPGroup"])[];
    };
    /** @description A LDAP group */
    LDAPGroup: {
      has_syncables?: boolean;
      mattermost_group_id?: string;
      primary_key?: string;
      name?: string;
    };
    /** @description User's sidebar category */
    SidebarCategory: {
      id?: string;
      user_id?: string;
      team_id?: string;
      display_name?: string;
      /** @enum {string} */
      type?: "channels" | "custom" | "direct_messages" | "favorites";
    };
    /** @description User's sidebar category with it's channels */
    SidebarCategoryWithChannels: {
      id?: string;
      user_id?: string;
      team_id?: string;
      display_name?: string;
      /** @enum {string} */
      type?: "channels" | "custom" | "direct_messages" | "favorites";
      channel_ids?: (string)[];
    };
    /** @description List of user's categories with their channels */
    OrderedSidebarCategories: {
      order?: (string)[];
      categories?: (components["schemas"]["SidebarCategoryWithChannels"])[];
    };
    /** @description A bot account */
    Bot: {
      /** @description The user id of the associated user entry. */
      user_id?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a bot was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a bot was last updated
       */
      update_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a bot was deleted
       */
      delete_at?: number;
      username?: string;
      display_name?: string;
      description?: string;
      /** @description The user id of the user that currently owns this bot. */
      owner_id?: string;
    };
    Server_Busy: {
      /** @description True if the server is marked as busy (under high load) */
      busy?: boolean;
      /**
       * Format: int64 
       * @description timestamp - number of seconds since Jan 1, 1970 UTC.
       */
      expires?: number;
    };
    /** @description group augmented with scheme admin information */
    GroupWithSchemeAdmin: {
      group?: components["schemas"]["Group"];
      scheme_admin?: boolean;
    };
    /** @description a map of channel id(s) to the set of groups that constrain the corresponding channel in a team */
    GroupsAssociatedToChannels: {
      [key: string]: (components["schemas"]["GroupWithSchemeAdmin"])[] | undefined;
    };
    /** @description an object containing information about an orphaned record. */
    OrphanedRecord: {
      /** @description the id of the parent relation (table) entry. */
      parent_id?: string;
      /** @description the id of the child relation (table) entry. */
      child_id?: string;
    };
    /** @description a thread that user is following */
    UserThread: {
      /** @description ID of the post that is this thread's root */
      id?: string;
      /** @description number of replies in this thread */
      reply_count?: number;
      /**
       * Format: int64 
       * @description timestamp of the last post to this thread
       */
      last_reply_at?: number;
      /**
       * Format: int64 
       * @description timestamp of the last time the user viewed this thread
       */
      last_viewed_at?: number;
      /** @description list of users participating in this thread. only includes IDs unless 'extended' was set to 'true' */
      participants?: (components["schemas"]["Post"])[];
      post?: components["schemas"]["Post"];
    };
    /** @description an object containing the results of a relational integrity check. */
    RelationalIntegrityCheckData: {
      /** @description the name of the parent relation (table). */
      parent_name?: string;
      /** @description the name of the child relation (table). */
      child_name?: string;
      /** @description the name of the attribute (column) containing the parent id. */
      parent_id_attr?: string;
      /** @description the name of the attribute (column) containing the child id. */
      child_id_attr?: string;
      /** @description the list of orphaned records found. */
      records?: (components["schemas"]["OrphanedRecord"])[];
    };
    /** @description an object with the result of the integrity check. */
    IntegrityCheckResult: {
      data?: components["schemas"]["RelationalIntegrityCheckData"];
      /** @description a string value set in case of error. */
      err?: string;
    };
    /** @description an object containing information used to keep track of a file upload. */
    UploadSession: {
      /** @description The unique identifier for the upload. */
      id?: string;
      /**
       * @description The type of the upload. 
       * @enum {string}
       */
      type?: "attachment" | "import";
      /**
       * Format: int64 
       * @description The time the upload was created in milliseconds.
       */
      create_at?: number;
      /** @description The ID of the user performing the upload. */
      user_id?: string;
      /** @description The ID of the channel to upload to. */
      channel_id?: string;
      /** @description The name of the file to upload. */
      filename?: string;
      /**
       * Format: int64 
       * @description The size of the file to upload in bytes.
       */
      file_size?: number;
      /**
       * Format: int64 
       * @description The amount of data uploaded in bytes.
       */
      file_offset?: number;
    };
    Notice: {
      /** @description Notice ID */
      id?: string;
      /** @description Does this notice apply only to sysadmins */
      sysAdminOnly?: boolean;
      /** @description Does this notice apply only to team admins */
      teamAdminOnly?: boolean;
      /** @description Optional action to perform on action button click. (defaults to closing the notice) */
      action?: string;
      /**
       * @description Optional action parameter. 
       * Example: {"action": "url", actionParam: "/console/some-page"}
       */
      actionParam?: string;
      /** @description Optional override for the action button text (defaults to OK) */
      actionText?: string;
      /** @description Notice content. Use {{Mattermost}} instead of plain text to support white-labeling. Text supports Markdown. */
      description?: string;
      /** @description URL of image to display */
      image?: string;
      /** @description Notice title. Use {{Mattermost}} instead of plain text to support white-labeling. Text supports Markdown. */
      title?: string;
    };
    SharedChannel: {
      /** @description Channel id of the shared channel */
      id?: string;
      team_id?: string;
      /** @description Is this the home cluster for the shared channel */
      home?: boolean;
      /** @description Is this shared channel shared as read only */
      readonly?: boolean;
      /** @description Channel name as it is shared (may be different than original channel name) */
      name?: string;
      /** @description Channel display name as it appears locally */
      display_name?: string;
      purpose?: string;
      header?: string;
      /** @description Id of the user that shared the channel */
      creator_id?: string;
      /** @description Time in milliseconds that the channel was shared */
      create_at?: number;
      /** @description Time in milliseconds that the shared channel record was last updated */
      update_at?: number;
      /** @description Id of the remote cluster where the shared channel is homed */
      remote_id?: string;
    };
    RemoteClusterInfo: {
      /** @description The display name for the remote cluster */
      display_name?: string;
      /**
       * Format: int64 
       * @description The time in milliseconds a remote cluster was created
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The time in milliseconds a remote cluster was last pinged successfully
       */
      last_ping_at?: number;
    };
    SystemStatusResponse: {
      /** @description Latest Android version supported */
      AndroidLatestVersion?: string;
      /** @description Minimum Android version supported */
      AndroidMinVersion?: string;
      /** @description Latest desktop version supported */
      DesktopLatestVersion?: string;
      /** @description Minimum desktop version supported */
      DesktopMinVersion?: string;
      /** @description Latest iOS version supported */
      IosLatestVersion?: string;
      /** @description Minimum iOS version supported */
      IosMinVersion?: string;
      /** @description Status of database ("OK" or "UNHEALTHY"). Included when get_server_status parameter set. */
      database_status?: string;
      /** @description Status of filestore ("OK" or "UNHEALTHY"). Included when get_server_status parameter set. */
      filestore_status?: string;
      /** @description Status of server ("OK" or "UNHEALTHY"). Included when get_server_status parameter set. */
      status?: string;
      /** @description Whether the device id provided can receive notifications ("true", "false" or "unknown"). Included when device_id parameter set. */
      CanReceiveNotifications?: string;
    };
    UserThreads: {
      /** @description Total number of threads (used for paging) */
      total?: number;
      /** @description Array of threads */
      threads?: (components["schemas"]["UserThread"])[];
    };
    LicenseRenewalLink: {
      /** @description License renewal link */
      renewal_link?: string;
    };
    System: {
      /** @description System property name */
      name?: string;
      /** @description System property value */
      value?: string;
    };
    PostsUsage: {
      /** @description Total no. of posts */
      count?: number;
    };
    StorageUsage: {
      /** @description Total file storage usage for the instance in bytes rounded down to the most significant digit */
      bytes?: number;
    };
    PlaybookRun: {
      /**
       * @description A unique, 26 characters long, alphanumeric identifier for the playbook run. 
       * @example mx3xyzdojfgyfdx8sc8of1gdme
       */
      id?: string;
      /**
       * @description The name of the playbook run. 
       * @example Server down in EU cluster
       */
      name?: string;
      /**
       * @description The description of the playbook run. 
       * @example There is one server in the EU cluster that is not responding since April 12.
       */
      description?: string;
      /**
       * @description True if the playbook run is ongoing; false if the playbook run is ended. 
       * @example false
       */
      is_active?: boolean;
      /**
       * @description The identifier of the user that is commanding the playbook run. 
       * @example bqnbdf8uc0a8yz4i39qrpgkvtg
       */
      owner_user_id?: string;
      /**
       * @description The identifier of the team where the playbook run's channel is in. 
       * @example 61ji2mpflefup3cnuif80r5rde
       */
      team_id?: string;
      /**
       * @description The identifier of the playbook run's channel. 
       * @example hwrmiyzj3kadcilh3ukfcnsbt6
       */
      channel_id?: string;
      /**
       * Format: int64 
       * @description The playbook run creation timestamp, formatted as the number of milliseconds since the Unix epoch. 
       * @example 1606807976289
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The playbook run finish timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not finished. 
       * @example 0
       */
      end_at?: number;
      /**
       * Format: int64 
       * @description The playbook run deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not deleted. 
       * @example 0
       */
      delete_at?: number;
      /**
       * Format: int32 
       * @description Zero-based index of the currently active stage. 
       * @example 1
       */
      active_stage?: number;
      /**
       * @description The title of the currently active stage. 
       * @example Triage issue
       */
      active_stage_title?: string;
      /**
       * @description If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty. 
       * @example b2ntfcrl4ujivl456ab4b3aago
       */
      post_id?: string;
      /**
       * @description The identifier of the playbook with from which this playbook run was created. 
       * @example 0y4a0ntte97cxvfont8y84wa7x
       */
      playbook_id?: string;
      checklists?: (components["schemas"]["Checklist"])[];
    };
    PlaybookRunMetadata: {
      /**
       * @description Name of the channel associated to the playbook run. 
       * @example server-down-in-eu-cluster
       */
      channel_name?: string;
      /**
       * @description Display name of the channel associated to the playbook run. 
       * @example Server down in EU cluster
       */
      channel_display_name?: string;
      /**
       * @description Name of the team the playbook run is in. 
       * @example sre-staff
       */
      team_name?: string;
      /**
       * Format: int64 
       * @description Number of users that have been members of the playbook run at any point. 
       * @example 25
       */
      num_members?: number;
      /**
       * Format: int64 
       * @description Number of posts in the channel associated to the playbook run. 
       * @example 202
       */
      total_posts?: number;
    };
    PlaybookRunList: {
      /**
       * Format: int32 
       * @description The total number of playbook runs in the list, regardless of the paging. 
       * @example 305
       */
      total_count?: number;
      /**
       * Format: int32 
       * @description The total number of pages. This depends on the total number of playbook runs in the database and the per_page parameter sent with the request. 
       * @example 2
       */
      page_count?: number;
      /**
       * @description A boolean describing whether there are more pages after the currently returned. 
       * @example true
       */
      has_more?: boolean;
      /** @description The playbook runs in this page. */
      items?: (components["schemas"]["PlaybookRun"])[];
    };
    PlaybookAutofollows: {
      /**
       * Format: int32 
       * @description The total number of users who marked this playbook to auto-follow runs. 
       * @example 12
       */
      total_count?: number;
      /** @description The user IDs of who marked this playbook to auto-follow. */
      items?: (string)[];
    };
    OwnerInfo: {
      /**
       * @description A unique, 26 characters long, alphanumeric identifier for the owner. 
       * @example ahz0s61gh275i7z2ag4g1ntvjm
       */
      user_id: string;
      /**
       * @description Owner's username. 
       * @example aaron.medina
       */
      username: string;
    };
    TriggerIdReturn: {
      /**
       * @description The trigger_id returned by the slash command. 
       * @example ceenjwsg6tgdzjpofxqemy1aio
       */
      trigger_id: string;
    };
    Playbook: {
      /**
       * @description A unique, 26 characters long, alphanumeric identifier for the playbook. 
       * @example iz0g457ikesz55dhxcfa0fk9yy
       */
      id?: string;
      /**
       * @description The title of the playbook. 
       * @example Cloud PlaybookRuns
       */
      title?: string;
      /**
       * @description The description of the playbook. 
       * @example A playbook to follow when there is a playbook run regarding the availability of the cloud service.
       */
      description?: string;
      /**
       * @description The identifier of the team where the playbook is in. 
       * @example p03rbi6viyztysbqnkvcqyel2i
       */
      team_id?: string;
      /**
       * @description A boolean indicating whether the playbook runs created from this playbook should be public or private. 
       * @example true
       */
      create_public_playbook_run?: boolean;
      /**
       * Format: int64 
       * @description The playbook creation timestamp, formatted as the number of milliseconds since the Unix epoch. 
       * @example 1602235338837
       */
      create_at?: number;
      /**
       * Format: int64 
       * @description The playbook deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook is not deleted. 
       * @example 0
       */
      delete_at?: number;
      /**
       * Format: int64 
       * @description The number of stages defined in this playbook. 
       * @example 3
       */
      num_stages?: number;
      /**
       * Format: int64 
       * @description The total number of steps from all the stages defined in this playbook. 
       * @example 18
       */
      num_steps?: number;
      /** @description The stages defined in this playbook. */
      checklists?: (components["schemas"]["Checklist"])[];
      /** @description The identifiers of all the users that are members of this playbook. */
      member_ids?: (string)[];
    };
    PlaybookList: {
      /**
       * Format: int32 
       * @description The total number of playbooks in the list, regardless of the paging. 
       * @example 305
       */
      total_count?: number;
      /**
       * Format: int32 
       * @description The total number of pages. This depends on the total number of playbooks in the database and the per_page parameter sent with the request. 
       * @example 2
       */
      page_count?: number;
      /**
       * @description A boolean describing whether there are more pages after the currently returned. 
       * @example true
       */
      has_more?: boolean;
      /** @description The playbooks in this page. */
      items?: (components["schemas"]["Playbook"])[];
    };
    Checklist: {
      /**
       * @description A unique, 26 characters long, alphanumeric identifier for the checklist. 
       * @example 6f6nsgxzoq84fqh1dnlyivgafd
       */
      id?: string;
      /**
       * @description The title of the checklist. 
       * @example Triage issue
       */
      title?: string;
      /** @description The list of tasks to do. */
      items?: (components["schemas"]["ChecklistItem"])[];
    };
    ChecklistItem: {
      /**
       * @description A unique, 26 characters long, alphanumeric identifier for the checklist item. 
       * @example 6f6nsgxzoq84fqh1dnlyivgafd
       */
      id?: string;
      /**
       * @description The title of the checklist item. 
       * @example Gather information from customer.
       */
      title?: string;
      /**
       * @description The state of the checklist item. An empty string means that the item is not done. 
       * @example closed 
       * @enum {string}
       */
      state?: "" | "in_progress" | "closed";
      /**
       * Format: int64 
       * @description The timestamp for the latest modification of the item's state, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item was never modified. 
       * @example 1607774621321
       */
      state_modified?: number;
      /**
       * @description The identifier of the user that has been assigned to complete this item. If the item has no assignee, this is an empty string. 
       * @example pisdatkjtdlkdhht2v4inxuzx1
       */
      assignee_id?: string;
      /**
       * Format: int64 
       * @description The timestamp for the latest modification of the item's assignee, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item never got an assignee. 
       * @example 1608897821125
       */
      assignee_modified?: number;
      /**
       * @description The slash command associated with this item. If the item has no slash command associated, this is an empty string 
       * @example /opsgenie on-call
       */
      command?: string;
      /**
       * Format: int64 
       * @description The timestamp for the latest execution of the item's command, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the command was never executed. 
       * @example 1608552221019
       */
      command_last_run?: number;
      /**
       * @description A detailed description of the checklist item, formatted with Markdown. 
       * @example Ask the customer for more information in [Zendesk](https://www.zendesk.com/).
       */
      description?: string;
    };
    Error: {
      /**
       * @description A message with the error description. 
       * @example Error retrieving the resource.
       */
      error: string;
      /**
       * @description Further details on where and why this error happened. 
       * @example Specific details about the error, depending on the case.
       */
      details: string;
    };
    WebhookOnCreationPayload: components["schemas"]["PlaybookRun"] & {
      /**
       * @description Absolute URL to the playbook run's channel. 
       * @example https://example.com/ad-1/channels/channel-name
       */
      channel_url?: string;
      /**
       * @description Absolute URL to the playbook run's details. 
       * @example https://example.com/ad-1/playbooks/runs/playbookRunID
       */
      details_url?: string;
    };
    WebhookOnStatusUpdatePayload: components["schemas"]["PlaybookRun"] & {
      /**
       * @description Absolute URL to the playbook run's channel. 
       * @example https://example.com/ad-1/channels/channel-name
       */
      channel_url?: string;
      /**
       * @description Absolute URL to the playbook run's details. 
       * @example https://example.com/ad-1/playbooks/runs/playbookRunID
       */
      details_url?: string;
    };
  };
  responses: {
    /** @description The request is malformed. */
    400: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Access to the resource is forbidden for this user. */
    403: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Resource requested not found. */
    404: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description There was an internal error in the server. */
    500: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Do not have appropriate permissions */
    Forbidden: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description No access token provided */
    Unauthorized: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Invalid or missing parameters in URL or request body */
    BadRequest: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Resource not found */
    NotFound: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Content too large */
    TooLarge: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Feature is disabled */
    NotImplemented: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Too many requests */
    TooManyRequests: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
    /** @description Something went wrong with the server */
    InternalServerError: {
      content: {
        "application/json": components["schemas"]["AppError"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Get a list of the top reactions for a team. 
   * @description Get a list of the top reactions across all public and private channels (the user is a member of) for a given team.
   * ##### Permissions
   * Must have `view_team` permission for the team.
   */
  GetTopReactionsForTeam: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: reactions posted on the current day.
         * - `7_day`: reactions posted in the last 7 days.
         * - `28_day`: reactions posted in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Top reactions retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopReactionList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top reactions for a user. 
   * @description Get a list of the top reactions across all public and private channels (the user is a member of) for a given user.
   * If no `team_id` is provided, this will also include reactions posted by the given user in direct and group messages.
   * ##### Permissions
   * Must be logged in as the user.
   */
  GetTopReactionsForUser: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: reactions posted on the current day.
         * - `7_day`: reactions posted in the last 7 days.
         * - `28_day`: reactions posted in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
        /**
         * @description Team ID will scope the response to a given team and exclude direct and group messages.
         * ##### Permissions
         * Must have `view_team` permission for the team.
         */
        team_id?: string;
      };
    };
    responses: {
      /** @description Top reactions retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopReactionList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top channels for a team. 
   * @description Get a list of the top public and private channels (the user is a member of) for a given team.
   * ##### Permissions
   * Must have `view_team` permission for the team.
   */
  GetTopChannelsForTeam: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: channels with posts on the current day.
         * - `7_day`: channels with posts in the last 7 days.
         * - `28_day`: channels with posts in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Top channels retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopChannelList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top channels for a user. 
   * @description Get a list of the top public and private channels (the user is a member of) for a given user.
   * ##### Permissions
   * Must be logged in as the user.
   */
  GetTopChannelsForUser: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: channels with posts on the current day.
         * - `7_day`: channels with posts in the last 7 days.
         * - `28_day`: channels with posts in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
        /**
         * @description Team ID will scope the response to a given team.
         * ##### Permissions
         * Must have `view_team` permission for the team.
         */
        team_id?: string;
      };
    };
    responses: {
      /** @description Top channels retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopChannelList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of new team members. 
   * @description Get a list of all of the new team members that have joined the given team during the given time period.
   * ##### Permissions
   * Must have `view_team` permission for the team.
   */
  GetNewTeamMembers: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: team members who joined during the current day.
         * - `7_day`: team members who joined in the last 7 days.
         * - `28_day`: team members who joined in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description New team members retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["NewTeamMembersList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top threads for a team. 
   * @description Get a list of the top threads from public and private channels (the user is a member of) for a given team.
   * ##### Permissions
   * Must have `view_team` permission for the team.
   */
  GetTopThreadsForTeam: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: threads with activity on the current day.
         * - `7_day`: threads with activity in the last 7 days.
         * - `28_day`: threads with activity in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Top threads retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopThreadList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top threads for a user. 
   * @description Get a list of the top threads from public and private channels (the user is a member of and participating in the thread) for a given user.
   * ##### Permissions
   * Must be logged in as the user.
   */
  GetTopThreadsForUser: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: threads with activity on the current day.
         * - `7_day`: threads with activity in the last 7 days.
         * - `28_day`: threads with activity in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
        /**
         * @description Team ID will scope the response to a given team.
         * ##### Permissions
         * Must have `view_team` permission for the team.
         */
        team_id?: string;
      };
    };
    responses: {
      /** @description Top threads retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopThreadList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of the top dms for a user. 
   * @description Get a list of the top dms for a given user.
   * ##### Permissions
   * Must be logged in as the user.
   */
  GetTopDMsForUser: {
    parameters: {
      query: {
        /**
         * @description Time range can be "today", "7_day", or "28_day".
         * - `today`: threads with activity on the current day.
         * - `7_day`: threads with activity in the last 7 days.
         * - `28_day`: threads with activity in the last 28 days.
         */
        time_range: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of items per page, up to a maximum of 200. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Top dms retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["TopDMList"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Login to Mattermost server 
   * @description ##### Permissions
   * No permission required
   */
  Login: {
    /** @description User authentication object */
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          login_id?: string;
          token?: string;
          device_id?: string;
          ldap_only?: boolean;
          /** @description The password used for email authentication. */
          password?: string;
        };
      };
    };
    responses: {
      /** @description User login successful */
      201: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Auto-Login to Mattermost server using CWS token 
   * @description CWS stands for Customer Web Server which is the cloud service used to manage cloud instances.
   * ##### Permissions
   * A Cloud license is required
   */
  LoginByCwsToken: {
    /** @description User authentication object */
    requestBody: {
      content: {
        "application/json": {
          login_id?: string;
          cws_token?: string;
        };
      };
    };
    responses: {
      /** @description Login successful, it'll redirect to login page to perform the autologin */
      302: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Logout from the Mattermost server 
   * @description ##### Permissions
   * An active session is required
   */
  Logout: {
    responses: {
      /** @description User logout successful */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get users 
   * @description Get a page of a list of users. Based on query string parameters, select users from a team, channel, or select users not in a specific channel.
   * 
   * Since server version 4.0, some basic sorting is available using the `sort` query parameter. Sorting is currently only supported when selecting users on a team.
   * ##### Permissions
   * Requires an active session and (if specified) membership to the channel or team being selected from.
   */
  GetUsers: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. There is a maximum limit of 200 users per page. */
        per_page?: number;
        /** @description The ID of the team to get users for. */
        in_team?: string;
        /** @description The ID of the team to exclude users for. Must not be used with "in_team" query parameter. */
        not_in_team?: string;
        /** @description The ID of the channel to get users for. */
        in_channel?: string;
        /** @description The ID of the channel to exclude users for. Must be used with "in_channel" query parameter. */
        not_in_channel?: string;
        /** @description The ID of the group to get users for. Must have `manage_system` permission. */
        in_group?: string;
        /** @description When used with `not_in_channel` or `not_in_team`, returns only the users that are allowed to join the channel or team based on its group constrains. */
        group_constrained?: boolean;
        /** @description Whether or not to list users that are not on any team. This option takes precendence over `in_team`, `in_channel`, and `not_in_channel`. */
        without_team?: boolean;
        /** @description Whether or not to list only users that are active. This option cannot be used along with the `inactive` option. */
        active?: boolean;
        /** @description Whether or not to list only users that are deactivated. This option cannot be used along with the `active` option. */
        inactive?: boolean;
        /** @description Returns users that have this role. */
        role?: string;
        /**
         * @description Sort is only available in conjunction with certain options below. The paging parameter is also always available.
         * 
         * ##### `in_team`
         * Can be "", "last_activity_at" or "create_at".
         * When left blank, sorting is done by username.
         * __Minimum server version__: 4.0
         * ##### `in_channel`
         * Can be "", "status".
         * When left blank, sorting is done by username. `status` will sort by User's current status (Online, Away, DND, Offline), then by Username.
         * __Minimum server version__: 4.7
         * ##### `in_group`
         * Can be "", "display_name".
         * When left blank, sorting is done by username. `display_name` will sort alphabetically by user's display name.
         * __Minimum server version__: 7.7
         */
        sort?: string;
        /**
         * @description Comma separated string used to filter users based on any of the specified system roles
         * 
         * Example: `?roles=system_admin,system_user` will return users that are either system admins or system users
         * 
         * __Minimum server version__: 5.26
         */
        roles?: string;
        /**
         * @description Comma separated string used to filter users based on any of the specified channel roles, can only be used in conjunction with `in_channel`
         * 
         * Example: `?in_channel=4eb6axxw7fg3je5iyasnfudc5y&channel_roles=channel_user` will return users that are only channel users and not admins or guests
         * 
         * __Minimum server version__: 5.26
         */
        channel_roles?: string;
        /**
         * @description Comma separated string used to filter users based on any of the specified team roles, can only be used in conjunction with `in_team`
         * 
         * Example: `?in_team=4eb6axxw7fg3je5iyasnfudc5y&team_roles=team_user` will return users that are only team users and not admins or guests
         * 
         * __Minimum server version__: 5.26
         */
        team_roles?: string;
      };
    };
    responses: {
      /** @description User page retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["User"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a user 
   * @description Create a new user on the system. Password is required for email login. For other authentication types such as LDAP or SAML, auth_data and auth_service fields are required.
   * ##### Permissions
   * No permission required for creating email/username accounts on an open server. Auth Token is required for other authentication types such as LDAP or SAML.
   */
  CreateUser: {
    parameters: {
      query: {
        /** @description Token id from an email invitation */
        t?: string;
        /** @description Token id from an invitation link */
        iid?: string;
      };
    };
    /** @description User object to be created */
    requestBody: {
      content: {
        "application/json": {
          email: string;
          username: string;
          first_name?: string;
          last_name?: string;
          nickname?: string;
          /** @description Service-specific authentication data, such as email address. */
          auth_data?: string;
          /** @description The authentication service, one of "email", "gitlab", "ldap", "saml", "office365", "google", and "". */
          auth_service?: string;
          /** @description The password used for email authentication. */
          password?: string;
          locale?: string;
          props?: Record<string, never>;
          notify_props?: components["schemas"]["UserNotifyProps"];
        };
      };
    };
    responses: {
      /** @description User creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Permanent delete all users 
   * @description Permanently deletes all users and all their related information, including posts.
   * 
   * __Minimum server version__: 5.26.0
   * 
   * __Local mode only__: This endpoint is only available through [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
   */
  PermanentDeleteAllUsers: {
    responses: {
      /** @description Delete request was successful */
      200: never;
    };
  };
  /**
   * Get users by ids 
   * @description Get a list of users based on a provided list of user ids.
   * ##### Permissions
   * Requires an active session but no other permissions.
   */
  GetUsersByIds: {
    parameters: {
      query: {
        /**
         * @description Only return users that have been modified since the given Unix timestamp (in milliseconds).
         * 
         * __Minimum server version__: 5.14
         */
        since?: number;
      };
    };
    /** @description List of user ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description User list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["User"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get users by group channels ids 
   * @description Get an object containing a key per group channel id in the
   * query and its value as a list of users members of that group
   * channel.
   * 
   * The user must be a member of the group ids in the query, or
   * they will be omitted from the response.
   * ##### Permissions
   * Requires an active session but no other permissions.
   * 
   * __Minimum server version__: 5.14
   */
  GetUsersByGroupChannelIds: {
    /** @description List of group channel ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description User list retrieval successful */
      200: {
        content: {
          "application/json": {
            "<CHANNEL_ID>"?: (components["schemas"]["User"])[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get users by usernames 
   * @description Get a list of users based on a provided list of usernames.
   * ##### Permissions
   * Requires an active session but no other permissions.
   */
  GetUsersByUsernames: {
    /** @description List of usernames */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description User list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["User"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Search users 
   * @description Get a list of users based on search criteria provided in the request body. Searches are typically done against username, full name, nickname and email unless otherwise configured by the server.
   * ##### Permissions
   * Requires an active session and `read_channel` and/or `view_team` permissions for any channels or teams specified in the request body.
   */
  SearchUsers: {
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The term to match against username, full name, nickname and email */
          term: string;
          /** @description If provided, only search users on this team */
          team_id?: string;
          /** @description If provided, only search users not on this team */
          not_in_team_id?: string;
          /** @description If provided, only search users in this channel */
          in_channel_id?: string;
          /** @description If provided, only search users not in this channel. Must specifiy `team_id` when using this option */
          not_in_channel_id?: string;
          /** @description If provided, only search users in this group. Must have `manage_system` permission. */
          in_group_id?: string;
          /** @description When used with `not_in_channel_id` or `not_in_team_id`, returns only the users that are allowed to join the channel or team based on its group constrains. */
          group_constrained?: boolean;
          /** @description When `true`, include deactivated users in the results */
          allow_inactive?: boolean;
          /** @description Set this to `true` if you would like to search for users that are not on a team. This option takes precendence over `team_id`, `in_channel_id`, and `not_in_channel_id`. */
          without_team?: boolean;
          /**
           * @description The maximum number of users to return in the results
           * 
           * __Available as of server version 5.6. Defaults to `100` if not provided or on an earlier server version.__
           *  
           * @default 100
           */
          limit?: number;
        };
      };
    };
    responses: {
      /** @description User list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["User"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Autocomplete users 
   * @description Get a list of users for the purpose of autocompleting based on the provided search term. Specify a combination of `team_id` and `channel_id` to filter results further.
   * ##### Permissions
   * Requires an active session and `view_team` and `read_channel` on any teams or channels used to filter the results further.
   */
  AutocompleteUsers: {
    parameters: {
      query: {
        /** @description Team ID */
        team_id?: string;
        /** @description Channel ID */
        channel_id?: string;
        /** @description Username, nickname first name or last name */
        name: string;
        /**
         * @description The maximum number of users to return in each subresult
         * 
         * __Available as of server version 5.6. Defaults to `100` if not provided or on an earlier server version.__
         */
        limit?: number;
      };
    };
    responses: {
      /** @description User autocomplete successful */
      200: {
        content: {
          "application/json": components["schemas"]["UserAutocomplete"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get user IDs of known users 
   * @description Get the list of user IDs of users with any direct relationship with a
   * user. That means any user sharing any channel, including direct and
   * group channels.
   * ##### Permissions
   * Must be authenticated.
   * 
   * __Minimum server version__: 5.23
   */
  GetKnownUsers: {
    responses: {
      /** @description Known users' IDs retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["KnownUsers"];
        };
      };
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get total count of users in the system 
   * @description Get a total count of users in the system.
   * ##### Permissions
   * Must be authenticated.
   */
  GetTotalUsersStats: {
    responses: {
      /** @description User stats retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["UsersStats"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get total count of users in the system matching the specified filters 
   * @description Get a count of users in the system matching the specified filters.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetTotalUsersStatsFiltered: {
    parameters: {
      query: {
        /** @description The ID of the team to get user stats for. */
        in_team?: string;
        /** @description The ID of the channel to get user stats for. */
        in_channel?: string;
        /** @description If deleted accounts should be included in the count. */
        include_deleted?: boolean;
        /** @description If bot accounts should be included in the count. */
        include_bots?: boolean;
        /**
         * @description Comma separated string used to filter users based on any of the specified system roles
         * 
         * Example: `?roles=system_admin,system_user` will include users that are either system admins or system users
         */
        roles?: string;
        /**
         * @description Comma separated string used to filter users based on any of the specified channel roles, can only be used in conjunction with `in_channel`
         * 
         * Example: `?in_channel=4eb6axxw7fg3je5iyasnfudc5y&channel_roles=channel_user` will include users that are only channel users and not admins or guests
         */
        channel_roles?: string;
        /**
         * @description Comma separated string used to filter users based on any of the specified team roles, can only be used in conjunction with `in_team`
         * 
         * Example: `?in_team=4eb6axxw7fg3je5iyasnfudc5y&team_roles=team_user` will include users that are only team users and not admins or guests
         */
        team_roles?: string;
      };
    };
    responses: {
      /** @description Filtered User stats retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["UsersStats"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a user 
   * @description Get a user a object. Sensitive information will be sanitized out.
   * ##### Permissions
   * Requires an active session but no other permissions.
   */
  GetUser: {
    parameters: {
      path: {
        /** @description User GUID. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description User retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update a user 
   * @description Update a user by providing the user object. The fields that can be updated are defined in the request body, all other provided fields will be ignored. Any fields not included in the request body will be set to null or reverted to default values.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  UpdateUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description User object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          id: string;
          email: string;
          username: string;
          first_name?: string;
          last_name?: string;
          nickname?: string;
          locale?: string;
          position?: string;
          timezone?: components["schemas"]["Timezone"];
          props?: Record<string, never>;
          notify_props?: components["schemas"]["UserNotifyProps"];
        };
      };
    };
    responses: {
      /** @description User update successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Deactivate a user account. 
   * @description Deactivates the user and revokes all its sessions by archiving its user object.
   * 
   * As of server version 5.28, optionally use the `permanent=true` query parameter to permanently delete the user for compliance reasons. To use this feature `ServiceSettings.EnableAPIUserDeletion` must be set to `true` in the server's configuration.
   * ##### Permissions
   * Must be logged in as the user being deactivated or have the `edit_other_users` permission.
   */
  DeleteUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User deactivation successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Patch a user 
   * @description Partially update a user by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  PatchUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description User object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          email?: string;
          username?: string;
          first_name?: string;
          last_name?: string;
          nickname?: string;
          locale?: string;
          position?: string;
          props?: Record<string, never>;
          notify_props?: components["schemas"]["UserNotifyProps"];
        };
      };
    };
    responses: {
      /** @description User patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update a user's roles 
   * @description Update a user's system-level roles. Valid user roles are "system_user", "system_admin" or both of them. Overwrites any previously assigned system-level roles.
   * ##### Permissions
   * Must have the `manage_roles` permission.
   */
  UpdateUserRoles: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Space-delimited system roles to assign to the user */
    requestBody: {
      content: {
        "application/json": {
          roles: string;
        };
      };
    };
    responses: {
      /** @description User roles update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update user active status 
   * @description Update user active or inactive status.
   * 
   * __Since server version 4.6, users using a SSO provider to login can be activated or deactivated with this endpoint. However, if their activation status in Mattermost does not reflect their status in the SSO provider, the next synchronization or login by that user will reset the activation status to that of their account in the SSO provider. Server versions 4.5 and before do not allow activation or deactivation of SSO users from this endpoint.__
   * ##### Permissions
   * User can deactivate themselves.
   * User with `manage_system` permission can activate or deactivate a user.
   */
  UpdateUserActive: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Use `true` to set the user active, `false` for inactive */
    requestBody: {
      content: {
        "application/json": {
          active: boolean;
        };
      };
    };
    responses: {
      /** @description User active status update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get user's profile image 
   * @description Get a user's profile image based on user_id string parameter.
   * ##### Permissions
   * Must be logged in.
   */
  GetProfileImage: {
    parameters: {
      query: {
        /** @description Not used by the server. Clients can pass in the last picture update time of the user to potentially take advantage of caching */
        _?: number;
      };
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User's profile image */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Set user's profile image 
   * @description Set a user's profile image based on user_id string parameter.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  SetProfileImage: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The image to be uploaded
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description Profile image set successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete user's profile image 
   * @description Delete user's profile image and reset to default image based on user_id string parameter.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   * __Minimum server version__: 5.5
   */
  SetDefaultProfileImage: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Profile image reset successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Return user's default (generated) profile image 
   * @description Returns the default (generated) user profile image based on user_id string parameter.
   * ##### Permissions
   * Must be logged in.
   * __Minimum server version__: 5.5
   */
  GetDefaultProfileImage: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Default profile image */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a user by username 
   * @description Get a user object by providing a username. Sensitive information will be sanitized out.
   * ##### Permissions
   * Requires an active session but no other permissions.
   */
  GetUserByUsername: {
    parameters: {
      path: {
        /** @description Username */
        username: string;
      };
    };
    responses: {
      /** @description User retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Reset password 
   * @description Update the password for a user using a one-use, timed recovery code tied to the user's account. Only works for non-SSO users.
   * ##### Permissions
   * No permissions required.
   */
  ResetPassword: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The recovery code */
          code: string;
          /** @description The new password for the user */
          new_password: string;
        };
      };
    };
    responses: {
      /** @description User password update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update a user's MFA 
   * @description Activates multi-factor authentication for the user if `activate` is true and a valid `code` is provided. If activate is false, then `code` is not required and multi-factor authentication is disabled for the user.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  UpdateUserMfa: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Use `true` to activate, `false` to deactivate */
          activate: boolean;
          /** @description The code produced by your MFA client. Required if `activate` is true */
          code?: string;
        };
      };
    };
    responses: {
      /** @description User MFA update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Generate MFA secret 
   * @description Generates an multi-factor authentication secret for a user and returns it as a string and as base64 encoded QR code image.
   * ##### Permissions
   * Must be logged in as the user or have the `edit_other_users` permission.
   */
  GenerateMfaSecret: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description MFA secret generation successful */
      200: {
        content: {
          "application/json": {
            /** @description The MFA secret as a string */
            secret?: string;
            /** @description A base64 encoded QR code image */
            qr_code?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Demote a user to a guest 
   * @description Convert a regular user into a guest. This will convert the user into a
   * guest for the whole system while retaining their existing team and
   * channel memberships.
   * 
   * __Minimum server version__: 5.16
   * 
   * ##### Permissions
   * Must be logged in as the user or have the `demote_to_guest` permission.
   */
  DemoteUserToGuest: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User successfully demoted */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Promote a guest to user 
   * @description Convert a guest into a regular user. This will convert the guest into a
   * user for the whole system while retaining any team and channel
   * memberships and automatically joining them to the default channels.
   * 
   * __Minimum server version__: 5.16
   * 
   * ##### Permissions
   * Must be logged in as the user or have the `promote_guest` permission.
   */
  PromoteGuestToUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Guest successfully promoted */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Convert a user into a bot 
   * @description Convert a user into a bot.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  ConvertUserToBot: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User successfully converted */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Check MFA 
   * @description Check if a user has multi-factor authentication active on their account by providing a login id. Used to check whether an MFA code needs to be provided when logging in.
   * ##### Permissions
   * No permission required.
   */
  CheckUserMfa: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The email or username used to login */
          login_id: string;
        };
      };
    };
    responses: {
      /** @description MFA check successful */
      200: {
        content: {
          "application/json": {
            /** @description Value will `true` if MFA is active, `false` otherwise */
            mfa_required?: boolean;
          };
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Update a user's password 
   * @description Update a user's password. New password must meet password policy set by server configuration. Current password is required if you're updating your own password.
   * ##### Permissions
   * Must be logged in as the user the password is being changed for or have `manage_system` permission.
   */
  UpdateUserPassword: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The current password for the user */
          current_password?: string;
          /** @description The new password for the user */
          new_password: string;
        };
      };
    };
    responses: {
      /** @description User password update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Send password reset email 
   * @description Send an email containing a link for resetting the user's password. The link will contain a one-use, timed recovery code tied to the user's account. Only works for non-SSO users.
   * ##### Permissions
   * No permissions required.
   */
  SendPasswordResetEmail: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The email of the user */
          email: string;
        };
      };
    };
    responses: {
      /** @description Email sent if account exists */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a user by email 
   * @description Get a user object by providing a user email. Sensitive information will be sanitized out.
   * ##### Permissions
   * Requires an active session and for the current session to be able to view another user's email based on the server's privacy settings.
   */
  GetUserByEmail: {
    parameters: {
      path: {
        /** @description User Email */
        email: string;
      };
    };
    responses: {
      /** @description User retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get user's sessions 
   * @description Get a list of sessions by providing the user GUID. Sensitive information will be sanitized out.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  GetSessions: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User session retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Session"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Revoke a user session 
   * @description Revokes a user session from the provided user id and session id strings.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  RevokeSession: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The session GUID to revoke. */
          session_id: string;
        };
      };
    };
    responses: {
      /** @description User session revoked successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Revoke all active sessions for a user 
   * @description Revokes all user sessions from the provided user id and session id strings.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   * __Minimum server version__: 4.4
   */
  RevokeAllSessions: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User sessions revoked successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Attach mobile device 
   * @description Attach a mobile device id to the currently logged in session. This will enable push notifications for a user, if configured by the server.
   * ##### Permissions
   * Must be authenticated.
   */
  AttachDeviceId: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Mobile device id. For Android prefix the id with `android:` and Apple with `apple:` */
          device_id: string;
        };
      };
    };
    responses: {
      /** @description Device id attach successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get user's audits 
   * @description Get a list of audit by providing the user GUID.
   * ##### Permissions
   * Must be logged in as the user or have the `edit_other_users` permission.
   */
  GetUserAudits: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User audits retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Audit"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Verify user email by ID 
   * @description Verify the email used by a user without a token.
   * 
   * __Minimum server version__: 5.24
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission.
   */
  VerifyUserEmailWithoutToken: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User email verification successful */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Verify user email 
   * @description Verify the email used by a user to sign-up their account with.
   * ##### Permissions
   * No permissions required.
   */
  VerifyUserEmail: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The token given to validate the email */
          token: string;
        };
      };
    };
    responses: {
      /** @description User email verification successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Send verification email 
   * @description Send an email with a verification link to a user that has an email matching the one in the request body. This endpoint will return success even if the email does not match any users on the system.
   * ##### Permissions
   * No permissions required.
   */
  SendVerificationEmail: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Email of a user */
          email: string;
        };
      };
    };
    responses: {
      /** @description Email send successful if email exists */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Switch login method 
   * @description Switch a user's login method from using email to OAuth2/SAML/LDAP or back to email. When switching to OAuth2/SAML, account switching is not complete until the user follows the returned link and completes any steps on the OAuth2/SAML service provider.
   * 
   * To switch from email to OAuth2/SAML, specify `current_service`, `new_service`, `email` and `password`.
   * 
   * To switch from OAuth2/SAML to email, specify `current_service`, `new_service`, `email` and `new_password`.
   * 
   * To switch from email to LDAP/AD, specify `current_service`, `new_service`, `email`, `password`, `ldap_ip` and `new_password` (this is the user's LDAP password).
   * 
   * To switch from LDAP/AD to email, specify `current_service`, `new_service`, `ldap_ip`, `password` (this is the user's LDAP password), `email`  and `new_password`.
   * 
   * Additionally, specify `mfa_code` when trying to switch an account on LDAP/AD or email that has MFA activated.
   * 
   * ##### Permissions
   * No current authentication required except when switching from OAuth2/SAML to email.
   */
  SwitchAccountType: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The service the user currently uses to login */
          current_service: string;
          /** @description The service the user will use to login */
          new_service: string;
          /** @description The email of the user */
          email?: string;
          /** @description The password used with the current service */
          password?: string;
          /** @description The MFA code of the current service */
          mfa_code?: string;
          /** @description The LDAP/AD id of the user */
          ldap_id?: string;
        };
      };
    };
    responses: {
      /** @description Login method switch or request successful */
      200: {
        content: {
          "application/json": {
            /** @description The link for the user to follow to login or to complete the account switching when the current service is OAuth2/SAML */
            follow_link?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get user access tokens 
   * @description Get a list of user access tokens for a user. Does not include the actual authentication tokens. Use query parameters for paging.
   * 
   * __Minimum server version__: 4.1
   * 
   * ##### Permissions
   * Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  GetUserAccessTokensForUser: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of tokens per page. */
        per_page?: number;
      };
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User access tokens retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["UserAccessTokenSanitized"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a user access token 
   * @description Generate a user access token that can be used to authenticate with the Mattermost REST API.
   * 
   * __Minimum server version__: 4.1
   * 
   * ##### Permissions
   * Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  CreateUserAccessToken: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the token usage */
          description: string;
        };
      };
    };
    responses: {
      /** @description User access token creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["UserAccessToken"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get user access tokens 
   * @description Get a page of user access tokens for users on the system. Does not include the actual authentication tokens. Use query parameters for paging.
   * 
   * __Minimum server version__: 4.7
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetUserAccessTokens: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of tokens per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description User access tokens retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["UserAccessTokenSanitized"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Revoke a user access token 
   * @description Revoke a user access token and delete any sessions using the token.
   * 
   * __Minimum server version__: 4.1
   * 
   * ##### Permissions
   * Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  RevokeUserAccessToken: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The user access token GUID to revoke */
          token_id: string;
        };
      };
    };
    responses: {
      /** @description User access token revoke successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a user access token 
   * @description Get a user access token. Does not include the actual authentication token.
   * 
   * __Minimum server version__: 4.1
   * 
   * ##### Permissions
   * Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  GetUserAccessToken: {
    parameters: {
      path: {
        /** @description User access token GUID */
        token_id: string;
      };
    };
    responses: {
      /** @description User access token retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["UserAccessTokenSanitized"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Disable personal access token 
   * @description Disable a personal access token and delete any sessions using the token. The token can be re-enabled using `/users/tokens/enable`.
   * 
   * __Minimum server version__: 4.4
   * 
   * ##### Permissions
   * Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  DisableUserAccessToken: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The personal access token GUID to disable */
          token_id: string;
        };
      };
    };
    responses: {
      /** @description Personal access token disable successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Enable personal access token 
   * @description Re-enable a personal access token that has been disabled.
   * 
   * __Minimum server version__: 4.4
   * 
   * ##### Permissions
   * Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission.
   */
  EnableUserAccessToken: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The personal access token GUID to enable */
          token_id: string;
        };
      };
    };
    responses: {
      /** @description Personal access token enable successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Search tokens 
   * @description Get a list of tokens based on search criteria provided in the request body. Searches are done against the token id, user id and username.
   * 
   * __Minimum server version__: 4.7
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  SearchUserAccessTokens: {
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the token id, user id or username. */
          term: string;
        };
      };
    };
    responses: {
      /** @description Personal access token search successful */
      200: {
        content: {
          "application/json": (components["schemas"]["UserAccessTokenSanitized"])[];
        };
      };
    };
  };
  /**
   * Update a user's authentication method 
   * @description Updates a user's authentication method. This can be used to change them to/from LDAP authentication for example.
   * 
   * __Minimum server version__: 4.6
   * ##### Permissions
   * Must have the `edit_other_users` permission.
   */
  UpdateUserAuth: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserAuthData"];
      };
    };
    responses: {
      /** @description User auth update successful */
      200: {
        content: {
          "application/json": components["schemas"]["UserAuthData"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Fetches user's latest terms of service action if the latest action was for acceptance. 
   * @description Will be deprecated in v6.0
   * Fetches user's latest terms of service action if the latest action was for acceptance.
   * 
   * __Minimum server version__: 5.6
   * ##### Permissions
   * Must be logged in as the user being acted on.
   */
  GetUserTermsOfService: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User's accepted terms of service action */
      200: {
        content: {
          "application/json": components["schemas"]["UserTermsOfService"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description User hasn't performed an action or the latest action was a rejection. */
      404: {
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
    };
  };
  /**
   * Records user action when they accept or decline custom terms of service 
   * @description Records user action when they accept or decline custom terms of service. Records the action in audit table.
   * Updates user's last accepted terms of service ID if they accepted it.
   * 
   * __Minimum server version__: 5.4
   * ##### Permissions
   * Must be logged in as the user being acted on.
   */
  RegisterTermsOfServiceAction: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description terms of service details */
    requestBody: {
      content: {
        "application/json": {
          /** @description terms of service ID on which the user is acting on */
          serviceTermsId: string;
          /** @description true or false, indicates whether the user accepted or rejected the terms of service. */
          accepted: string;
        };
      };
    };
    responses: {
      /** @description Terms of service action recorded successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Revoke all sessions from all users. 
   * @description For any session currently on the server (including admin) it will be revoked.
   * Clients will be notified to log out users.
   * 
   * __Minimum server version__: 5.14
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  RevokeSessionsFromAllUsers: {
    responses: {
      /** @description Sessions successfully revoked. */
      200: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Publish a user typing websocket event. 
   * @description Notify users in the given channel via websocket that the given user is typing.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must have `manage_system` permission to publish for any user other than oneself.
   */
  PublishUserTyping: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description The id of the channel to which to direct the typing event. */
          channel_id: string;
          /** @description The optional id of the root post of the thread to which the user is replying. If unset, the typing event is directed at the entire channel. */
          parent_id?: string;
        };
      };
    };
    responses: {
      /** @description User typing websocket event accepted for publishing. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get uploads for a user 
   * @description Gets all the upload sessions belonging to a user.
   * 
   * __Minimum server version__: 5.28
   * 
   * ##### Permissions
   * Must be logged in as the user who created the upload sessions.
   */
  GetUploadsForUser: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description User's uploads retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["UploadSession"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get all channel members from all teams for a user 
   * @description Get all channel members from all teams for a user.
   * 
   * __Minimum server version__: 6.2.0
   * 
   * ##### Permissions
   * Logged in as the user, or have `edit_other_users` permission.
   */
  GetChannelMembersWithTeamDataForUser: {
    parameters: {
      query: {
        /** @description Page specifies which part of the results to return, by PageSize. */
        page?: number;
        /** @description PageSize specifies the size of the returned chunk of results. */
        pageSize?: number;
      };
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description User's uploads retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelMemberWithTeamData"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Migrate user accounts authentication type to LDAP. 
   * @description Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to LDAP.
   * __Minimum server version__: 5.28
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  MigrateAuthToLdap: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description The current authentication type for the matched users. */
          from: string;
          /** @description Foreign user field name to match. */
          match_field: string;
          force: boolean;
        };
      };
    };
    responses: {
      /** @description Successfully migrated authentication type to LDAP. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Migrate user accounts authentication type to SAML. 
   * @description Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to SAML.
   * __Minimum server version__: 5.28
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  MigrateAuthToSaml: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description The current authentication type for the matched users. */
          from: string;
          /** @description Users map. */
          matches: Record<string, never>;
          auto: boolean;
        };
      };
    };
    responses: {
      /** @description Successfully migrated authentication type to LDAP. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get all threads that user is following 
   * @description Get all threads that user is following
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  GetUserThreads: {
    parameters: {
      query: {
        /** @description Since filters the threads based on their LastUpdateAt timestamp. */
        since?: number;
        /** @description Deleted will specify that even deleted threads should be returned (For mobile sync). */
        deleted?: boolean;
        /** @description Extended will enrich the response with participant details. */
        extended?: boolean;
        /** @description Page specifies which part of the results to return, by PageSize. */
        page?: number;
        /** @description PageSize specifies the size of the returned chunk of results. */
        pageSize?: number;
        /** @description Setting this to true will only return the total counts. */
        totalsOnly?: boolean;
        /** @description Setting this to true will only return threads. */
        threadsOnly?: boolean;
      };
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
      };
    };
    responses: {
      /** @description User's thread retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["UserThreads"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get all unread mention counts from followed threads, per-channel 
   * @description Get all unread mention counts from followed threads
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  GetThreadMentionCountsByChannel: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
      };
    };
    responses: {
      /** @description Get was successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Mark all threads that user is following as read 
   * @description Mark all threads that user is following as read
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  UpdateThreadsReadForUser: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
      };
    };
    responses: {
      /** @description User's thread update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Mark a thread that user is following read state to the timestamp 
   * @description Mark a thread that user is following as read
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  UpdateThreadReadForUser: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
        /** @description The ID of the thread to update */
        thread_id: string;
        /** @description The timestamp to which the thread's "last read" state will be reset. */
        timestamp: string;
      };
    };
    responses: {
      /** @description User's thread update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Mark a thread that user is following as unread based on a post id 
   * @description Mark a thread that user is following as unread
   * 
   * __Minimum server version__: 6.7
   * 
   * ##### Permissions
   * Must have `read_channel` permission for the channel the thread is in or if the channel is public, have the `read_public_channels` permission for the team.
   * 
   * Must have `edit_other_users` permission if the user is not the one marking the thread for himself.
   */
  SetThreadUnreadByPostId: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
        /** @description The ID of the thread to update */
        thread_id: string;
        /** @description The ID of a post belonging to the thread to mark as unread. */
        post_id: string;
      };
    };
    responses: {
      /** @description User's thread update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Start following a thread 
   * @description Start following a thread
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  StartFollowingThread: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
        /** @description The ID of the thread to follow */
        thread_id: string;
      };
    };
    responses: {
      /** @description User's thread update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Stop following a thread 
   * @description Stop following a thread
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  StopFollowingThread: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
        /** @description The ID of the thread to update */
        thread_id: string;
      };
    };
    responses: {
      /** @description User's thread update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a thread followed by the user 
   * @description Get a thread
   * 
   * __Minimum server version__: 5.29
   * 
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  GetUserThread: {
    parameters: {
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
        /** @description The ID of the team in which the thread is. */
        team_id: string;
        /** @description The ID of the thread to follow */
        thread_id: string;
      };
    };
    responses: {
      /** @description Get was successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get the policies which are applied to a user's teams 
   * @description Gets the policies which are applied to the all of the teams to which a user belongs.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must be logged in as the user or have the `manage_system` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetTeamPoliciesForUser: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of policies per page. There is a maximum limit of 200 per page. */
        per_page?: number;
      };
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description Teams for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["RetentionPolicyForTeamList"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the policies which are applied to a user's channels 
   * @description Gets the policies which are applied to the all of the channels to which a user belongs.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must be logged in as the user or have the `manage_system` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetChannelPoliciesForUser: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of policies per page. There is a maximum limit of 200 per page. */
        per_page?: number;
      };
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description Channels for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["RetentionPolicyForChannelList"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get user status 
   * @description Get user status by id from the server.
   * ##### Permissions
   * Must be authenticated.
   */
  GetUserStatus: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    responses: {
      /** @description User status retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Status"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Update user status 
   * @description Manually set a user's status. When setting a user's status, the status will remain that value until set "online" again, which will return the status to being automatically updated based on user activity.
   * ##### Permissions
   * Must have `edit_other_users` permission for the team.
   */
  UpdateUserStatus: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    /** @description Status object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description User ID */
          user_id: string;
          /** @description User status, can be `online`, `away`, `offline` and `dnd` */
          status: string;
          /** @description Time in epoch seconds at which a dnd status would be unset. */
          dnd_end_time?: number;
        };
      };
    };
    responses: {
      /** @description User status update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Status"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get user statuses by id 
   * @description Get a list of user statuses by id from the server.
   * ##### Permissions
   * Must be authenticated.
   */
  GetUsersStatusesByIds: {
    /** @description List of user ids to fetch */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description User statuses retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Status"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Update user custom status 
   * @description Updates a user's custom status by setting the value in the user's props and updates the user. Also save the given custom status to the recent custom statuses in the user's props
   * ##### Permissions
   * Must be logged in as the user whose custom status is being updated.
   */
  UpdateUserCustomStatus: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    /** @description Custom status object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description Any emoji */
          emoji: string;
          /** @description Any custom status text */
          text: string;
          /** @description Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time` */
          duration?: string;
          /** @description The time at which custom status should be expired. It should be in ISO format. */
          expires_at?: string;
        };
      };
    };
    responses: {
      /** @description User custom status update successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Unsets user custom status 
   * @description Unsets a user's custom status by updating the user's props and updates the user
   * ##### Permissions
   * Must be logged in as the user whose custom status is being removed.
   */
  UnsetUserCustomStatus: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    responses: {
      /** @description User custom status delete successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Delete user's recent custom status 
   * @description Deletes a user's recent custom status by removing the specific status from the recentCustomStatuses in the user's props and updates the user.
   * ##### Permissions
   * Must be logged in as the user whose recent custom status is being deleted.
   */
  RemoveRecentCustomStatus: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    /** @description Custom Status object that is to be removed from the recent custom statuses. */
    requestBody: {
      content: {
        "application/json": {
          /** @description Any emoji */
          emoji: string;
          /** @description Any custom status text */
          text: string;
          /** @description Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time` */
          duration: string;
          /** @description The time at which custom status should be expired. It should be in ISO format. */
          expires_at: string;
        };
      };
    };
    responses: {
      /** @description User recent custom status delete successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Delete user's recent custom status 
   * @description Deletes a user's recent custom status by removing the specific status from the recentCustomStatuses in the user's props and updates the user.
   * ##### Permissions
   * Must be logged in as the user whose recent custom status is being deleted.
   */
  PostUserRecentCustomStatusDelete: {
    parameters: {
      path: {
        /** @description User ID */
        user_id: string;
      };
    };
    /** @description Custom Status object that is to be removed from the recent custom statuses. */
    requestBody: {
      content: {
        "application/json": {
          /** @description Any emoji */
          emoji: string;
          /** @description Any custom status text */
          text: string;
          /** @description Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time` */
          duration: string;
          /** @description The time at which custom status should be expired. It should be in ISO format. */
          expires_at: string;
        };
      };
    };
    responses: {
      /** @description User recent custom status delete successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get teams 
   * @description For regular users only returns open teams. Users with the "manage_system" permission will return teams regardless of type. The result is based on query string parameters - page and per_page.
   * ##### Permissions
   * Must be authenticated. "manage_system" permission is required to show all teams.
   */
  GetAllTeams: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of teams per page. */
        per_page?: number;
        /** @description Appends a total count of returned teams inside the response object - ex: `{ "teams": [], "total_count" : 0 }`. */
        include_total_count?: boolean;
        /**
         * @description If set to true, teams which are part of a data retention policy will be excluded. The `sysconsole_read_compliance` permission is required to use this parameter.
         * __Minimum server version__: 5.35
         */
        exclude_policy_constrained?: boolean;
      };
    };
    responses: {
      /** @description Team list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Team"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Create a team 
   * @description Create a new team on the system.
   * ##### Permissions
   * Must be authenticated and have the `create_team` permission.
   */
  CreateTeam: {
    /** @description Team that is to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description Unique handler for a team, will be present in the team URL */
          name: string;
          /** @description Non-unique UI name for the team */
          display_name: string;
          /** @description `'O'` for open, `'I'` for invite only */
          type: string;
        };
      };
    };
    responses: {
      /** @description Team creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a team 
   * @description Get a team on the system.
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  GetTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update a team 
   * @description Update a team by providing the team object. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * Must have the `manage_team` permission.
   */
  UpdateTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Team to update */
    requestBody: {
      content: {
        "application/json": {
          id: string;
          display_name: string;
          description: string;
          company_name: string;
          allowed_domains: string;
          invite_id: string;
          allow_open_invite: string;
        };
      };
    };
    responses: {
      /** @description Team update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete a team 
   * @description Soft deletes a team, by marking the team as deleted in the database. Soft deleted teams will not be accessible in the user interface.
   * 
   * Optionally use the permanent query parameter to hard delete the team for compliance reasons. As of server version 5.0, to use this feature `ServiceSettings.EnableAPITeamDeletion` must be set to `true` in the server's configuration.
   * ##### Permissions
   * Must have the `manage_team` permission.
   */
  SoftDeleteTeam: {
    parameters: {
      query: {
        /** @description Permanently delete the team, to be used for compliance reasons only. As of server version 5.0, `ServiceSettings.EnableAPITeamDeletion` must be set to `true` in the server's configuration. */
        permanent?: boolean;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Patch a team 
   * @description Partially update a team by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * Must have the `manage_team` permission.
   */
  PatchTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Team object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          display_name?: string;
          description?: string;
          company_name?: string;
          invite_id?: string;
          allow_open_invite?: boolean;
        };
      };
    };
    responses: {
      /** @description team patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update teams's privacy 
   * @description Updates team's privacy allowing changing a team from Public (open) to Private (invitation only) and back.
   * 
   * __Minimum server version__: 5.24
   * 
   * ##### Permissions
   * `manage_team` permission for the team of the team.
   */
  UpdateTeamPrivacy: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Team privacy setting: 'O' for a public (open) team, 'I' for a private (invitation only) team */
          privacy: string;
        };
      };
    };
    responses: {
      /** @description Team conversion successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Restore a team 
   * @description Restore a team that was previously soft deleted.
   * 
   * __Minimum server version__: 5.24
   * 
   * ##### Permissions
   * Must have the `manage_team` permission.
   */
  RestoreTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team restore successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a team by name 
   * @description Get a team based on provided name string
   * ##### Permissions
   * Must be authenticated, team type is open and have the `view_team` permission.
   */
  GetTeamByName: {
    parameters: {
      path: {
        /** @description Team Name */
        name: string;
      };
    };
    responses: {
      /** @description Team retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Search teams 
   * @description Search teams based on search term and options provided in the request body.
   * 
   * ##### Permissions
   * Logged in user only shows open teams
   * Logged in user with "manage_system" permission shows all teams
   */
  SearchTeams: {
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the name or display name of teams */
          term?: string;
          /** @description The page number to return, if paginated. If this parameter is not present with the `per_page` parameter then the results will be returned un-paged. */
          page?: string;
          /** @description The number of entries to return per page, if paginated. If this parameter is not present with the `page` parameter then the results will be returned un-paged. */
          per_page?: string;
          /**
           * @description Filters results to teams where `allow_open_invite` is set to true or false, excludes group constrained channels if this filter option is passed.
           * If this filter option is not passed then the query will remain unchanged.
           * __Minimum server version__: 5.28
           */
          allow_open_invite?: boolean;
          /**
           * @description Filters results to teams where `group_constrained` is set to true or false, returns the union of results when used with `allow_open_invite`
           * If the filter option is not passed then the query will remain unchanged.
           * __Minimum server version__: 5.28
           */
          group_constrained?: boolean;
          /**
           * @description If set to true, only teams which do not have a granular retention policy assigned to them will be returned. The `sysconsole_read_compliance_data_retention` permission is required to use this parameter.
           * __Minimum server version__: 5.35
           *  
           * @default false
           */
          exclude_policy_constrained?: boolean;
        };
      };
    };
    responses: {
      /** @description Paginated teams response. (Note that the non-paginated responsereturned if the request body does not contain both `page` and `per_page` fieldsis a simple array of teams.) */
      200: {
        content: {
          "application/json": {
            /** @description The teams that matched the query. */
            teams?: (components["schemas"]["Team"])[];
            /** @description The total number of results, regardless of page and per_page requested. */
            total_count?: number;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Check if team exists 
   * @description Check if the team exists based on a team name.
   * ##### Permissions
   * Must be authenticated.
   */
  TeamExists: {
    parameters: {
      path: {
        /** @description Team Name */
        name: string;
      };
    };
    responses: {
      /** @description Team retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["TeamExists"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a user's teams 
   * @description Get a list of teams that a user is on.
   * ##### Permissions
   * Must be authenticated as the user or have the `manage_system` permission.
   */
  GetTeamsForUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Team list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Team"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get team members 
   * @description Get a page team members list based on query string parameters - team id, page and per page.
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  GetTeamMembers: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team members retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["TeamMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Add user to team 
   * @description Add user to the team by user_id.
   * ##### Permissions
   * Must be authenticated and team be open to add self. For adding another user, authenticated user must have the `add_user_to_team` permission.
   */
  AddTeamMember: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          team_id?: string;
          user_id?: string;
        };
      };
    };
    responses: {
      /** @description Team member creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["TeamMember"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Add user to team from invite 
   * @description Using either an invite id or hash/data pair from an email invite link, add a user to a team.
   * ##### Permissions
   * Must be authenticated.
   */
  AddTeamMemberFromInvite: {
    parameters: {
      query: {
        /** @description Token id from the invitation */
        token: string;
      };
    };
    responses: {
      /** @description Team member creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["TeamMember"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Add multiple users to team 
   * @description Add a number of users to the team by user_id.
   * ##### Permissions
   * Must be authenticated. Authenticated user must have the `add_user_to_team` permission.
   */
  AddTeamMembers: {
    parameters: {
      query: {
        /** @description Instead of aborting the operation if a user cannot be added, return an arrray that will contain both the success and added members and the ones with error, in form of `[{"member": {...}, "user_id", "...", "error": {...}}]` */
        graceful?: boolean;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (components["schemas"]["TeamMember"])[];
      };
    };
    responses: {
      /** @description Team members created successfully. */
      201: {
        content: {
          "application/json": (components["schemas"]["TeamMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get team members for a user 
   * @description Get a list of team members for a user. Useful for getting the ids of teams the user is on and the roles they have in those teams.
   * ##### Permissions
   * Must be logged in as the user or have the `edit_other_users` permission.
   */
  GetTeamMembersForUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Team members retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["TeamMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a team member 
   * @description Get a team member on the system.
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  GetTeamMember: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Team member retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["TeamMember"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Remove user from team 
   * @description Delete the team member object for a user, effectively removing them from a team.
   * ##### Permissions
   * Must be logged in as the user or have the `remove_user_from_team` permission.
   */
  RemoveTeamMember: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Team member deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get team members by ids 
   * @description Get a list of team members based on a provided array of user ids.
   * ##### Permissions
   * Must have `view_team` permission for the team.
   */
  GetTeamMembersByIds: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description List of user ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Team members retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["TeamMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a team stats 
   * @description Get a team stats on the system.
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  GetTeamStats: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team stats retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["TeamStats"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Regenerate the Invite ID from a Team 
   * @description Regenerates the invite ID used in invite links of a team
   * ##### Permissions
   * Must be authenticated and have the `manage_team` permission.
   */
  RegenerateTeamInviteId: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team Invite ID regenerated */
      200: {
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get the team icon 
   * @description Get the team icon of the team.
   * 
   * __Minimum server version__: 4.9
   * 
   * ##### Permissions
   * User must be authenticated. In addition, team must be open or the user must have the `view_team` permission.
   */
  GetTeamIcon: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team icon retrieval successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Sets the team icon 
   * @description Sets the team icon for the team.
   * 
   * __Minimum server version__: 4.9
   * 
   * ##### Permissions
   * Must be authenticated and have the `manage_team` permission.
   */
  SetTeamIcon: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The image to be uploaded
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description Team icon successfully set */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove the team icon 
   * @description Remove the team icon for the team.
   * 
   * __Minimum server version__: 4.10
   * 
   * ##### Permissions
   * Must be authenticated and have the `manage_team` permission.
   */
  RemoveTeamIcon: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team icon successfully remove */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Update a team member roles 
   * @description Update a team member roles. Valid team roles are "team_user", "team_admin" or both of them. Overwrites any previously assigned team roles.
   * ##### Permissions
   * Must be authenticated and have the `manage_team_roles` permission.
   */
  UpdateTeamMemberRoles: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Space-delimited team roles to assign to the user */
    requestBody: {
      content: {
        "application/json": {
          roles: string;
        };
      };
    };
    responses: {
      /** @description Team member roles update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update the scheme-derived roles of a team member. 
   * @description Update a team member's scheme_admin/scheme_user properties. Typically this should either be `scheme_admin=false, scheme_user=true` for ordinary team member, or `scheme_admin=true, scheme_user=true` for a team admin.
   * 
   * __Minimum server version__: 5.0
   * 
   * ##### Permissions
   * Must be authenticated and have the `manage_team_roles` permission.
   */
  UpdateTeamMemberSchemeRoles: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Scheme properties. */
    requestBody: {
      content: {
        "application/json": {
          scheme_admin: boolean;
          scheme_user: boolean;
        };
      };
    };
    responses: {
      /** @description Team member's scheme-derived roles updated successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get team unreads for a user 
   * @description Get the count for unread messages and mentions in the teams the user is a member of.
   * ##### Permissions
   * Must be logged in.
   */
  GetTeamsUnreadForUser: {
    parameters: {
      query: {
        /** @description Optional team id to be excluded from the results */
        exclude_team: string;
        /** @description Boolean to determine whether the collapsed threads should be included or not */
        include_collapsed_threads?: boolean;
      };
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Team unreads retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["TeamUnread"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get unreads for a team 
   * @description Get the unread mention and message counts for a team for the specified user.
   * ##### Permissions
   * Must be the user or have `edit_other_users` permission and have `view_team` permission for the team.
   */
  GetTeamUnread: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team unread count retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["TeamUnread"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Invite users to the team by email 
   * @description Invite users to the existing team using the user's email.
   * 
   * The number of emails that can be sent is rate limited to 20 per hour with a burst of 20 emails. If the rate limit exceeds, the error message contains details on when to retry and when the timer will be reset.
   * ##### Permissions
   * Must have `invite_user` and `add_user_to_team` permissions for the team.
   */
  InviteUsersToTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description List of user's email */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Users invite successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
    };
  };
  /**
   * Invite guests to the team by email 
   * @description Invite guests to existing team channels usign the user's email.
   * 
   * The number of emails that can be sent is rate limited to 20 per hour with a burst of 20 emails. If the rate limit exceeds, the error message contains details on when to retry and when the timer will be reset.
   * 
   * __Minimum server version__: 5.16
   * 
   * ##### Permissions
   * Must have `invite_guest` permission for the team.
   */
  InviteGuestsToTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Guests invite information */
    requestBody: {
      content: {
        "application/json": {
          /** @description List of emails */
          emails: (string)[];
          /** @description List of channel ids */
          channels: (string)[];
          /** @description Message to include in the invite */
          message?: string;
        };
      };
    };
    responses: {
      /** @description Guests invite successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
    };
  };
  /**
   * Invalidate active email invitations 
   * @description Invalidate active email invitations that have not been accepted by the user.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  InvalidateEmailInvites: {
    responses: {
      /** @description Email invites successfully revoked */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Import a Team from other application 
   * @description Import a team into a existing team. Import users, channels, posts, hooks.
   * ##### Permissions
   * Must have `permission_import_team` permission.
   */
  ImportTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description A file to be uploaded in zip format.
           */
          file: string;
          /** @description The size of the zip file to be imported. */
          filesize: number;
          /** @description String that defines from which application the team was exported to be imported into Mattermost. */
          importFrom: string;
        };
      };
    };
    responses: {
      /** @description JSON object containing a base64 encoded text file of the import logs in its `results` property. */
      200: {
        content: {
          "application/json": {
            results?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get invite info for a team 
   * @description Get the `name`, `display_name`, `description` and `id` for a team from the invite id.
   * 
   * __Minimum server version__: 4.0
   * 
   * ##### Permissions
   * No authentication required.
   */
  GetTeamInviteInfo: {
    parameters: {
      path: {
        /** @description Invite id for a team */
        invite_id: string;
      };
    };
    responses: {
      /** @description Team invite info retrieval successful */
      200: {
        content: {
          "application/json": {
            id?: string;
            name?: string;
            display_name?: string;
            description?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Set a team's scheme 
   * @description Set a team's scheme, more specifically sets the scheme_id value of a team record.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.0
   */
  UpdateTeamScheme: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Scheme GUID */
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the scheme. */
          scheme_id: string;
        };
      };
    };
    responses: {
      /** @description Update team scheme successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Team members minus group members. 
   * @description Get the set of users who are members of the team minus the set of users who are members of the given groups.
   * Each user object contains an array of group objects representing the group memberships for that user.
   * Each user object contains the boolean fields `scheme_guest`, `scheme_user`, and `scheme_admin` representing the roles that user has for the given team.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.14
   */
  TeamMembersMinusGroupMembers: {
    parameters: {
      query: {
        /** @description A comma-separated list of group ids. */
        group_ids: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Successfully returns users specified by the pagination, and the total_count. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of all channels 
   * @description ##### Permissions
   * `manage_system`
   */
  GetAllChannels: {
    parameters: {
      query: {
        /** @description A group id to exclude channels that are associated with that group via GroupChannel records. This can also be left blank with `not_associated_to_group=`. */
        not_associated_to_group?: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of channels per page. */
        per_page?: number;
        /** @description Whether to exclude default channels (ex Town Square, Off-Topic) from the results. */
        exclude_default_channels?: boolean;
        /** @description Include channels that have been archived. This correlates to the `DeleteAt` flag being set in the database. */
        include_deleted?: boolean;
        /** @description Appends a total count of returned channels inside the response object - ex: `{ "channels": [], "total_count" : 0 }`. */
        include_total_count?: boolean;
        /**
         * @description If set to true, channels which are part of a data retention policy will be excluded. The `sysconsole_read_compliance` permission is required to use this parameter.
         * __Minimum server version__: 5.35
         */
        exclude_policy_constrained?: boolean;
      };
    };
    responses: {
      /** @description Channel list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelListWithTeamData"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create a channel 
   * @description Create a new channel.
   * ##### Permissions
   * If creating a public channel, `create_public_channel` permission is required. If creating a private channel, `create_private_channel` permission is required.
   */
  CreateChannel: {
    /** @description Channel object to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description The team ID of the team to create the channel on */
          team_id: string;
          /** @description The unique handle for the channel, will be present in the channel URL */
          name: string;
          /** @description The non-unique UI name for the channel */
          display_name: string;
          /** @description A short description of the purpose of the channel */
          purpose?: string;
          /** @description Markdown-formatted text to display in the header of the channel */
          header?: string;
          /** @description 'O' for a public channel, 'P' for a private channel */
          type: string;
        };
      };
    };
    responses: {
      /** @description Channel creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a direct message channel 
   * @description Create a new direct message channel between two users.
   * ##### Permissions
   * Must be one of the two users and have `create_direct_channel` permission. Having the `manage_system` permission voids the previous requirements.
   */
  CreateDirectChannel: {
    /** @description The two user ids to be in the direct message */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Direct channel creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a group message channel 
   * @description Create a new group message channel to group of users. If the logged in user's id is not included in the list, it will be appended to the end.
   * ##### Permissions
   * Must have `create_group_channel` permission.
   */
  CreateGroupChannel: {
    /** @description User ids to be in the group message channel */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Group channel creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Search all private and open type channels across all teams 
   * @description Returns all private and open type channels where 'term' matches on the name, display name, or purpose of
   * the channel.
   * 
   * Configured 'default' channels (ex Town Square and Off-Topic) can be excluded from the results
   * with the `exclude_default_channels` boolean parameter.
   * 
   * Channels that are associated (via GroupChannel records) to a given group can be excluded from the results
   * with the `not_associated_to_group` parameter and a group id string.
   */
  SearchAllChannels: {
    parameters: {
      query: {
        /** @description Is the request from system_console. If this is set to true, it filters channels by the logged in user. */
        system_console?: boolean;
      };
    };
    /** @description The search terms and logic to use in the search. */
    requestBody: {
      content: {
        "application/json": {
          /** @description The string to search in the channel name, display name, and purpose. */
          term: string;
          /** @description A group id to exclude channels that are associated to that group via GroupChannel records. */
          not_associated_to_group?: string;
          /** @description Exclude default channels from the results by setting this parameter to true. */
          exclude_default_channels?: boolean;
          /**
           * @description Filters results to channels belonging to the given team ids
           * 
           * __Minimum server version__: 5.26
           */
          team_ids?: (string)[];
          /**
           * @description Filters results to only return channels constrained to a group
           * 
           * __Minimum server version__: 5.26
           */
          group_constrained?: boolean;
          /**
           * @description Filters results to exclude channels constrained to a group
           * 
           * __Minimum server version__: 5.26
           */
          exclude_group_constrained?: boolean;
          /**
           * @description Filters results to only return Public / Open channels, can be used in conjunction with `private` to return both `public` and `private` channels
           * 
           * __Minimum server version__: 5.26
           */
          public?: boolean;
          /**
           * @description Filters results to only return Private channels, can be used in conjunction with `public` to return both `private` and `public` channels
           * 
           * __Minimum server version__: 5.26
           */
          private?: boolean;
          /**
           * @description Filters results to only return deleted / archived channels
           * 
           * __Minimum server version__: 5.26
           */
          deleted?: boolean;
          /** @description The page number to return, if paginated. If this parameter is not present with the `per_page` parameter then the results will be returned un-paged. */
          page?: string;
          /** @description The number of entries to return per page, if paginated. If this parameter is not present with the `page` parameter then the results will be returned un-paged. */
          per_page?: string;
          /**
           * @description If set to true, only channels which do not have a granular retention policy assigned to them will be returned. The `sysconsole_read_compliance_data_retention` permission is required to use this parameter.
           * __Minimum server version__: 5.35
           *  
           * @default false
           */
          exclude_policy_constrained?: boolean;
          /**
           * @description If set to true, returns channels where given search 'term' matches channel ID.
           * __Minimum server version__: 5.35
           *  
           * @default false
           */
          include_search_by_id?: boolean;
        };
      };
    };
    responses: {
      /** @description Paginated channel response. (Note that the non-paginated responsereturned if the request body does not contain both `page` and `per_page` fieldsis a simple array of channels.) */
      200: {
        content: {
          "application/json": {
            /** @description The channels that matched the query. */
            channels?: (components["schemas"]["Channel"])[];
            /** @description The total number of results, regardless of page and per_page requested. */
            total_count?: number;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Search Group Channels 
   * @description Get a list of group channels for a user which members' usernames match the search term.
   * 
   * __Minimum server version__: 5.14
   */
  SearchGroupChannels: {
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the members' usernames of the group channels */
          term: string;
        };
      };
    };
    responses: {
      /** @description Channels search successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get a list of channels by ids 
   * @description Get a list of public channels on a team by id.
   * ##### Permissions
   * `view_team` for the team the channels are on.
   */
  GetPublicChannelsByIdsForTeam: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description List of channel ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Channel list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get timezones in a channel 
   * @description Get a list of timezones for the users who are in this channel.
   * 
   * __Minimum server version__: 5.6
   * 
   * ##### Permissions
   * Must have the `read_channel` permission.
   */
  GetChannelMembersTimezones: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Timezone retrieval successful */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a channel 
   * @description Get channel from the provided channel id string.
   * ##### Permissions
   * `read_channel` permission for the channel.
   */
  GetChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update a channel 
   * @description Update a channel. The fields that can be updated are listed as parameters. Omitted fields will be treated as blanks.
   * ##### Permissions
   * If updating a public channel, `manage_public_channel_members` permission is required. If updating a private channel, `manage_private_channel_members` permission is required.
   */
  UpdateChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    /** @description Channel object to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description The channel's id, not updatable */
          id: string;
          /** @description The unique handle for the channel, will be present in the channel URL */
          name?: string;
          /** @description The non-unique UI name for the channel */
          display_name?: string;
          /** @description A short description of the purpose of the channel */
          purpose?: string;
          /** @description Markdown-formatted text to display in the header of the channel */
          header?: string;
        };
      };
    };
    responses: {
      /** @description Channel update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete a channel 
   * @description Archives a channel. This will set the `deleteAt` to the current timestamp in the database. Soft deleted channels may not be accessible in the user interface. They can be viewed and unarchived in the **System Console > User Management > Channels** based on your license. Direct and group message channels cannot be deleted.
   * 
   * As of server version 5.28, optionally use the `permanent=true` query parameter to permanently delete the channel for compliance reasons. To use this feature `ServiceSettings.EnableAPIChannelDeletion` must be set to `true` in the server's configuration.  If you permanently delete a channel this action is not recoverable outside of a database backup.
   * 
   * ##### Permissions
   * `delete_public_channel` permission if the channel is public,
   * `delete_private_channel` permission if the channel is private,
   * or have `manage_system` permission.
   */
  DeleteChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Patch a channel 
   * @description Partially update a channel by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * If updating a public channel, `manage_public_channel_members` permission is required. If updating a private channel, `manage_private_channel_members` permission is required.
   */
  PatchChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    /** @description Channel object to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description The unique handle for the channel, will be present in the channel URL */
          name?: string;
          /** @description The non-unique UI name for the channel */
          display_name?: string;
          /** @description A short description of the purpose of the channel */
          purpose?: string;
          /** @description Markdown-formatted text to display in the header of the channel */
          header?: string;
        };
      };
    };
    responses: {
      /** @description Channel patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update channel's privacy 
   * @description Updates channel's privacy allowing changing a channel from Public to Private and back.
   * 
   * __Minimum server version__: 5.16
   * 
   * ##### Permissions
   * `manage_team` permission for the channels team on version < 5.28. `convert_public_channel_to_private` permission for the channel if updating privacy to 'P' on version >= 5.28. `convert_private_channel_to_public` permission for the channel if updating privacy to 'O' on version >= 5.28.
   */
  UpdateChannelPrivacy: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Channel privacy setting: 'O' for a public channel, 'P' for a private channel */
          privacy: string;
        };
      };
    };
    responses: {
      /** @description Channel conversion successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Restore a channel 
   * @description Restore channel from the provided channel id string.
   * 
   * __Minimum server version__: 3.10
   * 
   * ##### Permissions
   * `manage_team` permission for the team of the channel.
   */
  RestoreChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel restore successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Move a channel 
   * @description Move a channel to another team.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission.
   */
  MoveChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          team_id: string;
          /** @description Remove members those are not member of target team before moving the channel. */
          force?: boolean;
        };
      };
    };
    responses: {
      /** @description Channel move successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get channel statistics 
   * @description Get statistics for a channel.
   * ##### Permissions
   * Must have the `read_channel` permission.
   */
  GetChannelStats: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel statistics retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelStats"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a channel's pinned posts 
   * @description Get a list of pinned posts for channel.
   */
  GetPinnedPosts: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description The list of channel pinned posts */
      200: {
        content: {
          "application/json": components["schemas"]["PostList"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get public channels 
   * @description Get a page of public channels on a team based on query string parameters - page and per_page.
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  GetPublicChannelsForTeam: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of public channels per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get private channels 
   * @description Get a page of private channels on a team based on query string
   * parameters - team_id, page and per_page.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetPrivateChannelsForTeam: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of private channels per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get deleted channels 
   * @description Get a page of deleted channels on a team based on query string parameters - team_id, page and per_page.
   * 
   * __Minimum server version__: 3.10
   */
  GetDeletedChannelsForTeam: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of public channels per page. */
        per_page?: number;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Autocomplete channels 
   * @description Autocomplete public channels on a team based on the search term provided in the request URL.
   * 
   * __Minimum server version__: 4.7
   * 
   * ##### Permissions
   * Must have the `list_team_channels` permission.
   */
  AutocompleteChannelsForTeam: {
    parameters: {
      query: {
        /** @description Name or display name */
        name: string;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels autocomplete successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Autocomplete channels for search 
   * @description Autocomplete your channels on a team based on the search term provided in the request URL.
   * 
   * __Minimum server version__: 5.4
   * 
   * ##### Permissions
   * Must have the `list_team_channels` permission.
   */
  AutocompleteChannelsForTeamForSearch: {
    parameters: {
      query: {
        /** @description Name or display name */
        name: string;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels autocomplete successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Search channels 
   * @description Search public channels on a team based on the search term provided in the request body.
   * ##### Permissions
   * Must have the `list_team_channels` permission.
   * 
   * In server version 5.16 and later, a user without the `list_team_channels` permission will be able to use this endpoint, with the search results limited to the channels that the user is a member of.
   */
  SearchChannels: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the name or display name of channels */
          term: string;
        };
      };
    };
    responses: {
      /** @description Channels search successful */
      201: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Search archived channels 
   * @description Search archived channels on a team based on the search term provided in the request body.
   * 
   * __Minimum server version__: 5.18
   * 
   * ##### Permissions
   * Must have the `list_team_channels` permission.
   * 
   * In server version 5.18 and later, a user without the `list_team_channels` permission will be able to use this endpoint, with the search results limited to the channels that the user is a member of.
   */
  SearchArchivedChannels: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the name or display name of archived channels */
          term: string;
        };
      };
    };
    responses: {
      /** @description Channels search successful */
      201: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a channel by name 
   * @description Gets channel from the provided team id and channel name strings.
   * ##### Permissions
   * `read_channel` permission for the channel.
   */
  GetChannelByName: {
    parameters: {
      query: {
        /** @description Defines if deleted channels should be returned or not (Mattermost Server 5.26.0+) */
        include_deleted?: boolean;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description Channel Name */
        channel_name: string;
      };
    };
    responses: {
      /** @description Channel retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a channel by name and team name 
   * @description Gets a channel from the provided team name and channel name strings.
   * ##### Permissions
   * `read_channel` permission for the channel.
   */
  GetChannelByNameForTeamName: {
    parameters: {
      query: {
        /** @description Defines if deleted channels should be returned or not (Mattermost Server 5.26.0+) */
        include_deleted?: boolean;
      };
      path: {
        /** @description Team Name */
        team_name: string;
        /** @description Channel Name */
        channel_name: string;
      };
    };
    responses: {
      /** @description Channel retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get channel members 
   * @description Get a page of members for a channel.
   * ##### Permissions
   * `read_channel` permission for the channel.
   */
  GetChannelMembers: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of members per page. There is a maximum limit of 200 members. */
        per_page?: number;
      };
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel members retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Add user to channel 
   * @description Add a user to a channel by creating a channel member object.
   */
  AddChannelMember: {
    parameters: {
      path: {
        /** @description The channel ID */
        channel_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of user to add into the channel */
          user_id: string;
          /** @description The ID of root post where link to add channel member originates */
          post_root_id?: string;
        };
      };
    };
    responses: {
      /** @description Channel member creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["ChannelMember"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get channel members by ids 
   * @description Get a list of channel members based on the provided user ids.
   * ##### Permissions
   * Must have the `read_channel` permission.
   */
  GetChannelMembersByIds: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    /** @description List of user ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Channel member list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get channel member 
   * @description Get a channel member.
   * ##### Permissions
   * `read_channel` permission for the channel.
   */
  GetChannelMember: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Channel member retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelMember"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Remove user from channel 
   * @description Delete a channel member, effectively removing them from a channel.
   * 
   * In server version 5.3 and later, channel members can only be deleted from public or private channels.
   * ##### Permissions
   * `manage_public_channel_members` permission if the channel is public.
   * `manage_private_channel_members` permission if the channel is private.
   */
  RemoveUserFromChannel: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Channel member deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update channel roles 
   * @description Update a user's roles for a channel.
   * ##### Permissions
   * Must have `manage_channel_roles` permission for the channel.
   */
  UpdateChannelRoles: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Space-delimited channel roles to assign to the user */
    requestBody: {
      content: {
        "application/json": {
          roles: string;
        };
      };
    };
    responses: {
      /** @description Channel roles update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update the scheme-derived roles of a channel member. 
   * @description Update a channel member's scheme_admin/scheme_user properties. Typically this should either be `scheme_admin=false, scheme_user=true` for ordinary channel member, or `scheme_admin=true, scheme_user=true` for a channel admin.
   * __Minimum server version__: 5.0
   * ##### Permissions
   * Must be authenticated and have the `manage_channel_roles` permission.
   */
  UpdateChannelMemberSchemeRoles: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description Scheme properties. */
    requestBody: {
      content: {
        "application/json": {
          scheme_admin: boolean;
          scheme_user: boolean;
        };
      };
    };
    responses: {
      /** @description Channel member's scheme-derived roles updated successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update channel notifications 
   * @description Update a user's notification properties for a channel. Only the provided fields are updated.
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission.
   */
  UpdateChannelNotifyProps: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChannelNotifyProps"];
      };
    };
    responses: {
      /** @description Channel notification properties update successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * View channel 
   * @description Perform all the actions involved in viewing a channel. This includes marking channels as read, clearing push notifications, and updating the active channel.
   * ##### Permissions
   * Must be logged in as user or have `edit_other_users` permission.
   * 
   * __Response only includes `last_viewed_at_times` in Mattermost server 4.3 and newer.__
   */
  ViewChannel: {
    parameters: {
      path: {
        /** @description User ID to perform the view action for */
        user_id: string;
      };
    };
    /** @description Paremeters affecting how and which channels to view */
    requestBody: {
      content: {
        "application/json": {
          /** @description The channel ID that is being viewed. Use a blank string to indicate that all channels have lost focus. */
          channel_id: string;
          /** @description The channel ID of the previous channel, used when switching channels. Providing this ID will cause push notifications to clear on the channel being switched to. */
          prev_channel_id?: string;
        };
      };
    };
    responses: {
      /** @description Channel view successful */
      200: {
        content: {
          "application/json": {
            /** @description Value should be "OK" if successful */
            status?: string;
            /** @description A JSON object mapping channel IDs to the channel view times */
            last_viewed_at_times?: Record<string, never>;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get channel memberships and roles for a user 
   * @description Get all channel memberships and associated membership roles (i.e. `channel_user`, `channel_admin`) for a user on a specific team.
   * ##### Permissions
   * Logged in as the user and `view_team` permission for the team. Having `manage_system` permission voids the previous requirements.
   */
  GetChannelMembersForUser: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channel members retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelMember"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get channels for user 
   * @description Get all the channels on a team for a user.
   * ##### Permissions
   * Logged in as the user, or have `edit_other_users` permission, and `view_team` permission for the team.
   */
  GetChannelsForTeamForUser: {
    parameters: {
      query: {
        /** @description Defines if deleted channels should be returned or not */
        include_deleted?: boolean;
        /** @description Filters the deleted channels by this time in epoch format. Does not have any effect if include_deleted is set to false. */
        last_delete_at?: number;
      };
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Channels retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get all channels from all teams 
   * @description Get all channels from all teams that a user is a member of.
   * 
   * __Minimum server version__: 6.1
   * 
   * ##### Permissions
   * 
   * Logged in as the user, or have `edit_other_users` permission.
   */
  GetChannelsForUser: {
    parameters: {
      query: {
        /** @description Filters the deleted channels by this time in epoch format. Does not have any effect if include_deleted is set to false. */
        last_delete_at?: number;
        /** @description Defines if deleted channels should be returned or not */
        include_deleted?: boolean;
      };
      path: {
        /** @description The ID of the user. This can also be "me" which will point to the current user. */
        user_id: string;
      };
    };
    responses: {
      /** @description Channels retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get unread messages 
   * @description Get the total unread messages and mentions for a channel for a user.
   * ##### Permissions
   * Must be logged in as user and have the `read_channel` permission, or have `edit_other_usrs` permission.
   */
  GetChannelUnread: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel unreads retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelUnread"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Set a channel's scheme 
   * @description Set a channel's scheme, more specifically sets the scheme_id value of a channel record.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.10
   */
  UpdateChannelScheme: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    /** @description Scheme GUID */
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the scheme. */
          scheme_id: string;
        };
      };
    };
    responses: {
      /** @description Update channel scheme successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Channel members minus group members. 
   * @description Get the set of users who are members of the channel minus the set of users who are members of the given groups.
   * Each user object contains an array of group objects representing the group memberships for that user.
   * Each user object contains the boolean fields `scheme_guest`, `scheme_user`, and `scheme_admin` representing the roles that user has for the given channel.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.14
   */
  ChannelMembersMinusGroupMembers: {
    parameters: {
      query: {
        /** @description A comma-separated list of group ids. */
        group_ids: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. */
        per_page?: number;
      };
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Successfully returns users specified by the pagination, and the total_count. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Channel members counts for each group that has atleast one member in the channel 
   * @description Returns a set of ChannelMemberCountByGroup objects which contain a `group_id`, `channel_member_count` and a `channel_member_timezones_count`.
   * ##### Permissions
   * Must have `read_channel` permission for the given channel.
   * __Minimum server version__: 5.24
   */
  GetChannelMemberCountsByGroup: {
    parameters: {
      query: {
        /** @description Defines if member timezone counts should be returned or not */
        include_timezones?: boolean;
      };
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Successfully returns member counts by group for the given channel. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get information about channel's moderation. 
   * @description ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.22
   */
  GetChannelModerations: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Retreived successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelModeration"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update a channel's moderation settings. 
   * @description ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.22
   */
  PatchChannelModerations: {
    parameters: {
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChannelModerationPatch"];
      };
    };
    responses: {
      /** @description Patched successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["ChannelModeration"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get user's sidebar categories 
   * @description Get a list of sidebar categories that will appear in the user's sidebar on the given team, including a list of channel IDs in each category.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  GetSidebarCategoriesForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Category retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["OrderedSidebarCategories"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update user's sidebar categories 
   * @description Update any number of sidebar categories for the user on the given team. This can be used to reorder the channels in these categories.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  UpdateSidebarCategoriesForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (components["schemas"]["SidebarCategory"])[];
      };
    };
    responses: {
      /** @description Category update successful */
      200: {
        content: {
          "application/json": components["schemas"]["SidebarCategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create user's sidebar category 
   * @description Create a custom sidebar category for the user on the given team.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  CreateSidebarCategoryForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SidebarCategory"];
      };
    };
    responses: {
      /** @description Category creation successful */
      200: {
        content: {
          "application/json": components["schemas"]["SidebarCategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get user's sidebar category order 
   * @description Returns the order of the sidebar categories for a user on the given team as an array of IDs.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  GetSidebarCategoryOrderForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Order retrieval successful */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update user's sidebar category order 
   * @description Updates the order of the sidebar categories for a user on the given team. The provided array must include the IDs of all categories on the team.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  UpdateSidebarCategoryOrderForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Order update successful */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get sidebar category 
   * @description Returns a single sidebar category for the user on the given team.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  GetSidebarCategoryForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
        /** @description Category GUID */
        category_id: string;
      };
    };
    responses: {
      /** @description Category retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["SidebarCategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update sidebar category 
   * @description Updates a single sidebar category for the user on the given team.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  UpdateSidebarCategoryForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
        /** @description Category GUID */
        category_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SidebarCategory"];
      };
    };
    responses: {
      /** @description Category update successful */
      200: {
        content: {
          "application/json": components["schemas"]["SidebarCategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete sidebar category 
   * @description Deletes a single sidebar category for the user on the given team. Only custom categories can be deleted.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be authenticated and have the `list_team_channels` permission.
   */
  RemoveSidebarCategoryForTeamForUser: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
        /** @description User GUID */
        user_id: string;
        /** @description Category GUID */
        category_id: string;
      };
    };
    responses: {
      /** @description Category delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["SidebarCategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create a post 
   * @description Create a new post in a channel. To create the post as a comment on another post, provide `root_id`.
   * ##### Permissions
   * Must have `create_post` permission for the channel the post is being created in.
   */
  CreatePost: {
    parameters: {
      query: {
        /** @description Whether to set the user status as online or not. */
        set_online?: boolean;
      };
    };
    /** @description Post object to create */
    requestBody: {
      content: {
        "application/json": {
          /** @description The channel ID to post in */
          channel_id: string;
          /** @description The message contents, can be formatted with Markdown */
          message: string;
          /** @description The post ID to comment on */
          root_id?: string;
          /** @description A list of file IDs to associate with the post. Note that posts are limited to 5 files maximum. Please use additional posts for more files. */
          file_ids?: (string)[];
          /** @description A general JSON property bag to attach to the post */
          props?: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description Post creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Post"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a ephemeral post 
   * @description Create a new ephemeral post in a channel.
   * ##### Permissions
   * Must have `create_post_ephemeral` permission (currently only given to system admin)
   */
  CreatePostEphemeral: {
    /** @description Ephemeral Post object to send */
    requestBody: {
      content: {
        "application/json": {
          /** @description The target user id for the ephemeral post */
          user_id: string;
          /** @description Post object to create */
          post: {
            /** @description The channel ID to post in */
            channel_id: string;
            /** @description The message contents, can be formatted with Markdown */
            message: string;
          };
        };
      };
    };
    responses: {
      /** @description Post creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Post"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a post 
   * @description Get a single post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
   */
  GetPost: {
    parameters: {
      query: {
        /** @description Defines if result should include deleted posts, must have 'manage_system' (admin) permission. */
        include_deleted?: boolean;
      };
      path: {
        /** @description ID of the post to get */
        post_id: string;
      };
    };
    responses: {
      /** @description Post retrieval successful */
      200: {
        headers: {
          /** @description This header is included with the value "true" if the post is past the cloud's plan limit. */
          "Has-Inaccessible-Posts"?: boolean;
        };
        content: {
          "application/json": components["schemas"]["Post"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update a post 
   * @description Update a post. Only the fields listed below are updatable, omitted fields will be treated as blank.
   * ##### Permissions
   * Must have `edit_post` permission for the channel the post is in.
   */
  UpdatePost: {
    parameters: {
      path: {
        /** @description ID of the post to update */
        post_id: string;
      };
    };
    /** @description Post object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description ID of the post to update */
          id: string;
          /** @description Set to `true` to pin the post to the channel it is in */
          is_pinned?: boolean;
          /** @description The message text of the post */
          message?: string;
          /** @description Set to `true` if the post has reactions to it */
          has_reactions?: boolean;
          /** @description A general JSON property bag to attach to the post */
          props?: string;
        };
      };
    };
    responses: {
      /** @description Post update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Post"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Delete a post 
   * @description Soft deletes a post, by marking the post as deleted in the database. Soft deleted posts will not be returned in post queries.
   * ##### Permissions
   * Must be logged in as the user or have `delete_others_posts` permission.
   */
  DeletePost: {
    parameters: {
      path: {
        /** @description ID of the post to delete */
        post_id: string;
      };
    };
    responses: {
      /** @description Post deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Mark as unread from a post. 
   * @description Mark a channel as being unread from a given post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
   * Must have `edit_other_users` permission if the user is not the one marking the post for himself.
   * 
   * __Minimum server version__: 5.18
   */
  SetPostUnread: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Post GUID */
        post_id: string;
      };
    };
    responses: {
      /** @description Post marked as unread successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelUnreadAt"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Patch a post 
   * @description Partially update a post by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * Must have the `edit_post` permission.
   */
  PatchPost: {
    parameters: {
      path: {
        /** @description Post GUID */
        post_id: string;
      };
    };
    /** @description Post object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description Set to `true` to pin the post to the channel it is in */
          is_pinned?: boolean;
          /** @description The message text of the post */
          message?: string;
          /** @description The list of files attached to this post */
          file_ids?: (string)[];
          /** @description Set to `true` if the post has reactions to it */
          has_reactions?: boolean;
          /** @description A general JSON property bag to attach to the post */
          props?: string;
        };
      };
    };
    responses: {
      /** @description Post patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Post"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a thread 
   * @description Get a post and the rest of the posts in the same thread.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
   */
  GetPostThread: {
    parameters: {
      query: {
        /** @description The number of posts per page */
        perPage?: number;
        /** @description The post_id to return the next page of posts from */
        fromPost?: string;
        /** @description The create_at timestamp to return the next page of posts from */
        fromCreateAt?: number;
        /** @description The direction to return the posts. Either up or down. */
        direction?: string;
        /** @description Whether to skip fetching threads or not */
        skipFetchThreads?: boolean;
        /** @description Whether the client uses CRT or not */
        collapsedThreads?: boolean;
        /** @description Whether to return the associated users as part of the response or not */
        collapsedThreadsExtended?: boolean;
      };
      path: {
        /** @description ID of a post in the thread */
        post_id: string;
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["PostList"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of flagged posts 
   * @description Get a page of flagged posts of a user provided user id string. Selects from a channel, team, or all flagged posts by a user. Will only return posts from channels in which the user is member.
   * ##### Permissions
   * Must be user or have `manage_system` permission.
   */
  GetFlaggedPostsForUser: {
    parameters: {
      query: {
        /** @description Team ID */
        team_id?: string;
        /** @description Channel ID */
        channel_id?: string;
        /** @description The page to select */
        page?: number;
        /** @description The number of posts per page */
        per_page?: number;
      };
      path: {
        /** @description ID of the user */
        user_id: string;
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["PostList"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get file info for post 
   * @description Gets a list of file information objects for the files attached to a post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in.
   */
  GetFileInfosForPost: {
    parameters: {
      query: {
        /** @description Defines if result should include deleted posts, must have 'manage_system' (admin) permission. */
        include_deleted?: boolean;
      };
      path: {
        /** @description ID of the post */
        post_id: string;
      };
    };
    responses: {
      /** @description File info retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["FileInfo"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get posts for a channel 
   * @description Get a page of posts in a channel. Use the query parameters to modify the behaviour of this endpoint. The parameter `since` must not be used with any of `before`, `after`, `page`, and `per_page` parameters.
   * If `since` is used, it will always return all posts modified since that time, ordered by their create time limited till 1000. A caveat with this parameter is that there is no guarantee that the returned posts will be consecutive. It is left to the clients to maintain state and fill any missing holes in the post order.
   * ##### Permissions
   * Must have `read_channel` permission for the channel.
   */
  GetPostsForChannel: {
    parameters: {
      query: {
        /** @description The page to select */
        page?: number;
        /** @description The number of posts per page */
        per_page?: number;
        /** @description Provide a non-zero value in Unix time milliseconds to select posts modified after that time */
        since?: number;
        /** @description A post id to select the posts that came before this one */
        before?: string;
        /** @description A post id to select the posts that came after this one */
        after?: string;
        /** @description Whether to include deleted posts or not. Must have system admin permissions. */
        include_deleted?: boolean;
      };
      path: {
        /** @description The channel ID to get the posts for */
        channel_id: string;
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["PostList"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get posts around oldest unread 
   * @description Get the oldest unread post in the channel for the given user as well as the posts around it. The returned list is sorted in descending order (most recent post first).
   * ##### Permissions
   * Must be logged in as the user or have `edit_other_users` permission, and must have `read_channel` permission for the channel.
   * __Minimum server version__: 5.14
   */
  GetPostsAroundLastUnread: {
    parameters: {
      query: {
        /** @description Number of posts before the oldest unread posts. Maximum is 200 posts if limit is set greater than that. */
        limit_before?: number;
        /** @description Number of posts after and including the oldest unread post. Maximum is 200 posts if limit is set greater than that. */
        limit_after?: number;
        /** @description Whether to skip fetching threads or not */
        skipFetchThreads?: boolean;
        /** @description Whether the client uses CRT or not */
        collapsedThreads?: boolean;
        /** @description Whether to return the associated users as part of the response or not */
        collapsedThreadsExtended?: boolean;
      };
      path: {
        /** @description ID of the user */
        user_id: string;
        /** @description The channel ID to get the posts for */
        channel_id: string;
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["PostList"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Search for team posts 
   * @description Search posts in the team and from the provided terms string.
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  SearchPosts: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description The search terms and logic to use in the search. */
    requestBody: {
      content: {
        "application/json": {
          /** @description The search terms as inputed by the user. To search for posts from a user include `from:someusername`, using a user's username. To search in a specific channel include `in:somechannel`, using the channel name (not the display name). */
          terms: string;
          /** @description Set to true if an Or search should be performed vs an And search. */
          is_or_search: boolean;
          /**
           * @description Offset from UTC of user timezone for date searches. 
           * @default 0
           */
          time_zone_offset?: number;
          /** @description Set to true if deleted channels should be included in the search. (archived channels) */
          include_deleted_channels?: boolean;
          /**
           * @description The page to select. (Only works with Elasticsearch) 
           * @default 0
           */
          page?: number;
          /**
           * @description The number of posts per page. (Only works with Elasticsearch) 
           * @default 60
           */
          per_page?: number;
        };
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["PostListWithSearchMatches"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Pin a post to the channel 
   * @description Pin a post to a channel it is in based from the provided post id string.
   * ##### Permissions
   * Must be authenticated and have the `read_channel` permission to the channel the post is in.
   */
  PinPost: {
    parameters: {
      path: {
        /** @description Post GUID */
        post_id: string;
      };
    };
    responses: {
      /** @description Pinned post successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Unpin a post to the channel 
   * @description Unpin a post to a channel it is in based from the provided post id string.
   * ##### Permissions
   * Must be authenticated and have the `read_channel` permission to the channel the post is in.
   */
  UnpinPost: {
    parameters: {
      path: {
        /** @description Post GUID */
        post_id: string;
      };
    };
    responses: {
      /** @description Unpinned post successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Perform a post action 
   * @description Perform a post action, which allows users to interact with integrations through posts.
   * ##### Permissions
   * Must be authenticated and have the `read_channel` permission to the channel the post is in.
   */
  DoPostAction: {
    parameters: {
      path: {
        /** @description Post GUID */
        post_id: string;
        /** @description Action GUID */
        action_id: string;
      };
    };
    responses: {
      /** @description Post action successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get posts by a list of ids 
   * @description Fetch a list of posts based on the provided postIDs
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in or if the channel is public, have the `read_public_channels` permission for the team.
   */
  getPostsByIds: {
    /** @description List of post ids */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Post list retrieval successful */
      200: {
        headers: {
          /** @description Indicates whether the posts have been truncated as per the cloud's plan limit. */
          "Has-Inaccessible-Posts"?: boolean;
        };
        content: {
          "application/json": (components["schemas"]["Post"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Set a post reminder 
   * @description Set a reminder for the user for the post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in.
   * 
   * __Minimum server version__: 7.2
   */
  SetPostReminder: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description Post GUID */
        post_id: string;
      };
    };
    /** @description Target time for the reminder */
    requestBody: {
      content: {
        "application/json": {
          /** @description Target time for the reminder */
          target_time: number;
        };
      };
    };
    responses: {
      /** @description Reminder set successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get the user's preferences 
   * @description Get a list of the user's preferences.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  GetPreferences: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description User preferences retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Preference"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Save the user's preferences 
   * @description Save a list of the user's preferences.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  UpdatePreferences: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description List of preference objects */
    requestBody: {
      content: {
        "application/json": (components["schemas"]["Preference"])[];
      };
    };
    responses: {
      /** @description User preferences saved successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete user's preferences 
   * @description Delete a list of the user's preferences.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  DeletePreferences: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    /** @description List of preference objects */
    requestBody: {
      content: {
        "application/json": (components["schemas"]["Preference"])[];
      };
    };
    responses: {
      /** @description User preferences saved successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * List a user's preferences by category 
   * @description Lists the current user's stored preferences in the given category.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  GetPreferencesByCategory: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description The category of a group of preferences */
        category: string;
      };
    };
    responses: {
      /** @description A list of all of the current user's preferences in the given category */
      200: {
        content: {
          "application/json": (components["schemas"]["Preference"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a specific user preference 
   * @description Gets a single preference for the current user with the given category and name.
   * ##### Permissions
   * Must be logged in as the user being updated or have the `edit_other_users` permission.
   */
  GetPreferencesByCategoryByName: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
        /** @description The category of a group of preferences */
        category: string;
        /** @description The name of the preference */
        preference_name: string;
      };
    };
    responses: {
      /** @description A single preference for the current user in the current categorylist of all of the current user's preferences in the given category. */
      200: {
        content: {
          "application/json": components["schemas"]["Preference"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Upload a file 
   * @description Uploads a file that can later be attached to a post.
   * 
   * This request can either be a multipart/form-data request with a channel_id, files and optional
   * client_ids defined in the FormData, or it can be a request with the channel_id and filename
   * defined as query parameters with the contents of a single file in the body of the request.
   * 
   * Only multipart/form-data requests are supported by server versions up to and including 4.7.
   * Server versions 4.8 and higher support both types of requests.
   * 
   * ##### Permissions
   * Must have `upload_file` permission.
   */
  UploadFile: {
    parameters: {
      query: {
        /** @description The ID of the channel that this file will be uploaded to */
        channel_id?: string;
        /** @description The name of the file to be uploaded */
        filename?: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description A file to be uploaded
           */
          files?: string;
          /** @description The ID of the channel that this file will be uploaded to */
          channel_id?: string;
          /** @description A unique identifier for the file that will be returned in the response */
          client_ids?: string;
        };
      };
    };
    responses: {
      /** @description Corresponding lists of the provided client_ids and the metadata that has been stored in the database for each one */
      201: {
        content: {
          "application/json": {
            /** @description A list of file metadata that has been stored in the database */
            file_infos?: (components["schemas"]["FileInfo"])[];
            /** @description A list of the client_ids that were provided in the request */
            client_ids?: (string)[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a file 
   * @description Gets a file that has been uploaded previously.
   * ##### Permissions
   * Must have `read_channel` permission or be uploader of the file.
   */
  GetFile: {
    parameters: {
      path: {
        /** @description The ID of the file to get */
        file_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a file's thumbnail 
   * @description Gets a file's thumbnail.
   * ##### Permissions
   * Must have `read_channel` permission or be uploader of the file.
   */
  GetFileThumbnail: {
    parameters: {
      path: {
        /** @description The ID of the file to get */
        file_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a file's preview 
   * @description Gets a file's preview.
   * ##### Permissions
   * Must have `read_channel` permission or be uploader of the file.
   */
  GetFilePreview: {
    parameters: {
      path: {
        /** @description The ID of the file to get */
        file_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a public file link 
   * @description Gets a public link for a file that can be accessed without logging into Mattermost.
   * ##### Permissions
   * Must have `read_channel` permission or be uploader of the file.
   */
  GetFileLink: {
    parameters: {
      path: {
        /** @description The ID of the file to get a link for */
        file_id: string;
      };
    };
    responses: {
      /** @description A publicly accessible link to the given file */
      200: {
        content: {
          "application/json": {
            link?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get metadata for a file 
   * @description Gets a file's info.
   * ##### Permissions
   * Must have `read_channel` permission or be uploader of the file.
   */
  GetFileInfo: {
    parameters: {
      path: {
        /** @description The ID of the file info to get */
        file_id: string;
      };
    };
    responses: {
      /** @description The stored metadata for the given file */
      200: {
        content: {
          "application/json": components["schemas"]["FileInfo"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a public file 
   * @description ##### Permissions
   * No permissions required.
   */
  GetFilePublic: {
    parameters: {
      query: {
        /** @description File hash */
        h: string;
      };
      path: {
        /** @description The ID of the file to get */
        file_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description Do not have appropriate permissions */
      403: {
        headers: {
          /** @description This header is included with the value "1" if the file is past the cloud's plan limit. */
          "First-Inaccessible-File-Time"?: number;
        };
        content: {
          "application/json": components["schemas"]["AppError"];
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Search files in a team 
   * @description Search for files in a team based on file name, extention and file content (if file content extraction is enabled and supported for the files).
   * __Minimum server version__: 5.34
   * ##### Permissions
   * Must be authenticated and have the `view_team` permission.
   */
  SearchFiles: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description The search terms and logic to use in the search. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /** @description The search terms as inputed by the user. To search for files from a user include `from:someusername`, using a user's username. To search in a specific channel include `in:somechannel`, using the channel name (not the display name). To search for specific extensions included `ext:extension`. */
          terms: string;
          /** @description Set to true if an Or search should be performed vs an And search. */
          is_or_search: boolean;
          /**
           * @description Offset from UTC of user timezone for date searches. 
           * @default 0
           */
          time_zone_offset?: number;
          /** @description Set to true if deleted channels should be included in the search. (archived channels) */
          include_deleted_channels?: boolean;
          /**
           * @description The page to select. (Only works with Elasticsearch) 
           * @default 0
           */
          page?: number;
          /**
           * @description The number of posts per page. (Only works with Elasticsearch) 
           * @default 60
           */
          per_page?: number;
        };
      };
    };
    responses: {
      /** @description Files list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["FileInfoList"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create an upload 
   * @description Creates a new upload session.
   * 
   * __Minimum server version__: 5.28
   * ##### Permissions
   * Must have `upload_file` permission.
   */
  CreateUpload: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the channel to upload to. */
          channel_id: string;
          /** @description The name of the file to upload. */
          filename: string;
          /**
           * Format: int64 
           * @description The size of the file to upload in bytes.
           */
          file_size: number;
        };
      };
    };
    responses: {
      /** @description Upload creation successful. */
      201: {
        content: {
          "application/json": components["schemas"]["UploadSession"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get an upload session 
   * @description Gets an upload session that has been previously created.
   * 
   * ##### Permissions
   * Must be logged in as the user who created the upload session.
   */
  GetUpload: {
    parameters: {
      path: {
        /** @description The ID of the upload session to get. */
        upload_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Perform a file upload 
   * @description Starts or resumes a file upload.  
   * To resume an existing (incomplete) upload, data should be sent starting from the offset specified in the upload session object.
   * 
   * The request body can be in one of two formats:
   * - Binary file content streamed in request's body
   * - multipart/form-data
   * 
   * ##### Permissions
   * Must be logged in as the user who created the upload session.
   */
  UploadData: {
    parameters: {
      path: {
        /** @description The ID of the upload session the data belongs to. */
        upload_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": Record<string, never>;
      };
    };
    responses: {
      /** @description Upload successful */
      201: {
        content: {
          "application/json": components["schemas"]["FileInfo"];
        };
      };
      /** @description Upload incomplete */
      204: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the jobs. 
   * @description Get a page of jobs. Use the query parameters to modify the behaviour of this endpoint.
   * __Minimum server version: 4.1__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  GetJobs: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of jobs per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Job list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Job"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a new job. 
   * @description Create a new job.
   * __Minimum server version: 4.1__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  CreateJob: {
    /** @description Job object to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description The type of job to create */
          type: string;
          /** @description An object containing any additional data required for this job type */
          data?: Record<string, never>;
        };
      };
    };
    responses: {
      /** @description Job creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Job"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a job. 
   * @description Gets a single job.
   * __Minimum server version: 4.1__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  GetJob: {
    parameters: {
      path: {
        /** @description Job GUID */
        job_id: string;
      };
    };
    responses: {
      /** @description Job retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Job"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Download the results of a job. 
   * @description Download the result of a single job.
   * __Minimum server version: 5.28__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  DownloadJob: {
    parameters: {
      path: {
        /** @description Job GUID */
        job_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Cancel a job. 
   * @description Cancel a job.
   * __Minimum server version: 4.1__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  CancelJob: {
    parameters: {
      path: {
        /** @description Job GUID */
        job_id: string;
      };
    };
    responses: {
      /** @description Job canceled successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get the jobs of the given type. 
   * @description Get a page of jobs of the given type. Use the query parameters to modify the behaviour of this endpoint.
   * __Minimum server version: 4.1__
   * ##### Permissions
   * Must have `manage_jobs` permission.
   */
  GetJobsByType: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of jobs per page. */
        per_page?: number;
      };
      path: {
        /** @description Job type */
        type: string;
      };
    };
    responses: {
      /** @description Job list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Job"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Retrieve a list of supported timezones 
   * @description __Minimum server version__: 3.10
   * ##### Permissions
   * Must be logged in.
   */
  GetSupportedTimezone: {
    responses: {
      /** @description List of timezones retrieval successful */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Check system health 
   * @description Check if the server is up and healthy based on the configuration setting `GoRoutineHealthThreshold`. If `GoRoutineHealthThreshold` and the number of goroutines on the server exceeds that threshold the server is considered unhealthy. If `GoRoutineHealthThreshold` is not set or the number of goroutines is below the threshold the server is considered healthy.
   * __Minimum server version__: 3.10
   * If a "device_id" is passed in the query, it will test the Push Notification Proxy in order to discover whether the device is able to receive notifications. The response will have a "CanReceiveNotifications" property with one of the following values: - true: It can receive notifications - false: It cannot receive notifications - unknown: There has been an unknown error, and it is not certain whether it can
   *   receive notifications.
   * 
   * __Minimum server version__: 6.5
   * ##### Permissions
   * None.
   */
  GetPing: {
    parameters: {
      query: {
        /** @description Check the status of the database and file storage as well */
        get_server_status?: boolean;
        /** @description Check whether this device id can receive push notifications */
        device_id?: string;
      };
    };
    responses: {
      /** @description Status of the system */
      200: {
        content: {
          "application/json": components["schemas"]["SystemStatusResponse"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get notices for logged in user in specified team 
   * @description Will return appropriate product notices for current user in the team specified by teamId parameter.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be logged in.
   */
  GetNotices: {
    parameters: {
      query: {
        /** @description Version of the client (desktop/mobile/web) that issues the request */
        clientVersion: string;
        /** @description Client locale */
        locale?: string;
        /** @description Client type (web/mobile-ios/mobile-android/desktop) */
        client: string;
      };
      path: {
        /** @description ID of the team */
        teamId: string;
      };
    };
    responses: {
      /** @description List notices retrieve successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Notice"])[];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Update notices as 'viewed' 
   * @description Will mark the specified notices as 'viewed' by the logged in user.
   * __Minimum server version__: 5.26
   * ##### Permissions
   * Must be logged in.
   */
  MarkNoticesViewed: {
    /** @description Array of notice IDs */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Update successfull */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Recycle database connections 
   * @description Recycle database connections by closing and reconnecting all connections to master and read replica databases.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  DatabaseRecycle: {
    responses: {
      /** @description Database recycle successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Send a test email 
   * @description Send a test email to make sure you have your email settings configured correctly. Optionally provide a configuration in the request body to test. If no valid configuration is present in the request body the current server configuration will be tested.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  TestEmail: {
    /** @description Mattermost configuration */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Config"];
      };
    };
    responses: {
      /** @description Email successful sent */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Checks the validity of a Site URL 
   * @description Sends a Ping request to the mattermost server using the specified Site URL.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.16
   */
  TestSiteURL: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The Site URL to test */
          site_url: string;
        };
      };
    };
    responses: {
      /** @description Site URL is valid */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Test AWS S3 connection 
   * @description Send a test to validate if can connect to AWS S3. Optionally provide a configuration in the request body to test. If no valid configuration is present in the request body the current server configuration will be tested.
   * ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 4.8
   */
  TestS3Connection: {
    /** @description Mattermost configuration */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Config"];
      };
    };
    responses: {
      /** @description S3 Test successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get configuration 
   * @description Retrieve the current server configuration
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetConfig: {
    responses: {
      /** @description Configuration retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Config"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Update configuration 
   * @description Submit a new configuration for the server to use. As of server version 4.8, the `PluginSettings.EnableUploads` setting cannot be modified by this endpoint.
   * Note that the parameters that aren't set in the configuration that you provide will be reset to default values. Therefore, if you want to change a configuration parameter and leave the other ones unchanged, you need to get the existing configuration first, change the field that you want, then put that new configuration.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UpdateConfig: {
    /** @description Mattermost configuration */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Config"];
      };
    };
    responses: {
      /** @description Configuration update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Config"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Reload configuration 
   * @description Reload the configuration file to pick up on any changes made to it.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  ReloadConfig: {
    responses: {
      /** @description Configuration reload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get client configuration 
   * @description Get a subset of the server configuration needed by the client.
   * ##### Permissions
   * No permission required.
   */
  GetClientConfig: {
    parameters: {
      query: {
        /** @description Must be `old`, other formats not implemented yet */
        format: string;
      };
    };
    responses: {
      /** @description Configuration retrieval successful */
      200: never;
      400: components["responses"]["BadRequest"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get configuration made through environment variables 
   * @description Retrieve a json object mirroring the server configuration where fields are set to true
   * if the corresponding config setting is set through an environment variable. Settings
   * that haven't been set through environment variables will be missing from the object.
   * 
   * __Minimum server version__: 4.10
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetEnvironmentConfig: {
    responses: {
      /** @description Configuration retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["EnvironmentConfig"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Patch configuration 
   * @description Submit configuration to patch. As of server version 4.8, the `PluginSettings.EnableUploads` setting cannot be modified by this endpoint.
   * ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 5.20
   * ##### Note
   * The Plugins are stored as a map, and since a map may recursively go  down to any depth, individual fields of a map are not changed.  Consider using the `update config` (PUT api/v4/config) endpoint to update a plugins configurations.
   */
  PatchConfig: {
    /** @description Mattermost configuration */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Config"];
      };
    };
    responses: {
      /** @description Configuration update successful */
      200: {
        content: {
          "application/json": components["schemas"]["Config"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Upload license file 
   * @description Upload a license to enable enterprise features.
   * 
   * __Minimum server version__: 4.0
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UploadLicenseFile: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The license to be uploaded
           */
          license: string;
        };
      };
    };
    responses: {
      /** @description License file upload successful */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
    };
  };
  /**
   * Remove license file 
   * @description Remove the license file from the server. This will disable all enterprise features.
   * 
   * __Minimum server version__: 4.0
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  RemoveLicenseFile: {
    responses: {
      /** @description License removal successful */
      200: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get client license 
   * @description Get a subset of the server license needed by the client.
   * ##### Permissions
   * No permission required but having the `manage_system` permission returns more information.
   */
  GetClientLicense: {
    parameters: {
      query: {
        /** @description Must be `old`, other formats not implemented yet */
        format: string;
      };
    };
    responses: {
      /** @description License retrieval successful */
      200: never;
      400: components["responses"]["BadRequest"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Request the license renewal link 
   * @description Request the renewal link that would be used to start the license renewal process
   * __Minimum server version__: 5.32
   * ##### Permissions
   * Must have `sysconsole_write_about` permission.
   */
  RequestLicenseRenewalLink: {
    responses: {
      /** @description License renewal link obtained */
      200: {
        content: {
          "application/json": components["schemas"]["LicenseRenewalLink"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Request and install a trial license for your server 
   * @description Request and install a trial license for your server
   * __Minimum server version__: 5.25
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  RequestTrialLicense: {
    /** @description License request */
    requestBody: {
      content: {
        "application/json": {
          /** @description Number of users requested (20% extra is going to be added) */
          users: number;
        };
      };
    };
    responses: {
      /** @description Trial license obtained and installed */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get last trial license used 
   * @description Get the last trial license used on the sevrer
   * __Minimum server version__: 5.36
   * ##### Permissions
   * Must have `manage_systems` permissions.
   */
  GetPrevTrialLicense: {
    responses: {
      /** @description License fetched successfully. */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get audits 
   * @description Get a page of audits for all users on the system, selected with `page` and `per_page` query parameters.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetAudits: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of audits per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Audits retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Audit"])[];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Invalidate all the caches 
   * @description Purge all the in-memory caches for the Mattermost server. This can have a temporary negative effect on performance while the caches are re-populated.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  InvalidateCaches: {
    responses: {
      /** @description Caches invalidate successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get logs 
   * @description Get a page of server logs, selected with `page` and `logs_per_page` query parameters.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetLogs: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of logs per page. There is a maximum limit of 10000 logs per page. */
        logs_per_page?: string;
      };
    };
    responses: {
      /** @description Logs retrieval successful */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Add log message 
   * @description Add log messages to the server logs.
   * ##### Permissions
   * Users with `manage_system` permission can log ERROR or DEBUG messages.
   * Logged in users can log ERROR or DEBUG messages when `ServiceSettings.EnableDeveloper` is `true` or just DEBUG messages when `false`.
   * Non-logged in users can log ERROR or DEBUG messages when `ServiceSettings.EnableDeveloper` is `true` and cannot log when `false`.
   */
  PostLog: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The error level, ERROR or DEBUG */
          level: string;
          /** @description Message to send to the server logs */
          message: string;
        };
      };
    };
    responses: {
      /** @description Logs sent successful */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get analytics 
   * @description Get some analytics data about the system. This endpoint uses the old format, the `/analytics` route is reserved for the new format when it gets implemented.
   * 
   * The returned JSON changes based on the `name` query parameter but is always key/value pairs.
   * 
   * __Minimum server version__: 4.0
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetAnalyticsOld: {
    parameters: {
      query: {
        /** @description Possible values are "standard", "bot_post_counts_day", "post_counts_day", "user_counts_with_posts_day" or "extra_counts" */
        name?: string;
        /** @description The team ID to filter the data by */
        team_id?: string;
      };
    };
    responses: {
      /** @description Analytics retrieval successful */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get server busy expiry time. 
   * @description Gets the timestamp corresponding to when the server busy flag will be automatically cleared.
   * 
   * __Minimum server version__: 5.20
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetServerBusyExpires: {
    responses: {
      /** @description Server busy expires timestamp retrieved successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Server_Busy"];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Set the server busy (high load) flag 
   * @description Marks the server as currently having high load which disables non-critical services such as search, statuses and typing notifications.
   * 
   * __Minimum server version__: 5.20
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  SetServerBusy: {
    parameters: {
      query: {
        /** @description Number of seconds until server is automatically marked as not busy. */
        seconds?: string;
      };
    };
    responses: {
      /** @description Server busy flag set successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Clears the server busy (high load) flag 
   * @description Marks the server as not having high load which re-enables non-critical services such as search, statuses and typing notifications.
   * 
   * __Minimum server version__: 5.20
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  ClearServerBusy: {
    responses: {
      /** @description Server busy flag cleared successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Acknowledge receiving of a notification 
   * @description __Minimum server version__: 3.10
   * ##### Permissions
   * Must be logged in.
   */
  AcknowledgeNotification: {
    responses: {
      /** @description Status of the system */
      200: {
        content: {
          "application/json": components["schemas"]["PushNotification"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get redirect location 
   * @description __Minimum server version__: 3.10
   * ##### Permissions
   * Must be logged in.
   */
  GetRedirectLocation: {
    parameters: {
      query: {
        /** @description Url to check */
        url: string;
      };
    };
    responses: {
      /** @description Got redirect location */
      200: {
        content: {
          "image/*": {
            location?: string;
          };
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get an image by url 
   * @description Fetches an image via Mattermost image proxy.
   * __Minimum server version__: 3.10
   * ##### Permissions
   * Must be logged in.
   */
  GetImageByUrl: {
    responses: {
      /** @description Image found */
      200: {
        content: {
          "image/*": string;
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Executes an inplace upgrade from Team Edition to Enterprise Edition 
   * @description It downloads the Mattermost Enterprise Edition of your current version and replace your current version with it. After the upgrade you need to restart the Mattermost server.
   * __Minimum server version__: 5.27
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UpgradeToEnterprise: {
    responses: {
      /** @description Upgrade started */
      202: {
        content: {
          "application/json": components["schemas"]["PushNotification"];
        };
      };
      403: components["responses"]["Forbidden"];
      429: components["responses"]["TooManyRequests"];
    };
  };
  /**
   * Get the current status for the inplace upgrade from Team Edition to Enterprise Edition 
   * @description It returns the percentage of completion of the current upgrade or the error if there is any.
   * __Minimum server version__: 5.27
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UpgradeToEnterpriseStatus: {
    responses: {
      /** @description Upgrade status */
      200: {
        content: {
          "application/json": {
            /** @description Current percentage of the upgrade */
            percentage?: number;
            /** @description Error happened during the upgrade */
            error?: string;
          };
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Restart the system after an upgrade from Team Edition to Enterprise Edition 
   * @description It restarts the current running mattermost instance to execute the new Enterprise binary.
   * __Minimum server version__: 5.27
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  RestartServer: {
    responses: {
      /** @description Restart started */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get the warn metrics status (enabled or disabled) 
   * @description Get the status of a set of metrics (enabled or disabled) from the Systems table.
   * 
   * The returned JSON contains the metrics that we need to warn the admin on with regard
   * to their status (we return the ones whose status is "true", which means that they are
   * in a "warnable" state - e.g. a threshold has been crossed or some other condition has
   * been fulfilled).
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission.
   */
  GetWarnMetricsStatus: {
    responses: {
      /** @description Warn metrics retrieval was successful. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Acknowledge a warning of a metric status 
   * @description Acknowledge a warning for the warn_metric_id metric crossing a threshold (or some
   * similar condition being fulfilled) - attempts to send an ack email to
   * acknowledge@mattermost.com and sets the "ack" status for all the warn metrics in the system.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission.
   */
  SendWarnMetricAck: {
    parameters: {
      path: {
        /** @description Warn Metric Id. */
        warn_metric_id: string;
      };
    };
    /** @description payload that contains the ack flag */
    requestBody: {
      content: {
        "application/json": {
          /** @description Flag which determines if the ack for the metric warning should be directly stored (without trying to send email first) or not */
          forceAck?: boolean;
        };
      };
    };
    responses: {
      /** @description The acknowledgement of the warning for the metric has been successful. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Request trial license and acknowledge a warning of a metric status 
   * @description Request a trial license and acknowledge a warning for the warn_metric_id metric crossing a threshold (or some
   * similar condition being fulfilled) - sets the "ack" status for all the warn metrics in the system.
   * 
   * __Minimum server version__: 5.28
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission.
   */
  SendTrialLicenseWarnMetricAck: {
    parameters: {
      path: {
        /** @description Warn Metric Id. */
        warn_metric_id: string;
      };
    };
    responses: {
      /** @description The trial license request and the subsequent acknowledgement of the warning for the metric have been successful. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Perform a database integrity check 
   * @description Performs a database integrity check.
   * 
   * 
   * __Note__: This check may temporarily harm system performance.
   * 
   * 
   * __Minimum server version__: 5.28.0
   * 
   * 
   * __Local mode only__: This endpoint is only available through [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
   */
  CheckIntegrity: {
    responses: {
      /** @description Integrity check successful */
      200: {
        content: {
          "application/json": (components["schemas"]["IntegrityCheckResult"])[];
        };
      };
    };
  };
  /**
   * Download a zip file which contains helpful and useful information for troubleshooting your mattermost instance. 
   * @description Download a zip file which contains helpful and useful information for troubleshooting your mattermost instance.
   * __Minimum server version: 5.32__
   * ##### Permissions
   * Must have any of the system console read permissions.
   * ##### License
   * Requires either a E10 or E20 license.
   */
  GenerateSupportPacket: {
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a list of custom emoji 
   * @description Get a page of metadata for custom emoji on the system. Since server version 4.7, sort using the `sort` query parameter.
   * ##### Permissions
   * Must be authenticated.
   */
  GetEmojiList: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of emojis per page. */
        per_page?: number;
        /** @description Either blank for no sorting or "name" to sort by emoji names. Minimum server version for sorting is 4.7. */
        sort?: string;
      };
    };
    responses: {
      /** @description Emoji list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a custom emoji 
   * @description Create a custom emoji for the team.
   * ##### Permissions
   * Must be authenticated.
   */
  CreateEmoji: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description A file to be uploaded
           */
          image: string;
          /** @description A JSON object containing a `name` field with the name of the emoji and a `creator_id` field with the id of the authenticated user. */
          emoji: string;
        };
      };
    };
    responses: {
      /** @description Emoji creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a custom emoji 
   * @description Get some metadata for a custom emoji.
   * ##### Permissions
   * Must be authenticated.
   */
  GetEmoji: {
    parameters: {
      path: {
        /** @description Emoji GUID */
        emoji_id: string;
      };
    };
    responses: {
      /** @description Emoji retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete a custom emoji 
   * @description Delete a custom emoji.
   * ##### Permissions
   * Must have the `manage_team` or `manage_system` permissions or be the user who created the emoji.
   */
  DeleteEmoji: {
    parameters: {
      path: {
        /** @description Emoji GUID */
        emoji_id: string;
      };
    };
    responses: {
      /** @description Emoji delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a custom emoji by name 
   * @description Get some metadata for a custom emoji using its name.
   * ##### Permissions
   * Must be authenticated.
   * 
   * __Minimum server version__: 4.7
   */
  GetEmojiByName: {
    parameters: {
      path: {
        /** @description Emoji name */
        emoji_name: string;
      };
    };
    responses: {
      /** @description Emoji retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get custom emoji image 
   * @description Get the image for a custom emoji.
   * ##### Permissions
   * Must be authenticated.
   */
  GetEmojiImage: {
    parameters: {
      path: {
        /** @description Emoji GUID */
        emoji_id: string;
      };
    };
    responses: {
      /** @description Emoji image retrieval successful */
      200: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Search custom emoji 
   * @description Search for custom emoji by name based on search criteria provided in the request body. A maximum of 200 results are returned.
   * ##### Permissions
   * Must be authenticated.
   * 
   * __Minimum server version__: 4.7
   */
  SearchEmoji: {
    /** @description Search criteria */
    requestBody: {
      content: {
        "application/json": {
          /** @description The term to match against the emoji name. */
          term: string;
          /** @description Set to only search for names starting with the search term. */
          prefix_only?: string;
        };
      };
    };
    responses: {
      /** @description Emoji list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Emoji"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Autocomplete custom emoji 
   * @description Get a list of custom emoji with names starting with or matching the provided name. Returns a maximum of 100 results.
   * ##### Permissions
   * Must be authenticated.
   * 
   * __Minimum server version__: 4.7
   */
  AutocompleteEmoji: {
    parameters: {
      query: {
        /** @description The emoji name to search. */
        name: string;
      };
    };
    responses: {
      /** @description Emoji list retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Emoji"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * List incoming webhooks 
   * @description Get a page of a list of incoming webhooks. Optionally filter for a specific team using query parameters.
   * ##### Permissions
   * `manage_webhooks` for the system or `manage_webhooks` for the specific team.
   */
  GetIncomingWebhooks: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of hooks per page. */
        per_page?: number;
        /** @description The ID of the team to get hooks for. */
        team_id?: string;
      };
    };
    responses: {
      /** @description Incoming webhooks retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["IncomingWebhook"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create an incoming webhook 
   * @description Create an incoming webhook for a channel.
   * ##### Permissions
   * `manage_webhooks` for the team the webhook is in.
   * 
   * `manage_others_incoming_webhooks` for the team the webhook is in if the user is different than the requester.
   */
  CreateIncomingWebhook: {
    /** @description Incoming webhook to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of a public channel or private group that receives the webhook payloads. */
          channel_id: string;
          /** @description The ID of the owner of the webhook if different than the requester. Required for [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode). */
          user_id?: string;
          /** @description The display name for this incoming webhook */
          display_name?: string;
          /** @description The description for this incoming webhook */
          description?: string;
          /** @description The username this incoming webhook will post as. */
          username?: string;
          /** @description The profile picture this incoming webhook will use when posting. */
          icon_url?: string;
        };
      };
    };
    responses: {
      /** @description Incoming webhook creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["IncomingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get an incoming webhook 
   * @description Get an incoming webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  GetIncomingWebhook: {
    parameters: {
      path: {
        /** @description Incoming Webhook GUID */
        hook_id: string;
      };
    };
    responses: {
      /** @description Webhook retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["IncomingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update an incoming webhook 
   * @description Update an incoming webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  UpdateIncomingWebhook: {
    parameters: {
      path: {
        /** @description Incoming Webhook GUID */
        hook_id: string;
      };
    };
    /** @description Incoming webhook to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description Incoming webhook GUID */
          id: string;
          /** @description The ID of a public channel or private group that receives the webhook payloads. */
          channel_id: string;
          /** @description The display name for this incoming webhook */
          display_name: string;
          /** @description The description for this incoming webhook */
          description: string;
          /** @description The username this incoming webhook will post as. */
          username?: string;
          /** @description The profile picture this incoming webhook will use when posting. */
          icon_url?: string;
        };
      };
    };
    responses: {
      /** @description Webhook update successful */
      200: {
        content: {
          "application/json": components["schemas"]["IncomingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete an incoming webhook 
   * @description Delete an incoming webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  DeleteIncomingWebhook: {
    parameters: {
      path: {
        /** @description Incoming webhook GUID */
        hook_id: string;
      };
    };
    responses: {
      /** @description Webhook deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * List outgoing webhooks 
   * @description Get a page of a list of outgoing webhooks. Optionally filter for a specific team or channel using query parameters.
   * ##### Permissions
   * `manage_webhooks` for the system or `manage_webhooks` for the specific team/channel.
   */
  GetOutgoingWebhooks: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of hooks per page. */
        per_page?: number;
        /** @description The ID of the team to get hooks for. */
        team_id?: string;
        /** @description The ID of the channel to get hooks for. */
        channel_id?: string;
      };
    };
    responses: {
      /** @description Outgoing webhooks retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["OutgoingWebhook"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create an outgoing webhook 
   * @description Create an outgoing webhook for a team.
   * ##### Permissions
   * `manage_webhooks` for the team the webhook is in.
   * 
   * `manage_others_outgoing_webhooks` for the team the webhook is in if the user is different than the requester.
   */
  CreateOutgoingWebhook: {
    /** @description Outgoing webhook to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the team that the webhook watchs */
          team_id: string;
          /** @description The ID of a public channel that the webhook watchs */
          channel_id?: string;
          /** @description The ID of the owner of the webhook if different than the requester. Required in [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode). */
          creator_id?: string;
          /** @description The description for this outgoing webhook */
          description?: string;
          /** @description The display name for this outgoing webhook */
          display_name: string;
          /** @description List of words for the webhook to trigger on */
          trigger_words: (string)[];
          /** @description When to trigger the webhook, `0` when a trigger word is present at all and `1` if the message starts with a trigger word */
          trigger_when?: number;
          /** @description The URLs to POST the payloads to when the webhook is triggered */
          callback_urls: (string)[];
          /**
           * @description The format to POST the data in, either `application/json` or `application/x-www-form-urlencoded` 
           * @default application/x-www-form-urlencoded
           */
          content_type?: string;
        };
      };
    };
    responses: {
      /** @description Outgoing webhook creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["OutgoingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get an outgoing webhook 
   * @description Get an outgoing webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  GetOutgoingWebhook: {
    parameters: {
      path: {
        /** @description Outgoing webhook GUID */
        hook_id: string;
      };
    };
    responses: {
      /** @description Outgoing webhook retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["OutgoingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update an outgoing webhook 
   * @description Update an outgoing webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  UpdateOutgoingWebhook: {
    parameters: {
      path: {
        /** @description outgoing Webhook GUID */
        hook_id: string;
      };
    };
    /** @description Outgoing webhook to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description Outgoing webhook GUID */
          id: string;
          /** @description The ID of a public channel or private group that receives the webhook payloads. */
          channel_id: string;
          /** @description The display name for this incoming webhook */
          display_name: string;
          /** @description The description for this incoming webhook */
          description: string;
        };
      };
    };
    responses: {
      /** @description Webhook update successful */
      200: {
        content: {
          "application/json": components["schemas"]["OutgoingWebhook"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Delete an outgoing webhook 
   * @description Delete an outgoing webhook given the hook id.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  DeleteOutgoingWebhook: {
    parameters: {
      path: {
        /** @description Outgoing webhook GUID */
        hook_id: string;
      };
    };
    responses: {
      /** @description Webhook deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Regenerate the token for the outgoing webhook. 
   * @description Regenerate the token for the outgoing webhook.
   * ##### Permissions
   * `manage_webhooks` for system or `manage_webhooks` for the specific team or `manage_webhooks` for the channel.
   */
  RegenOutgoingHookToken: {
    parameters: {
      path: {
        /** @description Outgoing webhook GUID */
        hook_id: string;
      };
    };
    responses: {
      /** @description Webhook token regenerate successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get metadata 
   * @description Get SAML metadata from the server. SAML must be configured properly.
   * ##### Permissions
   * No permission required.
   */
  GetSamlMetadata: {
    responses: {
      /** @description SAML metadata retrieval successful */
      200: {
        content: {
          "application/json": string;
        };
      };
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get metadata from Identity Provider 
   * @description Get SAML metadata from the Identity Provider. SAML must be configured properly.
   * ##### Permissions
   * No permission required.
   */
  GetSamlMetadataFromIdp: {
    requestBody?: {
      content: {
        "application/json": {
          /** @description The URL from which to retrieve the SAML IDP data. */
          saml_metadata_url?: string;
        };
      };
    };
    responses: {
      /** @description SAML metadata retrieval successful */
      200: {
        content: {
          "application/json": string;
        };
      };
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload IDP certificate 
   * @description Upload the IDP certificate to be used with your SAML configuration. The server will pick a hard-coded filename for the IdpCertificateFile setting in your `config.json`.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  UploadSamlIdpCertificate: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The IDP certificate file
           */
          certificate: string;
        };
      };
    };
    responses: {
      /** @description SAML certificate upload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove IDP certificate 
   * @description Delete the current IDP certificate being used with your SAML configuration. This will also disable SAML on your system as this certificate is required for SAML.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  DeleteSamlIdpCertificate: {
    responses: {
      /** @description SAML certificate delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload public certificate 
   * @description Upload the public certificate to be used for encryption with your SAML configuration. The server will pick a hard-coded filename for the PublicCertificateFile setting in your `config.json`.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  UploadSamlPublicCertificate: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The public certificate file
           */
          certificate: string;
        };
      };
    };
    responses: {
      /** @description SAML certificate upload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove public certificate 
   * @description Delete the current public certificate being used with your SAML configuration. This will also disable encryption for SAML on your system as this certificate is required for that.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  DeleteSamlPublicCertificate: {
    responses: {
      /** @description SAML certificate delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload private key 
   * @description Upload the private key to be used for encryption with your SAML configuration. The server will pick a hard-coded filename for the PrivateKeyFile setting in your `config.json`.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  UploadSamlPrivateCertificate: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The private key file
           */
          certificate: string;
        };
      };
    };
    responses: {
      /** @description SAML certificate upload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove private key 
   * @description Delete the current private key being used with your SAML configuration. This will also disable encryption for SAML on your system as this key is required for that.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  DeleteSamlPrivateCertificate: {
    responses: {
      /** @description SAML certificate delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get certificate status 
   * @description Get the status of the uploaded certificates and keys in use by your SAML configuration.
   * ##### Permissions
   * Must have `sysconsole_write_authentication` permission.
   */
  GetSamlCertificateStatus: {
    responses: {
      /** @description SAML certificate status retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["SamlCertificateStatus"];
        };
      };
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Reset AuthData to Email 
   * @description Reset the AuthData field of SAML users to their email. This is meant to be used when the "id" attribute is set to an empty value ("") from a previously non-empty value.
   * __Minimum server version__: 5.35
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  ResetSamlAuthDataToEmail: {
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description Whether to include deleted users. 
           * @default false
           */
          include_deleted?: boolean;
          /**
           * @description If set to true, the number of users who would be affected is returned. 
           * @default false
           */
          dry_run?: boolean;
          /**
           * @description If set to a non-empty array, then users whose IDs are not in the array will be excluded. 
           * @default []
           */
          user_ids?: (string)[];
        };
      };
    };
    responses: {
      /** @description AuthData successfully reset */
      200: {
        content: {
          "application/json": {
            /** @description The number of users whose AuthData field was reset. */
            num_affected?: number;
          };
        };
      };
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get reports 
   * @description Get a list of compliance reports previously created by page, selected with `page` and `per_page` query parameters.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetComplianceReports: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of reports per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Compliance reports retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Compliance"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create report 
   * @description Create and save a compliance report.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  CreateComplianceReport: {
    responses: {
      /** @description Compliance report creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Compliance"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a report 
   * @description Get a compliance reports previously created.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetComplianceReport: {
    parameters: {
      path: {
        /** @description Compliance report GUID */
        report_id: string;
      };
    };
    responses: {
      /** @description Compliance report retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Compliance"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Download a report 
   * @description Download the full contents of a report as a file.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  DownloadComplianceReport: {
    parameters: {
      path: {
        /** @description Compliance report GUID */
        report_id: string;
      };
    };
    responses: {
      /** @description The compliance report file */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Sync with LDAP 
   * @description Synchronize any user attribute changes in the configured AD/LDAP server with Mattermost.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  SyncLdap: {
    responses: {
      /** @description LDAP sync successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Test LDAP configuration 
   * @description Test the current AD/LDAP configuration to see if the AD/LDAP server can be contacted successfully.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  TestLdap: {
    responses: {
      /** @description LDAP test successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Returns a list of LDAP groups 
   * @description ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 5.11
   */
  GetLdapGroups: {
    parameters: {
      query: {
        /** @description Search term */
        q?: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. There is a maximum limit of 200 users per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description LDAP group page retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["LDAPGroupsPaged"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Link a LDAP group 
   * @description ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 5.11
   */
  LinkLdapGroup: {
    parameters: {
      path: {
        /** @description Group GUID */
        remote_id: string;
      };
    };
    responses: {
      /** @description LDAP group successfully linked */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Delete a link for LDAP group 
   * @description ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 5.11
   */
  UnlinkLdapGroup: {
    parameters: {
      path: {
        /** @description Group GUID */
        remote_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted ldap group link */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Migrate Id LDAP 
   * @description Migrate LDAP IdAttribute to new value.
   * ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version__: 5.26
   */
  MigrateIdLdap: {
    requestBody: {
      content: {
        "application/json": {
          /** @description New IdAttribute value */
          toAttribute: string;
        };
      };
    };
    responses: {
      /** @description Migration successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload public certificate 
   * @description Upload the public certificate to be used for TLS verification. The server will pick a hard-coded filename for the PublicCertificateFile setting in your `config.json`.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UploadLdapPublicCertificate: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The public certificate file
           */
          certificate: string;
        };
      };
    };
    responses: {
      /** @description LDAP certificate upload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove public certificate 
   * @description Delete the current public certificate being used for TLS verification.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  DeleteLdapPublicCertificate: {
    responses: {
      /** @description LDAP certificate delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload private key 
   * @description Upload the private key to be used for TLS verification. The server will pick a hard-coded filename for the PrivateKeyFile setting in your `config.json`.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UploadLdapPrivateCertificate: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The private key file
           */
          certificate: string;
        };
      };
    };
    responses: {
      /** @description LDAP certificate upload successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove private key 
   * @description Delete the current private key being used with your TLS verification.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  DeleteLdapPrivateCertificate: {
    responses: {
      /** @description LDAP certificate delete successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get groups 
   * @description Retrieve a list of all groups not associated to a particular channel or team.
   * 
   * `not_associated_to_team` **OR** `not_associated_to_channel` is required.
   * 
   * If you use `not_associated_to_team`, you must be a team admin for that particular team (permission to manage that team).
   * 
   * If you use `not_associated_to_channel`, you must be a channel admin for that particular channel (permission to manage that channel).
   * 
   * __Minimum server version__: 5.11
   */
  GetGroups: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of groups per page. */
        per_page?: number;
        /** @description String to pattern match the `name` and `display_name` field. Will return all groups whose `name` and `display_name` field match any of the text. */
        q?: string;
        /** @description Boolean which adds the `member_count` attribute to each group JSON object */
        include_member_count?: boolean;
        /** @description Team GUID which is used to return all the groups not associated to this team */
        not_associated_to_team: string;
        /** @description Group GUID which is used to return all the groups not associated to this channel */
        not_associated_to_channel: string;
        /**
         * @description Only return groups that have been modified since the given Unix timestamp (in milliseconds). All modified groups, including deleted and created groups, will be returned.
         * __Minimum server version__: 5.24
         */
        since?: number;
        /** @description Boolean which filters the group entries with the `allow_reference` attribute set. */
        filter_allow_reference?: boolean;
      };
    };
    responses: {
      /** @description Group list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Group"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a custom group 
   * @description Create a `custom` type group.
   * 
   * #### Permission
   * Must have `create_custom_group` permission.
   * 
   * __Minimum server version__: 6.3
   */
  CreateGroup: {
    /** @description Group object and initial members. */
    requestBody: {
      content: {
        "application/json": {
          /** @description Group object to create. */
          group: {
            /** @description The unique group name used for at-mentioning. */
            name: string;
            /** @description The display name of the group which can include spaces. */
            display_name: string;
            /** @description Must be `custom` */
            source: string;
            /** @description Must be true */
            allow_reference: boolean;
          };
          /** @description The user ids of the group members to add. */
          user_ids: (string)[];
        };
      };
    };
    responses: {
      /** @description Group creation and memberships successful. */
      201: never;
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
      /**
       * @description Group has an invalid `source`, or
       * `allow_reference` is not `true`, or
       * group has a `remote_id`.
       */
      501: never;
    };
  };
  /**
   * Get a group 
   * @description Get group from the provided group id string
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroup: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    responses: {
      /** @description Group retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Group"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Deletes a custom group 
   * @description Soft deletes a custom group.
   * 
   * ##### Permissions
   * Must have `custom_group_delete` permission for the given group.
   * 
   * __Minimum server version__: 6.3
   */
  DeleteGroup: {
    parameters: {
      path: {
        /** @description The ID of the group. */
        group_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted the group. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      /** @description Group is already deleted or doesn't exist. */
      404: never;
      /** @description The group doesn't have a `source` value of `custom`. */
      501: never;
    };
  };
  /**
   * Patch a group 
   * @description Partially update a group by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  PatchGroup: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    /** @description Group object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          display_name?: string;
          description?: string;
        };
      };
    };
    responses: {
      /** @description Group patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Group"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Link a team to a group 
   * @description Link a team to a group
   * ##### Permissions
   * Must have `manage_team` permission.
   * 
   * __Minimum server version__: 5.11
   */
  LinkGroupSyncableForTeam: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Team successfully linked to group */
      201: {
        content: {
          "application/json": components["schemas"]["GroupSyncableTeam"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete a link from a team to a group 
   * @description Delete a link from a team to a group
   * ##### Permissions
   * Must have `manage_team` permission.
   * 
   * __Minimum server version__: 5.11
   */
  UnlinkGroupSyncableForTeam: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted link between team and group */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Link a channel to a group 
   * @description Link a channel to a group
   * ##### Permissions
   * If the channel is private, you must have `manage_private_channel_members` permission.
   * Otherwise, you must have the `manage_public_channel_members` permission.
   * 
   * __Minimum server version__: 5.11
   */
  LinkGroupSyncableForChannel: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Channel successfully linked to group */
      201: {
        content: {
          "application/json": components["schemas"]["GroupSyncableChannel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete a link from a channel to a group 
   * @description Delete a link from a channel to a group
   * ##### Permissions
   * If the channel is private, you must have `manage_private_channel_members` permission.
   * Otherwise, you must have the `manage_public_channel_members` permission.
   * 
   * __Minimum server version__: 5.11
   */
  UnlinkGroupSyncableForChannel: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted link between channel and group */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get GroupSyncable from Team ID 
   * @description Get the GroupSyncable object with group_id and team_id from params
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupSyncableForTeamId: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description GroupSyncable object retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["GroupSyncableTeam"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get GroupSyncable from channel ID 
   * @description Get the GroupSyncable object with group_id and channel_id from params
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupSyncableForChannelId: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description GroupSyncable object retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["GroupSyncableChannel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get group teams 
   * @description Retrieve the list of teams associated to the group
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupSyncablesTeams: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    responses: {
      /** @description Teams list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["GroupSyncableTeams"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get group channels 
   * @description Retrieve the list of channels associated to the group
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupSyncablesChannels: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    responses: {
      /** @description Channel list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["GroupSyncableChannels"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Patch a GroupSyncable associated to Team 
   * @description Partially update a GroupSyncable by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  PatchGroupSyncableForTeam: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Team GUID */
        team_id: string;
      };
    };
    /** @description GroupSyncable object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          auto_add?: boolean;
        };
      };
    };
    responses: {
      /** @description GroupSyncable patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["GroupSyncableTeam"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Patch a GroupSyncable associated to Channel 
   * @description Partially update a GroupSyncable by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  PatchGroupSyncableForChannel: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    /** @description GroupSyncable object that is to be updated */
    requestBody: {
      content: {
        "application/json": {
          auto_add?: boolean;
        };
      };
    };
    responses: {
      /** @description GroupSyncable patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["GroupSyncableChannel"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get group users 
   * @description Retrieve the list of users associated with a given group.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupUsers: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of groups per page. */
        per_page?: number;
      };
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    responses: {
      /** @description User list retrieval successful */
      200: {
        content: {
          "application/json": {
            members?: (components["schemas"]["User"])[];
            total_member_count?: number;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Adds members to a custom group 
   * @description Adds members to a custom group.
   * 
   * ##### Permissions
   * Must have `custom_group_manage_members` permission for the given group.
   * 
   * __Minimum server version__: 6.3
   */
  AddGroupMembers: {
    parameters: {
      path: {
        /** @description The ID of the group. */
        group_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          user_ids?: (string)[];
        };
      };
    };
    responses: {
      /** @description Successfully added the group members. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      /** @description Can't find the group. */
      404: never;
      /** @description If the group does not have a `source` value of `custom`. */
      501: never;
    };
  };
  /**
   * Removes members from a custom group 
   * @description Soft deletes a custom group members.
   * 
   * ##### Permissions
   * Must have `custom_group_manage_members` permission for the given group.
   * 
   * __Minimum server version__: 6.3
   */
  DeleteGroupMembers: {
    parameters: {
      path: {
        /** @description The ID of the group to delete. */
        group_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          user_ids?: (string)[];
        };
      };
    };
    responses: {
      /** @description Successfully deleted the group members. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      /** @description Can't find the group. */
      404: never;
      /** @description If the group does not have a `source` value of `custom`. */
      501: never;
    };
  };
  /**
   * Get group stats 
   * @description Retrieve the stats of a given group.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.26
   */
  GetGroupStats: {
    parameters: {
      path: {
        /** @description Group GUID */
        group_id: string;
      };
    };
    responses: {
      /** @description Group stats retrieval successful */
      200: {
        content: {
          "application/json": {
            group_id?: string;
            total_member_count?: number;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get channel groups 
   * @description Retrieve the list of groups associated with a given channel.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupsByChannel: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of groups per page. */
        per_page?: number;
        /** @description Boolean which filters the group entries with the `allow_reference` attribute set. */
        filter_allow_reference?: boolean;
      };
      path: {
        /** @description Channel GUID */
        channel_id: string;
      };
    };
    responses: {
      /** @description Group list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Group"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get team groups 
   * @description Retrieve the list of groups associated with a given team.
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupsByTeam: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of groups per page. */
        per_page?: number;
        /** @description Boolean which filters in the group entries with the `allow_reference` attribute set. */
        filter_allow_reference?: boolean;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Group list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Group"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get team groups by channels 
   * @description Retrieve the set of groups associated with the channels in the given team grouped by channel.
   * 
   * ##### Permissions
   * Must have `manage_system` permission or can access only for current user
   * 
   * __Minimum server version__: 5.11
   */
  GetGroupsAssociatedToChannelsByTeam: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of groups per page. */
        per_page?: number;
        /** @description Boolean which filters in the group entries with the `allow_reference` attribute set. */
        filter_allow_reference?: boolean;
        /** @description Boolean to determine whether the pagination should be applied or not */
        paginate?: boolean;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Group list retrieval successful */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get groups for a userId 
   * @description Retrieve the list of groups associated to the user
   * 
   * __Minimum server version__: 5.24
   */
  GetGroupsByUserId: {
    parameters: {
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description Group list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Group"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cluster status 
   * @description Get a set of information for each node in the cluster, useful for checking the status and health of each node.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  GetClusterStatus: {
    responses: {
      /** @description Cluster status retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["ClusterInfo"])[];
        };
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get brand image 
   * @description Get the previously uploaded brand image. Returns 404 if no brand image has been uploaded.
   * ##### Permissions
   * No permission required.
   */
  GetBrandImage: {
    responses: {
      /** @description Brand image retrieval successful */
      200: {
        content: {
          "application/json": string;
        };
      };
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload brand image 
   * @description Uploads a brand image.
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  UploadBrandImage: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The image to be uploaded
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description Brand image upload successful */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete current brand image 
   * @description Deletes the previously uploaded brand image. Returns 404 if no brand image has been uploaded.
   * ##### Permissions
   * Must have `manage_system` permission.
   * __Minimum server version: 5.6__
   */
  DeleteBrandImage: {
    responses: {
      /** @description Brand image succesfully deleted */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * List commands for a team 
   * @description List commands for a team.
   * ##### Permissions
   * `manage_slash_commands` if need list custom commands.
   */
  ListCommands: {
    parameters: {
      query: {
        /** @description The team id. */
        team_id?: string;
        /**
         * @description To get only the custom commands. If set to false will get the custom
         * if the user have access plus the system commands, otherwise just the system commands.
         */
        custom_only?: boolean;
      };
    };
    responses: {
      /** @description List Commands retrieve successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Command"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a command 
   * @description Create a command for a team.
   * ##### Permissions
   * `manage_slash_commands` for the team the command is in.
   */
  CreateCommand: {
    /** @description command to be created */
    requestBody: {
      content: {
        "application/json": {
          /** @description Team ID to where the command should be created */
          team_id: string;
          /** @description `'P'` for post request, `'G'` for get request */
          method: string;
          /** @description Activation word to trigger the command */
          trigger: string;
          /** @description The URL that the command will make the request */
          url: string;
        };
      };
    };
    responses: {
      /** @description Command creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Command"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * List autocomplete commands 
   * @description List autocomplete commands in the team.
   * ##### Permissions
   * `view_team` for the team.
   */
  ListAutocompleteCommands: {
    parameters: {
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Autocomplete commands retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Command"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * List commands' autocomplete data 
   * @description List commands' autocomplete data for the team.
   * ##### Permissions
   * `view_team` for the team.
   * __Minimum server version__: 5.24
   */
  ListCommandAutocompleteSuggestions: {
    parameters: {
      query: {
        /** @description String inputted by the user. */
        user_input: string;
      };
      path: {
        /** @description Team GUID */
        team_id: string;
      };
    };
    responses: {
      /** @description Commands' autocomplete data retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["AutocompleteSuggestion"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a command 
   * @description Get a command definition based on command id string.
   * ##### Permissions
   * Must have `manage_slash_commands` permission for the team the command is in.
   * 
   * __Minimum server version__: 5.22
   */
  GetCommandById: {
    parameters: {
      path: {
        /** @description ID of the command to get */
        command_id: string;
      };
    };
    responses: {
      /** @description Command get successful */
      200: {
        content: {
          "application/json": components["schemas"]["Command"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Update a command 
   * @description Update a single command based on command id string and Command struct.
   * ##### Permissions
   * Must have `manage_slash_commands` permission for the team the command is in.
   */
  UpdateCommand: {
    parameters: {
      path: {
        /** @description ID of the command to update */
        command_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Command"];
      };
    };
    responses: {
      /** @description Command updated successful */
      200: {
        content: {
          "application/json": components["schemas"]["Command"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Delete a command 
   * @description Delete a command based on command id string.
   * ##### Permissions
   * Must have `manage_slash_commands` permission for the team the command is in.
   */
  DeleteCommand: {
    parameters: {
      path: {
        /** @description ID of the command to delete */
        command_id: string;
      };
    };
    responses: {
      /** @description Command deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Move a command 
   * @description Move a command to a different team based on command id string.
   * ##### Permissions
   * Must have `manage_slash_commands` permission for the team the command is currently in and the destination team.
   * 
   * __Minimum server version__: 5.22
   */
  MoveCommand: {
    parameters: {
      path: {
        /** @description ID of the command to move */
        command_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Destination teamId */
          team_id?: string;
        };
      };
    };
    responses: {
      /** @description Command move successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Generate a new token 
   * @description Generate a new token for the command based on command id string.
   * ##### Permissions
   * Must have `manage_slash_commands` permission for the team the command is in.
   */
  RegenCommandToken: {
    parameters: {
      path: {
        /** @description ID of the command to generate the new token */
        command_id: string;
      };
    };
    responses: {
      /** @description Token generation successful */
      200: {
        content: {
          "application/json": {
            /** @description The new token */
            token?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Execute a command 
   * @description Execute a command on a team.
   * ##### Permissions
   * Must have `use_slash_commands` permission for the team the command is in.
   */
  ExecuteCommand: {
    /** @description command to be executed */
    requestBody: {
      content: {
        "application/json": {
          /** @description Channel Id where the command will execute */
          channel_id: string;
          /** @description The slash command to execute, including parameters. Eg, `'/echo bounces around the room'` */
          command: string;
        };
      };
    };
    responses: {
      /** @description Command execution successful */
      200: {
        content: {
          "application/json": components["schemas"]["CommandResponse"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get OAuth apps 
   * @description Get a page of OAuth 2.0 client applications registered with Mattermost.
   * ##### Permissions
   * With `manage_oauth` permission, the apps registered by the logged in user are returned. With `manage_system_wide_oauth` permission, all apps regardless of creator are returned.
   */
  GetOAuthApps: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of apps per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description OAuthApp list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["OAuthApp"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Register OAuth app 
   * @description Register an OAuth 2.0 client application with Mattermost as the service provider.
   * ##### Permissions
   * Must have `manage_oauth` permission.
   */
  CreateOAuthApp: {
    /** @description OAuth application to register */
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the client application */
          name: string;
          /** @description A short description of the application */
          description: string;
          /** @description A URL to an icon to display with the application */
          icon_url?: string;
          /** @description A list of callback URLs for the appliation */
          callback_urls: (string)[];
          /** @description A link to the website of the application */
          homepage: string;
          /** @description Set this to `true` to skip asking users for permission */
          is_trusted?: boolean;
        };
      };
    };
    responses: {
      /** @description App registration successful */
      201: {
        content: {
          "application/json": components["schemas"]["OAuthApp"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get an OAuth app 
   * @description Get an OAuth 2.0 client application registered with Mattermost.
   * ##### Permissions
   * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
   */
  GetOAuthApp: {
    parameters: {
      path: {
        /** @description Application client id */
        app_id: string;
      };
    };
    responses: {
      /** @description App retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApp"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Update an OAuth app 
   * @description Update an OAuth 2.0 client application based on OAuth struct.
   * ##### Permissions
   * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
   */
  UpdateOAuthApp: {
    parameters: {
      path: {
        /** @description Application client id */
        app_id: string;
      };
    };
    /** @description OAuth application to update */
    requestBody: {
      content: {
        "application/json": {
          /** @description The id of the client application */
          id: string;
          /** @description The name of the client application */
          name: string;
          /** @description A short description of the application */
          description: string;
          /** @description A URL to an icon to display with the application */
          icon_url?: string;
          /** @description A list of callback URLs for the appliation */
          callback_urls: (string)[];
          /** @description A link to the website of the application */
          homepage: string;
          /** @description Set this to `true` to skip asking users for permission. It will be set to false if value is not provided. */
          is_trusted?: boolean;
        };
      };
    };
    responses: {
      /** @description App update successful */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApp"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete an OAuth app 
   * @description Delete and unregister an OAuth 2.0 client application 
   * ##### Permissions
   * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
   */
  DeleteOAuthApp: {
    parameters: {
      path: {
        /** @description Application client id */
        app_id: string;
      };
    };
    responses: {
      /** @description App deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Regenerate OAuth app secret 
   * @description Regenerate the client secret for an OAuth 2.0 client application registered with Mattermost.
   * ##### Permissions
   * If app creator, must have `mange_oauth` permission otherwise `manage_system_wide_oauth` permission is required.
   */
  RegenerateOAuthAppSecret: {
    parameters: {
      path: {
        /** @description Application client id */
        app_id: string;
      };
    };
    responses: {
      /** @description Secret regeneration successful */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApp"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get info on an OAuth app 
   * @description Get public information about an OAuth 2.0 client application registered with Mattermost. The application's client secret will be blanked out.
   * ##### Permissions
   * Must be authenticated.
   */
  GetOAuthAppInfo: {
    parameters: {
      path: {
        /** @description Application client id */
        app_id: string;
      };
    };
    responses: {
      /** @description App retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApp"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get authorized OAuth apps 
   * @description Get a page of OAuth 2.0 client applications authorized to access a user's account.
   * ##### Permissions
   * Must be authenticated as the user or have `edit_other_users` permission.
   */
  GetAuthorizedOAuthAppsForUser: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of apps per page. */
        per_page?: number;
      };
      path: {
        /** @description User GUID */
        user_id: string;
      };
    };
    responses: {
      /** @description OAuthApp list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["OAuthApp"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Test Elasticsearch configuration 
   * @description Test the current Elasticsearch configuration to see if the Elasticsearch server can be contacted successfully.
   * Optionally provide a configuration in the request body to test. If no valid configuration is present in the
   * request body the current server configuration will be tested.
   * 
   * __Minimum server version__: 4.1
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  TestElasticsearch: {
    responses: {
      /** @description Elasticsearch test successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Purge all Elasticsearch indexes 
   * @description Deletes all Elasticsearch indexes and their contents. After calling this endpoint, it is
   * necessary to schedule a new Elasticsearch indexing job to repopulate the indexes.
   * __Minimum server version__: 4.1
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  PurgeElasticsearchIndexes: {
    responses: {
      /** @description Indexes purged successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Purge all Bleve indexes 
   * @description Deletes all Bleve indexes and their contents. After calling this endpoint, it is
   * necessary to schedule a new Bleve indexing job to repopulate the indexes.
   * __Minimum server version__: 5.24
   * ##### Permissions
   * Must have `sysconsole_write_experimental` permission.
   */
  PurgeBleveIndexes: {
    responses: {
      /** @description Indexes purged successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the global data retention policy 
   * @description Gets the current global data retention policy details from the server,
   * including what data should be purged and the cutoff times for each data
   * type that should be purged.
   * 
   * __Minimum server version__: 4.3
   * 
   * ##### Permissions
   * Requires an active session but no other permissions.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetDataRetentionPolicy: {
    responses: {
      /** @description Global data retention policy details retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["GlobalDataRetentionPolicy"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the number of granular data retention policies 
   * @description Gets the number of granular (i.e. team or channel-specific) data retention
   * policies from the server.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetDataRetentionPoliciesCount: {
    responses: {
      /** @description Number of retention policies retrieved successfully. */
      200: {
        content: {
          "application/json": {
            /** @description The number of granular retention policies. */
            total_count?: number;
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the granular data retention policies 
   * @description Gets details about the granular (i.e. team or channel-specific) data retention
   * policies from the server.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetDataRetentionPolicies: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of policies per page. There is a maximum limit of 200 per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Retention policies' details retrieved successfully. */
      200: {
        content: {
          "application/json": (components["schemas"]["DataRetentionPolicyWithTeamAndChannelCounts"])[];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a new granular data retention policy 
   * @description Creates a new granular data retention policy with the specified display
   * name and post duration.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  CreateDataRetentionPolicy: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DataRetentionPolicyCreate"];
      };
    };
    responses: {
      /** @description Retention policy successfully created. */
      201: {
        content: {
          "application/json": components["schemas"]["DataRetentionPolicyWithTeamAndChannelCounts"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a granular data retention policy 
   * @description Gets details about a granular data retention policies by ID.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetDataRetentionPolicyByID: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    responses: {
      /** @description Retention policy's details retrieved successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["DataRetentionPolicyWithTeamAndChannelCounts"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete a granular data retention policy 
   * @description Deletes a granular data retention policy.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  DeleteDataRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    responses: {
      /** @description Retention policy successfully deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Patch a granular data retention policy 
   * @description Patches (i.e. replaces the fields of) a granular data retention policy.
   * If any fields are omitted, they will not be changed.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  PatchDataRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DataRetentionPolicyWithTeamAndChannelIds"];
      };
    };
    responses: {
      /** @description Retention policy successfully patched. */
      200: {
        content: {
          "application/json": components["schemas"]["DataRetentionPolicyWithTeamAndChannelCounts"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the teams for a granular data retention policy 
   * @description Gets the teams to which a granular data retention policy is applied.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetTeamsForRetentionPolicy: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of teams per page. There is a maximum limit of 200 per page. */
        per_page?: number;
      };
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    responses: {
      /** @description Teams for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": (components["schemas"]["Team"])[];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Add teams to a granular data retention policy 
   * @description Adds teams to a granular data retention policy.
   * 
   *  __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  AddTeamsToRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Teams successfully added to retention policy. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete teams from a granular data retention policy 
   * @description Delete teams from a granular data retention policy.
   * 
   *  __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  RemoveTeamsFromRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Teams successfully deleted from retention policy. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Search for the teams in a granular data retention policy 
   * @description Searches for the teams to which a granular data retention policy is applied.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  SearchTeamsForRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The search term to match against the name or display name of teams */
          term?: string;
        };
      };
    };
    responses: {
      /** @description Teams for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": (components["schemas"]["Team"])[];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get the channels for a granular data retention policy 
   * @description Gets the channels to which a granular data retention policy is applied.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  GetChannelsForRetentionPolicy: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of channels per page. There is a maximum limit of 200 per page. */
        per_page?: number;
      };
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    responses: {
      /** @description Channels for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelListWithTeamData"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Add channels to a granular data retention policy 
   * @description Adds channels to a granular data retention policy.
   * 
   *  __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  AddChannelsToRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Channels successfully added to retention policy. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete channels from a granular data retention policy 
   * @description Delete channels from a granular data retention policy.
   * 
   *  __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_write_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  RemoveChannelsFromRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Channels successfully deleted from retention policy. */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Search for the channels in a granular data retention policy 
   * @description Searches for the channels to which a granular data retention policy is applied.
   * 
   * __Minimum server version__: 5.35
   * 
   * ##### Permissions
   * Must have the `sysconsole_read_compliance_data_retention` permission.
   * 
   * ##### License
   * Requires an E20 license.
   */
  SearchChannelsForRetentionPolicy: {
    parameters: {
      path: {
        /** @description The ID of the granular retention policy. */
        policy_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The string to search in the channel name, display name, and purpose. */
          term?: string;
          /** @description Filters results to channels belonging to the given team ids */
          team_ids?: (string)[];
          /** @description Filters results to only return Public / Open channels, can be used in conjunction with `private` to return both `public` and `private` channels */
          public?: boolean;
          /** @description Filters results to only return Private channels, can be used in conjunction with `public` to return both `private` and `public` channels */
          private?: boolean;
          /** @description Filters results to only return deleted / archived channels */
          deleted?: boolean;
        };
      };
    };
    responses: {
      /** @description Channels for retention policy successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelListWithTeamData"];
        };
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get plugins 
   * @description Get a list of inactive and a list of active plugin manifests. Plugins must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.4
   */
  GetPlugins: {
    responses: {
      /** @description Plugins retrieval successful */
      200: {
        content: {
          "application/json": {
            active?: (components["schemas"]["PluginManifest"])[];
            inactive?: (components["schemas"]["PluginManifest"])[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Upload plugin 
   * @description Upload a plugin that is contained within a compressed .tar.gz file. Plugins and plugin uploads must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.4
   */
  UploadPlugin: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description The plugin image to be uploaded
           */
          plugin: string;
          /** @description Set to 'true' to overwrite a previously installed plugin with the same ID, if any */
          force?: string;
        };
      };
    };
    responses: {
      /** @description Plugin upload successful */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Install plugin from url 
   * @description Supply a URL to a plugin compressed in a .tar.gz file. Plugins must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.14
   */
  InstallPluginFromUrl: {
    parameters: {
      query: {
        /** @description URL used to download the plugin */
        plugin_download_url: string;
        /** @description Set to 'true' to overwrite a previously installed plugin with the same ID, if any */
        force?: string;
      };
    };
    responses: {
      /** @description Plugin install successful */
      201: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Remove plugin 
   * @description Remove the plugin with the provided ID from the server. All plugin files are deleted. Plugins must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.4
   */
  RemovePlugin: {
    parameters: {
      path: {
        /** @description Id of the plugin to be removed */
        plugin_id: string;
      };
    };
    responses: {
      /** @description Plugin removed successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Enable plugin 
   * @description Enable a previously uploaded plugin. Plugins must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.4
   */
  EnablePlugin: {
    parameters: {
      path: {
        /** @description Id of the plugin to be enabled */
        plugin_id: string;
      };
    };
    responses: {
      /** @description Plugin enabled successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Disable plugin 
   * @description Disable a previously enabled plugin. Plugins must be enabled in the server's config settings.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 4.4
   */
  DisablePlugin: {
    parameters: {
      path: {
        /** @description Id of the plugin to be disabled */
        plugin_id: string;
      };
    };
    responses: {
      /** @description Plugin disabled successfully */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get webapp plugins 
   * @description Get a list of web app plugins installed and activated on the server.
   * 
   * ##### Permissions
   * No permissions required.
   * 
   * __Minimum server version__: 4.4
   */
  GetWebappPlugins: {
    responses: {
      /** @description Plugin deactivated successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["PluginManifestWebapp"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get plugins status 
   * @description Returns the status for plugins installed anywhere in the cluster
   * 
   * ##### Permissions
   * No permissions required.
   * 
   * __Minimum server version__: 4.4
   */
  GetPluginStatuses: {
    responses: {
      /** @description Plugin status retreived successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["PluginStatus"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Gets all the marketplace plugins 
   * @description Gets all plugins from the marketplace server, merging data from locally installed plugins as well as prepackaged plugins shipped with the server.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.16
   */
  GetMarketplacePlugins: {
    parameters: {
      query: {
        /** @description Page number to be fetched. (not yet implemented) */
        page?: number;
        /** @description Number of item per page. (not yet implemented) */
        per_page?: number;
        /** @description Set to filter plugins by ID, name, or description. */
        filter?: string;
        /** @description Set to filter minimum plugin server version. (not yet implemented) */
        server_version?: string;
        /** @description Set true to only retrieve local plugins. */
        local_only?: boolean;
      };
    };
    responses: {
      /** @description Plugins retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["MarketplacePlugin"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Installs a marketplace plugin 
   * @description Installs a plugin listed in the marketplace server.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.16
   */
  InstallMarketplacePlugin: {
    /** @description The metadata identifying the plugin to install. */
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the plugin to install. */
          id: string;
          /** @description The version of the plugin to install. */
          version: string;
        };
      };
    };
    responses: {
      /** @description Plugin installed successfully */
      200: {
        content: {
          "application/json": components["schemas"]["PluginManifest"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get if the Plugin Marketplace has been visited by at least an admin. 
   * @description Retrieves the status that specifies that at least one System Admin has visited the in-product Plugin Marketplace.
   * __Minimum server version: 5.33__
   * ##### Permissions
   * Must have `manage_system` permissions.
   */
  GetMarketplaceVisitedByAdmin: {
    responses: {
      /** @description Retrieves the system-level status */
      200: {
        content: {
          "application/json": components["schemas"]["System"];
        };
      };
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Stores that the Plugin Marketplace has been visited by at least an admin. 
   * @description Stores the system-level status that specifies that at least an admin has visited the in-product Plugin Marketplace.
   * __Minimum server version: 5.33__
   * ##### Permissions
   * Must have `manage_system` permissions.
   */
  UpdateMarketplaceVisitedByAdmin: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["System"];
      };
    };
    responses: {
      /** @description setting has been successfully set */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get a list of all the roles 
   * @description ##### Permissions
   * 
   * `manage_system` permission is required.
   * 
   * __Minimum server version__: 5.33
   */
  GetAllRoles: {
    responses: {
      /** @description Roles retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Role"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a role 
   * @description Get a role from the provided role id.
   * 
   * ##### Permissions
   * Requires an active session but no other permissions.
   * 
   * __Minimum server version__: 4.9
   */
  GetRole: {
    parameters: {
      path: {
        /** @description Role GUID */
        role_id: string;
      };
    };
    responses: {
      /** @description Role retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Role"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a role 
   * @description Get a role from the provided role name.
   * 
   * ##### Permissions
   * Requires an active session but no other permissions.
   * 
   * __Minimum server version__: 4.9
   */
  GetRoleByName: {
    parameters: {
      path: {
        /** @description Role Name */
        role_name: string;
      };
    };
    responses: {
      /** @description Role retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Role"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Patch a role 
   * @description Partially update a role by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * 
   * ##### Permissions
   * `manage_system` permission is required.
   * 
   * __Minimum server version__: 4.9
   */
  PatchRole: {
    parameters: {
      path: {
        /** @description Role GUID */
        role_id: string;
      };
    };
    /** @description Role object to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description The permissions the role should grant. */
          permissions?: (string)[];
        };
      };
    };
    responses: {
      /** @description Role patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Role"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a list of roles by name 
   * @description Get a list of roles from their names.
   * 
   * ##### Permissions
   * Requires an active session but no other permissions.
   * 
   * __Minimum server version__: 4.9
   */
  GetRolesByNames: {
    /** @description List of role names */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Role list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Role"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get the schemes. 
   * @description Get a page of schemes. Use the query parameters to modify the behaviour of this endpoint.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.0
   */
  GetSchemes: {
    parameters: {
      query: {
        /** @description Limit the results returned to the provided scope, either `team` or `channel`. */
        scope?: string;
        /** @description The page to select. */
        page?: number;
        /** @description The number of schemes per page. */
        per_page?: number;
      };
    };
    responses: {
      /** @description Scheme list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Scheme"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a scheme 
   * @description Create a new scheme.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.0
   */
  CreateScheme: {
    /** @description Scheme object to create */
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the scheme */
          name: string;
          /** @description The description of the scheme */
          description?: string;
          /** @description The scope of the scheme ("team" or "channel") */
          scope: string;
        };
      };
    };
    responses: {
      /** @description Scheme creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Scheme"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a scheme 
   * @description Get a scheme from the provided scheme id.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.0
   */
  GetScheme: {
    parameters: {
      path: {
        /** @description Scheme GUID */
        scheme_id: string;
      };
    };
    responses: {
      /** @description Scheme retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["Scheme"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete a scheme 
   * @description Soft deletes a scheme, by marking the scheme as deleted in the database.
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   * 
   * __Minimum server version__: 5.0
   */
  DeleteScheme: {
    parameters: {
      path: {
        /** @description ID of the scheme to delete */
        scheme_id: string;
      };
    };
    responses: {
      /** @description Scheme deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Patch a scheme 
   * @description Partially update a scheme by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * 
   * ##### Permissions
   * `manage_system` permission is required.
   * 
   * __Minimum server version__: 5.0
   */
  PatchScheme: {
    parameters: {
      path: {
        /** @description Scheme GUID */
        scheme_id: string;
      };
    };
    /** @description Scheme object to be updated */
    requestBody: {
      content: {
        "application/json": {
          /** @description The human readable name of the scheme */
          name?: string;
          /** @description The description of the scheme */
          description?: string;
        };
      };
    };
    responses: {
      /** @description Scheme patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Scheme"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get a page of teams which use this scheme. 
   * @description Get a page of teams which use this scheme. The provided Scheme ID should be for a Team-scoped Scheme.
   * Use the query parameters to modify the behaviour of this endpoint.
   * 
   * ##### Permissions
   * `manage_system` permission is required.
   * 
   * __Minimum server version__: 5.0
   */
  GetTeamsForScheme: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of teams per page. */
        per_page?: number;
      };
      path: {
        /** @description Scheme GUID */
        scheme_id: string;
      };
    };
    responses: {
      /** @description Team list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Team"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get a page of channels which use this scheme. 
   * @description Get a page of channels which use this scheme. The provided Scheme ID should be for a Channel-scoped Scheme.
   * Use the query parameters to modify the behaviour of this endpoint.
   * 
   * ##### Permissions
   * `manage_system` permission is required.
   * 
   * __Minimum server version__: 5.0
   */
  GetChannelsForScheme: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of channels per page. */
        per_page?: number;
      };
      path: {
        /** @description Scheme GUID */
        scheme_id: string;
      };
    };
    responses: {
      /** @description Channel list retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Channel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get latest terms of service 
   * @description Get latest terms of service from the server
   * 
   * __Minimum server version__: 5.4
   * ##### Permissions
   * Must be authenticated.
   */
  GetTermsOfService: {
    responses: {
      /** @description Terms of service fetched successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TermsOfService"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Creates a new terms of service 
   * @description Creates new terms of service
   * 
   * __Minimum server version__: 5.4
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  CreateTermsOfService: {
    responses: {
      /** @description terms of service fetched successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TermsOfService"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
    };
  };
  /**
   * Get all shared channels for team. 
   * @description Get all shared channels for a team.
   * 
   * __Minimum server version__: 5.50
   * 
   * ##### Permissions
   * Must be authenticated.
   */
  GetAllSharedChannels: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of sharedchannels per page. */
        per_page?: number;
      };
      path: {
        /** @description Team Id */
        team_id: string;
      };
    };
    responses: {
      /** @description Shared channels fetch successful. Result may be empty. */
      200: {
        content: {
          "application/json": (components["schemas"]["SharedChannel"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get remote cluster info by ID for user. 
   * @description Get remote cluster info based on remoteId.
   * 
   * __Minimum server version__: 5.50
   * 
   * ##### Permissions
   * Must be authenticated and user must belong to at least one channel shared with the remote cluster.
   */
  GetRemoteClusterInfo: {
    parameters: {
      path: {
        /** @description Remote Cluster GUID */
        remote_id: string;
      };
    };
    responses: {
      /** @description Remote cluster info retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteClusterInfo"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get open graph metadata for url 
   * @description Get Open Graph Metadata for a specif URL. Use the Open Graph protocol to get some generic metadata about a URL. Used for creating link previews.
   * 
   * __Minimum server version__: 3.10
   * 
   * ##### Permissions
   * No permission required but must be logged in.
   */
  OpenGraph: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The URL to get Open Graph Metadata. */
          url: string;
        };
      };
    };
    responses: {
      /** @description Open Graph retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["OpenGraph"];
        };
      };
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a reaction 
   * @description Create a reaction.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in.
   */
  SaveReaction: {
    /** @description The user's reaction with its post_id, user_id, and emoji_name fields set */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Reaction"];
      };
    };
    responses: {
      /** @description Reaction creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Reaction"];
        };
      };
      400: components["responses"]["BadRequest"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a list of reactions to a post 
   * @description Get a list of reactions made by all users to a given post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in.
   */
  GetReactions: {
    parameters: {
      path: {
        /** @description ID of a post */
        post_id: string;
      };
    };
    responses: {
      /** @description List reactions retrieve successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Reaction"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Remove a reaction from a post 
   * @description Deletes a reaction made by a user from the given post.
   * ##### Permissions
   * Must be user or have `manage_system` permission.
   */
  DeleteReaction: {
    parameters: {
      path: {
        /** @description ID of the user */
        user_id: string;
        /** @description ID of the post */
        post_id: string;
        /** @description emoji name */
        emoji_name: string;
      };
    };
    responses: {
      /** @description Reaction deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Bulk get the reaction for posts 
   * @description Get a list of reactions made by all users to a given post.
   * ##### Permissions
   * Must have `read_channel` permission for the channel the post is in.
   * 
   * __Minimum server version__: 5.8
   */
  GetBulkReactions: {
    /** @description Array of post IDs */
    requestBody: {
      content: {
        "application/json": (string)[];
      };
    };
    responses: {
      /** @description Reactions retrieval successful */
      200: {
        content: {
          "application/json": components["schemas"]["PostIdToReactionsMap"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Open a dialog 
   * @description Open an interactive dialog using a trigger ID provided by a slash command, or some other action payload. See https://docs.mattermost.com/developer/interactive-dialogs.html for more information on interactive dialogs.
   * __Minimum server version: 5.6__
   */
  OpenInteractiveDialog: {
    /** @description Metadata for the dialog to be opened */
    requestBody: {
      content: {
        "application/json": {
          /** @description Trigger ID provided by other action */
          trigger_id: string;
          /** @description The URL to send the submitted dialog payload to */
          url: string;
          /** @description Post object to create */
          dialog: {
            /** @description Set an ID that will be included when the dialog is submitted */
            callback_id?: string;
            /** @description Title of the dialog */
            title: string;
            /** @description Markdown formatted introductory paragraph */
            introduction_text?: string;
            /** @description Input elements, see https://docs.mattermost.com/developer/interactive-dialogs.html#elements */
            elements: (Record<string, never>)[];
            /** @description Label on the submit button */
            submit_label?: string;
            /** @description Set true to receive payloads when user cancels a dialog */
            notify_on_cancel?: boolean;
            /** @description Set some state to be echoed back with the dialog submission */
            state?: string;
          };
        };
      };
    };
    responses: {
      /** @description Dialog open successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * Submit a dialog 
   * @description Endpoint used by the Mattermost clients to submit a dialog. See https://docs.mattermost.com/developer/interactive-dialogs.html for more information on interactive dialogs.
   * __Minimum server version: 5.6__
   */
  SubmitInteractiveDialog: {
    /** @description Dialog submission data */
    requestBody: {
      content: {
        "application/json": {
          /** @description The URL to send the submitted dialog payload to */
          url: string;
          /** @description Channel ID the user submitted the dialog from */
          channel_id: string;
          /** @description Team ID the user submitted the dialog from */
          team_id: string;
          /** @description String map where keys are element names and values are the element input values */
          submission: Record<string, never>;
          /** @description Callback ID sent when the dialog was opened */
          callback_id?: string;
          /** @description State sent when the dialog was opened */
          state?: string;
          /** @description Set to true if the dialog was cancelled */
          cancelled?: boolean;
        };
      };
    };
    responses: {
      /** @description Dialog submission successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get bots 
   * @description Get a page of a list of bots.
   * ##### Permissions
   * Must have `read_bots` permission for bots you are managing, and `read_others_bots` permission for bots others are managing.
   * __Minimum server version__: 5.10
   */
  GetBots: {
    parameters: {
      query: {
        /** @description The page to select. */
        page?: number;
        /** @description The number of users per page. There is a maximum limit of 200 users per page. */
        per_page?: number;
        /** @description If deleted bots should be returned. */
        include_deleted?: boolean;
        /** @description When true, only orphaned bots will be returned. A bot is consitered orphaned if it's owner has been deactivated. */
        only_orphaned?: boolean;
      };
    };
    responses: {
      /** @description Bot page retrieval successful */
      200: {
        content: {
          "application/json": (components["schemas"]["Bot"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a bot 
   * @description Create a new bot account on the system. Username is required.
   * ##### Permissions
   * Must have `create_bot` permission.
   * __Minimum server version__: 5.10
   */
  CreateBot: {
    /** @description Bot to be created */
    requestBody: {
      content: {
        "application/json": {
          username: string;
          display_name?: string;
          description?: string;
        };
      };
    };
    responses: {
      /** @description Bot creation successful */
      201: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get a bot 
   * @description Get a bot specified by its bot id.
   * ##### Permissions
   * Must have `read_bots` permission for bots you are managing, and `read_others_bots` permission for bots others are managing.
   * __Minimum server version__: 5.10
   */
  GetBot: {
    parameters: {
      query: {
        /** @description If deleted bots should be returned. */
        include_deleted?: boolean;
      };
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    responses: {
      /** @description Bot successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Patch a bot 
   * @description Partially update a bot by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored.
   * ##### Permissions
   * Must have `manage_bots` permission. 
   * __Minimum server version__: 5.10
   */
  PatchBot: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    /** @description Bot to be created */
    requestBody: {
      content: {
        "application/json": {
          username: string;
          display_name?: string;
          description?: string;
        };
      };
    };
    responses: {
      /** @description Bot patch successful */
      200: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Disable a bot 
   * @description Disable a bot.
   * ##### Permissions
   * Must have `manage_bots` permission. 
   * __Minimum server version__: 5.10
   */
  DisableBot: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    responses: {
      /** @description Bot successfully disabled. */
      200: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Enable a bot 
   * @description Enable a bot.
   * ##### Permissions
   * Must have `manage_bots` permission. 
   * __Minimum server version__: 5.10
   */
  EnableBot: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    responses: {
      /** @description Bot successfully enabled. */
      200: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Assign a bot to a user 
   * @description Assign a bot to a specified user.
   * ##### Permissions
   * Must have `manage_bots` permission. 
   * __Minimum server version__: 5.10
   */
  AssignBot: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
        /** @description The user ID to assign the bot to. */
        user_id: string;
      };
    };
    responses: {
      /** @description Bot successfully assigned. */
      200: {
        content: {
          "application/json": components["schemas"]["Bot"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Get bot's LHS icon 
   * @description Get a bot's LHS icon image based on bot_user_id string parameter.
   * ##### Permissions
   * Must be logged in.
   * __Minimum server version__: 5.14
   */
  GetBotIconImage: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    responses: {
      /** @description Bot's LHS icon image */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Set bot's LHS icon image 
   * @description Set a bot's LHS icon image based on bot_user_id string parameter. Icon image must be SVG format, all other formats are rejected.
   * ##### Permissions
   * Must have `manage_bots` permission.
   * __Minimum server version__: 5.14
   */
  SetBotIconImage: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description SVG icon image to be uploaded
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description SVG icon image set successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      413: components["responses"]["TooLarge"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Delete bot's LHS icon image 
   * @description Delete bot's LHS icon image based on bot_user_id string parameter.
   * ##### Permissions
   * Must have `manage_bots` permission.
   * __Minimum server version__: 5.14
   */
  DeleteBotIconImage: {
    parameters: {
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    responses: {
      /** @description Icon image deletion successful */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Convert a bot into a user 
   * @description Convert a bot into a user.
   * 
   * __Minimum server version__: 5.26
   * 
   * ##### Permissions
   * Must have `manage_system` permission.
   */
  ConvertBotToUser: {
    parameters: {
      query: {
        /** @description Whether to give the user the system admin role. */
        set_system_admin?: boolean;
      };
      path: {
        /** @description Bot user ID */
        bot_user_id: string;
      };
    };
    /** @description Data to be used in the user creation */
    requestBody: {
      content: {
        "application/json": {
          email?: string;
          username?: string;
          password?: string;
          first_name?: string;
          last_name?: string;
          nickname?: string;
          locale?: string;
          position?: string;
          props?: Record<string, never>;
          notify_props?: components["schemas"]["UserNotifyProps"];
        };
      };
    };
    responses: {
      /** @description Bot successfully converted */
      200: {
        content: {
          "application/json": components["schemas"]["StatusOK"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Get cloud workspace limits 
   * @description Retrieve any cloud workspace limits applicable to this instance.
   * ##### Permissions
   * Must be authenticated and be licensed for Cloud.
   * __Minimum server version__: 7.0 __Note:__ This is intended for internal use and is subject to change.
   */
  GetCloudLimits: {
    responses: {
      /** @description Cloud workspace limits returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ProductLimits"];
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cloud products 
   * @description Retrieve a list of all products that are offered for Mattermost Cloud.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
   */
  GetCloudProducts: {
    responses: {
      /** @description Cloud products returned successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Product"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Create a customer setup payment intent 
   * @description Creates a customer setup payment intent for the given Mattermost cloud installation.
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permission and be licensed for Cloud.
   * 
   * __Minimum server version__: 5.28
   * __Note:__: This is intended for internal use and is subject to change.
   */
  CreateCustomerPayment: {
    responses: {
      /** @description Payment setup intented created */
      201: {
        content: {
          "application/json": components["schemas"]["PaymentSetupIntent"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Completes the payment setup intent 
   * @description Confirms the payment setup intent initiated when posting to `/cloud/payment`.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
   */
  ConfirmCustomerPayment: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          stripe_setup_intent_id?: string;
        };
      };
    };
    responses: {
      /** @description Payment setup intent confirmed successfully */
      200: never;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cloud customer 
   * @description Retrieves the customer information for the Mattermost Cloud customer bound to this installation.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
   */
  GetCloudCustomer: {
    responses: {
      /** @description Cloud customer returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["CloudCustomer"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Update cloud customer 
   * @description Updates the customer information for the Mattermost Cloud customer bound to this installation.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.29 __Note:__ This is intended for internal use and is subject to change.
   */
  UpdateCloudCustomer: {
    /** @description Customer patch including information to update */
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          email?: string;
          contact_first_name?: string;
          contact_last_name?: string;
          num_employees?: string;
        };
      };
    };
    responses: {
      /** @description Cloud customer updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["CloudCustomer"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Update cloud customer address 
   * @description Updates the company address for the Mattermost Cloud customer bound to this installation.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.29 __Note:__ This is intended for internal use and is subject to change.
   */
  UpdateCloudCustomerAddress: {
    /** @description Company address information to update */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Address"];
      };
    };
    responses: {
      /** @description Cloud customer address updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["CloudCustomer"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cloud subscription 
   * @description Retrieves the subscription information for the Mattermost Cloud customer bound to this installation.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.28 __Note:__ This is intended for internal use and is subject to change.
   */
  GetSubscription: {
    responses: {
      /** @description Cloud subscription returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Subscription"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cloud subscription invoices 
   * @description Retrieves the invoices for the subscription bound to this installation.
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
   */
  GetInvoicesForSubscription: {
    responses: {
      /** @description Subscription invoices returned successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Invoice"])[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get cloud invoice PDF 
   * @description Retrieves the PDF for the invoice passed as parameter
   * ##### Permissions
   * Must have `manage_system` permission and be licensed for Cloud.
   * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
   */
  GetInvoiceForSubscriptionAsPdf: {
    parameters: {
      path: {
        /** @description Invoice ID */
        invoice_id: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * POST endpoint for CWS Webhooks 
   * @description An endpoint for processing webhooks from the Customer Portal
   * ##### Permissions
   * This endpoint should only be accessed by CWS, in a Mattermost Cloud instance
   * __Minimum server version__: 5.30 __Note:__ This is intended for internal use and is subject to change.
   */
  PostEndpointForCwsWebhooks: {
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      501: components["responses"]["NotImplemented"];
    };
  };
  /**
   * Get current usage of posts 
   * @description Retrieve rounded off total no. of posts for this instance. Example: returns 4000 instead of 4321
   * ##### Permissions
   * Must be authenticated.
   * __Minimum server version__: 7.0
   */
  GetPostsUsage: {
    responses: {
      /** @description Total no. of posts returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["PostsUsage"];
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get the total file storage usage for the instance in bytes. 
   * @description Get the total file storage usage for the instance in bytes rounded down to the most significant digit. Example: returns 4000 instead of 4321
   * ##### Permissions
   * Must be authenticated.
   * __Minimum server version__: 7.1
   */
  GetStorageUsage: {
    responses: {
      /** @description The total file storage usage for the instance in bytes rounded down to the most significant digit. */
      200: {
        content: {
          "application/json": components["schemas"]["StorageUsage"];
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Return all system console subsection ancillary permissions 
   * @description Returns all the ancillary permissions for the corresponding system console subsection permissions appended to the requested permission subsections.
   * 
   * __Minimum server version__: 5.35
   */
  GetAncillaryPermissions: {
    parameters: {
      query: {
        /** @description The subsection permissions to return the ancillary permissions for. These values are comma seperated. Ex. subsection_permissions=sysconsole_read_reporting_site_statistics,sysconsole_write_reporting_site_statistics,sysconsole_write_user_management_channels */
        subsection_permissions?: string;
      };
    };
    responses: {
      /** @description Successfully returned all ancillary and requested permissions */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  /**
   * List import files 
   * @description Lists all available import files.
   * 
   * __Minimum server version__: 5.31
   * ##### Permissions
   * Must have `manage_system` permissions.
   */
  ListImports: {
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * List export files 
   * @description Lists all available export files.
   * __Minimum server version__: 5.33
   * ##### Permissions
   * Must have `manage_system` permissions.
   */
  ListExports: {
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Download an export file 
   * @description Downloads an export file.
   * 
   * 
   * __Minimum server version__: 5.33
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permissions.
   */
  DownloadExport: {
    parameters: {
      path: {
        /** @description The name of the export file to download */
        export_name: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Delete an export file 
   * @description Deletes an export file.
   * 
   * 
   * __Minimum server version__: 5.33
   * 
   * ##### Permissions
   * 
   * Must have `manage_system` permissions.
   */
  DeleteExport: {
    parameters: {
      path: {
        /** @description The name of the export file to delete */
        export_name: string;
      };
    };
    responses: {
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List all playbook runs 
   * @description Retrieve a paged list of playbook runs, filtered by team, status, owner, name and/or members, and sorted by ID, name, status, creation date, end date, team or owner ID.
   */
  listPlaybookRuns: {
    parameters: {
      query: {
        /**
         * @description ID of the team to filter by. 
         * @example el3d3t9p55pevvxs2qkdwz334k
         */
        team_id: string;
        /**
         * @description Zero-based index of the page to request. 
         * @example 3
         */
        page?: number;
        /**
         * @description Number of playbook runs to return per page. 
         * @example 50
         */
        per_page?: number;
        /**
         * @description Field to sort the returned playbook runs by. 
         * @example end_at
         */
        sort?: "id" | "name" | "is_active" | "create_at" | "end_at" | "team_id" | "owner_user_id";
        /**
         * @description Direction (ascending or descending) followed by the sorting of the playbook runs. 
         * @example asc
         */
        direction?: "desc" | "asc";
        /**
         * @description The returned list will contain only the playbook runs with the specified statuses. 
         * @example InProgress
         */
        statuses?: ("InProgress" | "Finished")[];
        /**
         * @description The returned list will contain only the playbook runs commanded by this user. Specify "me" for current user. 
         * @example lpn2ogt9qzkc59lfvvad9t15v4
         */
        owner_user_id?: string;
        /**
         * @description The returned list will contain only the playbook runs for which the given user is a participant. Specify "me" for current user. 
         * @example bruhg1cs65retdbea798hrml4v
         */
        participant_id?: string;
        /**
         * @description The returned list will contain only the playbook runs whose name contains the search term. 
         * @example server down
         */
        search_term?: string;
      };
    };
    responses: {
      /** @description A paged list of playbook runs. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookRunList"];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Create a new playbook run 
   * @description Create a new playbook run in a team, using a playbook as template, with a specific name and a specific owner.
   */
  createPlaybookRunFromPost: {
    /** @description Playbook run payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The name of the playbook run. 
           * @example Server down in EU cluster
           */
          name: string;
          /**
           * @description The description of the playbook run. 
           * @example There is one server in the EU cluster that is not responding since April 12.
           */
          description?: string;
          /**
           * @description The identifier of the user who is commanding the playbook run. 
           * @example bqnbdf8uc0a8yz4i39qrpgkvtg
           */
          owner_user_id: string;
          /**
           * @description The identifier of the team where the playbook run's channel is in. 
           * @example 61ji2mpflefup3cnuif80r5rde
           */
          team_id: string;
          /**
           * @description If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty. 
           * @example b2ntfcrl4ujivl456ab4b3aago
           */
          post_id?: string;
          /**
           * @description The identifier of the playbook with from which this playbook run was created. 
           * @example 0y4a0ntte97cxvfont8y84wa7x
           */
          playbook_id: string;
        };
      };
    };
    responses: {
      /** @description Created playbook run. */
      201: {
        headers: {
          /** @description Location of the created playbook run. */
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["PlaybookRun"];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Create a new playbook run from dialog 
   * @description This is an internal endpoint to create a playbook run from the submission of an interactive dialog, filled by a user in the webapp. See [Interactive Dialogs](https://docs.mattermost.com/developer/interactive-dialogs.html) for more information.
   */
  createPlaybookRunFromDialog: {
    /** @description Dialog submission payload. */
    requestBody?: {
      content: {
        "application/json": {
          /** @example dialog_submission */
          type?: string;
          url?: string;
          /** @description Callback ID provided by the integration. */
          callback_id?: string;
          /** @description Stringified JSON with the post_id and the client_id. */
          state?: string;
          /** @description ID of the user who submitted the dialog. */
          user_id?: string;
          /** @description ID of the channel the user was in when submitting the dialog. */
          channel_id?: string;
          /** @description ID of the team the user was on when submitting the dialog. */
          team_id?: string;
          /** @description Map of the dialog fields to their values */
          submission?: {
            /**
             * @description ID of the playbook to create the playbook run from. 
             * @example ahz0s61gh275i7z2ag4g1ntvjm
             */
            playbookID: string;
            /**
             * @description The name of the playbook run to be created. 
             * @example Server down in EU cluster.
             */
            playbookRunName: string;
            /**
             * @description An optional description of the playbook run. 
             * @example There is one server in the EU cluster that is not responding since April 12.
             */
            playbookRunDescription?: string;
          };
          /** @description If the dialog was cancelled. */
          cancelled?: boolean;
        };
      };
    };
    responses: {
      /** @description Created playbook run. */
      201: {
        headers: {
          /** @description Location of the created playbook run. */
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["PlaybookRun"];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Get all owners 
   * @description Get the owners of all playbook runs, filtered by team.
   */
  getOwners: {
    parameters: {
      query: {
        /**
         * @description ID of the team to filter by. 
         * @example el3d3t9p55pevvxs2qkdwz334k
         */
        team_id: string;
      };
    };
    responses: {
      /** @description A list of owners. */
      200: {
        content: {
          "application/json": (components["schemas"]["OwnerInfo"])[];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Get playbook run channels 
   * @description Get all channels associated with a playbook run, filtered by team, status, owner, name and/or members, and sorted by ID, name, status, creation date, end date, team, or owner ID.
   */
  getChannels: {
    parameters: {
      query: {
        /**
         * @description ID of the team to filter by. 
         * @example el3d3t9p55pevvxs2qkdwz334k
         */
        team_id: string;
        /**
         * @description Field to sort the returned channels by, according to their playbook run. 
         * @example end_at
         */
        sort?: "id" | "name" | "create_at" | "end_at" | "team_id" | "owner_user_id";
        /**
         * @description Direction (ascending or descending) followed by the sorting of the playbook runs associated to the channels. 
         * @example asc
         */
        direction?: "desc" | "asc";
        /**
         * @description The returned list will contain only the channels whose playbook run has this status. 
         * @example active
         */
        status?: "all" | "InProgress" | "Finished";
        /**
         * @description The returned list will contain only the channels whose playbook run is commanded by this user. 
         * @example lpn2ogt9qzkc59lfvvad9t15v4
         */
        owner_user_id?: string;
        /**
         * @description The returned list will contain only the channels associated to a playbook run whose name contains the search term. 
         * @example server down
         */
        search_term?: string;
        /**
         * @description The returned list will contain only the channels associated to a playbook run for which the given user is a participant. 
         * @example bruhg1cs65retdbea798hrml4v
         */
        participant_id?: string;
      };
    };
    responses: {
      /** @description Channel IDs. */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Get autocomplete data for /playbook check 
   * @description This is an internal endpoint used by the autocomplete system to retrieve the data needed to show the list of items that the user can check.
   */
  getChecklistAutocomplete: {
    parameters: {
      query: {
        /**
         * @description ID of the channel the user is in. 
         * @example r3vk8jdys4rlya46xhdthatoyx
         */
        channel_ID: string;
      };
    };
    responses: {
      /** @description List of autocomplete items for this channel. */
      200: {
        content: {
          "application/json": ({
              /**
               * @description A string containing a pair of integers separated by a space. The first integer is the index of the checklist; the second is the index of the item within the checklist. 
               * @example 1 2
               */
              item: string;
              /**
               * @description The title of the corresponding item. 
               * @example Gather information from customer.
               */
              hint: string;
              /**
               * @description Always the value "Check/uncheck this item". 
               * @example Check/uncheck this item
               */
              helptext: string;
            })[];
        };
      };
      500: components["responses"]["500"];
    };
  };
  /** Find playbook run by channel ID */
  getPlaybookRunByChannelId: {
    parameters: {
      path: {
        /** @description ID of the channel associated to the playbook run to retrieve. */
        channel_id: string;
      };
    };
    responses: {
      /** @description Playbook run associated to the channel. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookRun"];
        };
      };
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
  };
  /** Get a playbook run */
  getPlaybookRun: {
    parameters: {
      path: {
        /** @description ID of the playbook run to retrieve. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookRun"];
        };
      };
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Update a playbook run */
  updatePlaybookRun: {
    parameters: {
      path: {
        /** @description ID of the playbook run to retrieve. */
        id: string;
      };
    };
    /** @description Playbook run update payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description Zero-based index of the stage that will be made active. 
           * @example 2
           */
          active_stage?: number;
        };
      };
    };
    responses: {
      /** @description Playbook run successfully updated. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Get playbook run metadata */
  getPlaybookRunMetadata: {
    parameters: {
      path: {
        /** @description ID of the playbook run whose metadata will be retrieved. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run metadata. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookRunMetadata"];
        };
      };
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** End a playbook run */
  endPlaybookRun: {
    parameters: {
      path: {
        /** @description ID of the playbook run to end. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run ended */
      200: never;
      500: components["responses"]["500"];
    };
  };
  /**
   * End a playbook run from dialog 
   * @description This is an internal endpoint to end a playbook run via a confirmation dialog, submitted by a user in the webapp.
   */
  endPlaybookRunDialog: {
    parameters: {
      path: {
        /** @description ID of the playbook run to end. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run ended */
      200: never;
      500: components["responses"]["500"];
    };
  };
  /** Restart a playbook run */
  restartPlaybookRun: {
    parameters: {
      path: {
        /** @description ID of the playbook run to restart. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run restarted. */
      200: never;
      500: components["responses"]["500"];
    };
  };
  /** Update a playbook run's status */
  status: {
    parameters: {
      path: {
        /** @description ID of the playbook run to update. */
        id: string;
      };
    };
    /** @description Payload to change the playbook run's status update message. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The status update message. 
           * @example Starting to investigate.
           */
          message: string;
          /**
           * @description The number of seconds until the system will send a reminder to the owner to update the status. No reminder will be scheduled if reminder is 0 or omitted. 
           * @example 600
           */
          reminder?: number;
        };
      };
    };
    responses: {
      /** @description Playbook run updated. */
      200: never;
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Finish a playbook */
  finish: {
    parameters: {
      path: {
        /** @description ID of the playbook run to finish. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook run finished. */
      200: never;
      500: components["responses"]["500"];
    };
  };
  /** Update playbook run owner */
  changeOwner: {
    parameters: {
      path: {
        /** @description ID of the playbook run whose owner will be changed. */
        id: string;
      };
    };
    /** @description Payload to change the playbook run's owner. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The user ID of the new owner. 
           * @example hx7fqtqxp7nn8129t7e505ls6s
           */
          owner_id: string;
        };
      };
    };
    responses: {
      /** @description Owner successfully changed. */
      200: never;
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Go to next stage from dialog 
   * @description This is an internal endpoint to go to the next stage via a confirmation dialog, submitted by a user in the webapp.
   */
  nextStageDialog: {
    parameters: {
      path: {
        /** @description The PlaybookRun ID */
        id: string;
      };
    };
    /** @description Dialog submission payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description String representation of the zero-based index of the stage to go to. 
           * @example 3
           */
          state?: string;
        };
      };
    };
    responses: {
      /** @description Playbook run stage update. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Add an item to a playbook run's checklist 
   * @description The most common pattern to add a new item is to only send its title as the request payload. By default, it is an open item, with no assignee and no slash command.
   */
  addChecklistItem: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose checklist will be modified. 
         * @example twcqg0a2m37ydi6ebge3j9ev5z
         */
        id: string;
        /**
         * @description Zero-based index of the checklist to modify. 
         * @example 1
         */
        checklist: number;
      };
    };
    /** @description Checklist item payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The title of the checklist item. 
           * @example Gather information from customer.
           */
          title: string;
          /**
           * @description The state of the checklist item. An empty string means that the item is not done. 
           * @example closed 
           * @enum {string}
           */
          state?: "" | "in_progress" | "closed";
          /**
           * Format: int64 
           * @description The timestamp for the latest modification of the item's state, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item was never modified. 
           * @example 1607774621321
           */
          state_modified?: number;
          /**
           * @description The identifier of the user that has been assigned to complete this item. If the item has no assignee, this is an empty string. 
           * @example pisdatkjtdlkdhht2v4inxuzx1
           */
          assignee_id?: string;
          /**
           * Format: int64 
           * @description The timestamp for the latest modification of the item's assignee, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item never got an assignee. 
           * @example 1608897821125
           */
          assignee_modified?: number;
          /**
           * @description The slash command associated with this item. If the item has no slash command associated, this is an empty string 
           * @example /opsgenie on-call
           */
          command?: string;
          /**
           * Format: int64 
           * @description The timestamp for the latest execution of the item's command, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the command was never executed. 
           * @example 1608552221019
           */
          command_last_run?: number;
          /**
           * @description A detailed description of the checklist item, formatted with Markdown. 
           * @example Ask the customer for more information in [Zendesk](https://www.zendesk.com/).
           */
          description?: string;
        };
      };
    };
    responses: {
      /** @description Item successfully added. */
      200: never;
      /** @description Error response */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Reorder an item in a playbook run's checklist */
  reoderChecklistItem: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose checklist will be modified. 
         * @example yj74zsk7dvtsv6ndsynsps3g5s
         */
        id: string;
        /**
         * @description Zero-based index of the checklist to modify. 
         * @example 1
         */
        checklist: number;
      };
    };
    /** @description Reorder checklist item payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description Zero-based index of the item to reorder. 
           * @example 2
           */
          item_num: number;
          /**
           * @description Zero-based index of the new place to move the item to. 
           * @example 2
           */
          new_location: number;
        };
      };
    };
    responses: {
      /** @description Item successfully reordered. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /**
   * Update an item of a playbook run's checklist 
   * @description Update the title and the slash command of an item in one of the playbook run's checklists.
   */
  itemRename: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose checklist will be modified. 
         * @example 6t7jdgyqr7b5sk24zkauhmrb06
         */
        id: string;
        /**
         * @description Zero-based index of the checklist to modify. 
         * @example 1
         */
        checklist: number;
        /**
         * @description Zero-based index of the item to modify. 
         * @example 2
         */
        item: number;
      };
    };
    /** @description Update checklist item payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The new title of the item. 
           * @example Gather information from server's logs.
           */
          title: string;
          /**
           * @description The new slash command of the item. 
           * @example /jira update ticket
           */
          command: string;
        };
      };
    };
    responses: {
      /** @description Item updated. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Delete an item of a playbook run's checklist */
  itemDelete: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose checklist will be modified. 
         * @example zjy2q2iy2jafl0lo2oddos5xn7
         */
        id: string;
        /**
         * @description Zero-based index of the checklist to modify. 
         * @example 1
         */
        checklist: number;
        /**
         * @description Zero-based index of the item to modify. 
         * @example 2
         */
        item: number;
      };
    };
    responses: {
      /** @description Item successfully deleted. */
      204: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Update the state of an item */
  itemSetState: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose checklist will be modified. 
         * @example 7l37isroz4e63giev62hs318bn
         */
        id: string;
        /**
         * @description Zero-based index of the checklist to modify. 
         * @example 1
         */
        checklist: number;
        /**
         * @description Zero-based index of the item to modify. 
         * @example 2
         */
        item: number;
      };
    };
    /** @description Update checklist item's state payload. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The new state of the item. 
           * @default  
           * @example closed 
           * @enum {string}
           */
          new_state: "" | "in_progress" | "closed";
        };
      };
    };
    responses: {
      /** @description Item's state successfully updated. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Update the assignee of an item */
  itemSetAssignee: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose item will get a new assignee. 
         * @example 7l37isroz4e63giev62hs318bn
         */
        id: string;
        /**
         * @description Zero-based index of the checklist whose item will get a new assignee. 
         * @example 1
         */
        checklist: number;
        /**
         * @description Zero-based index of the item that will get a new assignee. 
         * @example 2
         */
        item: number;
      };
    };
    /** @description User ID of the new assignee. */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The user ID of the new assignee of the item. 
           * @example ruu86intseidqdxjojia41u7l1
           */
          assignee_id: string;
        };
      };
    };
    responses: {
      /** @description Item's assignee successfully updated. */
      200: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Run an item's slash command */
  itemRun: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose item will be executed. 
         * @example 7l37isroz4e63giev62hs318bn
         */
        id: string;
        /**
         * @description Zero-based index of the checklist whose item will be executed. 
         * @example 1
         */
        checklist: number;
        /**
         * @description Zero-based index of the item whose slash command will be executed. 
         * @example 2
         */
        item: number;
      };
    };
    responses: {
      /** @description Item's slash command successfully executed. */
      200: {
        content: {
          "application/json": components["schemas"]["TriggerIdReturn"];
        };
      };
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /** Remove a timeline event from the playbook run */
  removeTimelineEvent: {
    parameters: {
      path: {
        /**
         * @description ID of the playbook run whose timeline event will be modified. 
         * @example zjy2q2iy2jafl0lo2oddos5xn7
         */
        id: string;
        /**
         * @description ID of the timeline event to be deleted 
         * @example craxgf4r4trgzrtues3a1t74ac
         */
        "event-id": string;
      };
    };
    responses: {
      /** @description Item successfully deleted. */
      204: never;
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  /**
   * List all playbooks 
   * @description Retrieve a paged list of playbooks, filtered by team, and sorted by title, number of stages or number of steps.
   */
  getPlaybooks: {
    parameters: {
      query: {
        /**
         * @description ID of the team to filter by. 
         * @example 08fmfasq5wit3qyfmq4mjk0rto
         */
        team_id: string;
        /**
         * @description Zero-based index of the page to request. 
         * @example 3
         */
        page?: number;
        /**
         * @description Number of playbooks to return per page. 
         * @example 50
         */
        per_page?: number;
        /**
         * @description Field to sort the returned playbooks by title, number of stages or total number of steps. 
         * @example stages
         */
        sort?: "title" | "stages" | "steps";
        /**
         * @description Direction (ascending or descending) followed by the sorting of the playbooks. 
         * @example asc
         */
        direction?: "desc" | "asc";
        /**
         * @description Includes archived playbooks in the result. 
         * @example true
         */
        with_archived?: boolean;
      };
    };
    responses: {
      /** @description A paged list of playbooks. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookList"];
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Create a playbook */
  createPlaybook: {
    /** @description Playbook */
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description The title of the playbook. 
           * @example Cloud PlaybookRuns
           */
          title: string;
          /**
           * @description The description of the playbook. 
           * @example A playbook to follow when there is a playbook run regarding the availability of the cloud service.
           */
          description?: string;
          /**
           * @description The identifier of the team where the playbook is in. 
           * @example p03rbi6viyztysbqnkvcqyel2i
           */
          team_id: string;
          /**
           * @description A boolean indicating whether the playbook runs created from this playbook should be public or private. 
           * @example true
           */
          create_public_playbook_run: boolean;
          /** @description The stages defined by this playbook. */
          checklists: ({
              /**
               * @description The title of the checklist. 
               * @example Triage issue
               */
              title: string;
              /** @description The list of tasks to do. */
              items: ({
                  /**
                   * @description The title of the checklist item. 
                   * @example Gather information from customer.
                   */
                  title: string;
                  /**
                   * @description The slash command associated with this item. If the item has no slash command associated, this is an empty string 
                   * @example /opsgenie on-call
                   */
                  command?: string;
                  /**
                   * @description A detailed description of the checklist item, formatted with Markdown. 
                   * @example Ask the customer for more information in [Zendesk](https://www.zendesk.com/).
                   */
                  description?: string;
                })[];
            })[];
          /** @description The identifiers of all the users that are members of this playbook. */
          member_ids: (string)[];
          /** @description The IDs of the channels where all the status updates will be broadcasted. The team of the broadcast channel must be the same as the playbook's team. */
          broadcast_channel_ids?: (string)[];
          /** @description A list with the IDs of the members to be automatically invited to the playbook run's channel as soon as the playbook run is created. */
          invited_user_ids?: (string)[];
          /**
           * @description Boolean that indicates whether the members declared in invited_user_ids will be automatically invited. 
           * @example true
           */
          invite_users_enabled?: boolean;
          /**
           * @description User ID of the member that will be automatically assigned as owner as soon as the playbook run is created. If the member is not part of the playbook run's channel or is not included in the invited_user_ids list, they will be automatically invited to the channel. 
           * @example 9dtruav6d9ce3oqnc5pwhtqtfq
           */
          default_owner_id?: string;
          /**
           * @description Boolean that indicates whether the member declared in default_owner_id will be automatically assigned as owner. 
           * @example true
           */
          default_owner_enabled?: string;
          /**
           * @description ID of the channel where the playbook run will be automatically announced as soon as the playbook run is created. 
           * @example 8iofau5swv32l6qtk3vlxgobta
           */
          announcement_channel_id?: string;
          /**
           * @description Boolean that indicates whether the playbook run creation will be announced in the channel declared in announcement_channel_id. 
           * @example true
           */
          announcement_channel_enabled?: boolean;
          /**
           * @description An absolute URL where a POST request will be sent as soon as the playbook run is created. The allowed protocols are HTTP and HTTPS. 
           * @example https://httpbin.org/post
           */
          webhook_on_creation_url?: string;
          /**
           * @description Boolean that indicates whether the webhook declared in webhook_on_creation_url will be automatically sent. 
           * @example true
           */
          webhook_on_creation_enabled?: boolean;
          /**
           * @description An absolute URL where a POST request will be sent as soon as the playbook run's status is updated. The allowed protocols are HTTP and HTTPS. 
           * @example https://httpbin.org/post
           */
          webhook_on_status_update_url?: string;
          /**
           * @description Boolean that indicates whether the webhook declared in webhook_on_status_update_url will be automatically sent. 
           * @example true
           */
          webhook_on_status_update_enabled?: boolean;
        };
      };
    };
    responses: {
      /** @description ID of the created playbook. */
      201: {
        headers: {
          /** @description Location of the created playbook. */
          Location?: string;
        };
        content: {
          "application/json": {
            /** @example iz0g457ikesz55dhxcfa0fk9yy */
            id: string;
          };
        };
      };
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Get a playbook */
  getPlaybook: {
    parameters: {
      path: {
        /** @description ID of the playbook to retrieve. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook. */
      200: {
        content: {
          "application/json": components["schemas"]["Playbook"];
        };
      };
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Update a playbook */
  updatePlaybook: {
    parameters: {
      path: {
        /** @description ID of the playbook to update. */
        id: string;
      };
    };
    /** @description Playbook payload */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["Playbook"];
      };
    };
    responses: {
      /** @description Playbook succesfully updated. */
      200: never;
      400: components["responses"]["400"];
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Delete a playbook */
  deletePlaybook: {
    parameters: {
      path: {
        /** @description ID of the playbook to delete. */
        id: string;
      };
    };
    responses: {
      /** @description Playbook successfully deleted. */
      204: never;
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
  /** Get the list of followers' user IDs of a playbook */
  getAutoFollows: {
    parameters: {
      path: {
        /** @description ID of the playbook to retrieve followers from. */
        id: string;
      };
    };
    responses: {
      /** @description List of the user IDs who follow the playbook. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybookAutofollows"];
        };
      };
      403: components["responses"]["403"];
      500: components["responses"]["500"];
    };
  };
}
